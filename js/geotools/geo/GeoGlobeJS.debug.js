window.Geo = {
    singleFile: true
};


//装载GeoSurfJSAPI库文件
(function(){
    /**
     * Namespace: Geo
     * Geo 是整个 GeoGlobeSDK 地图 API 的命名空间，本手册中介绍的所有类和对象都通过 Geo.XXX 的方式调用。
     * 如创建一个 LonLat 对象：new Geo.LonLat(121.123458,34.534227)。
     */
    window.Geo = window.Geo || {};
    window.Geo.Service = {};
    window.Geo.Query = {};
    window.Geo.Tdt = {};	
    window.Geo.Math = {};
    window.Geo.Analysis = {};
    window.Geo.View2D = {};
    window.Geo.View2D.Control = OpenLayers.Control;    
    window.Geo.View3D = {};
    window.Geo.View3D.Event = {};
    //基本类型对象
    window.Geo.Bounds = OpenLayers.Bounds;
    window.Geo.Class = OpenLayers.Class;
    window.Geo.LonLat = OpenLayers.LonLat;
    window.Geo.Pixel = OpenLayers.Pixel;
    window.Geo.Size = OpenLayers.Size;
    window.Geo.Element = OpenLayers.Element;
	window.Geo.Date = OpenLayers.Date;
	//基类
    window.Geo.Feature = OpenLayers.Feature;
    window.Geo.Filter = OpenLayers.Filter;
    window.Geo.Format = OpenLayers.Format;
    window.Geo.Geometry = OpenLayers.Geometry;
    window.Geo.View2D.Handler = OpenLayers.Handler;
    window.Geo.View2D.Layer = OpenLayers.Layer;
    window.Geo.View2D.Popup = OpenLayers.Popup;
    window.Geo.Protocol = OpenLayers.Protocol;
    window.Geo.Request = OpenLayers.Request;
    window.Geo.Strategy = OpenLayers.Strategy;
    window.Geo.Symbolizer = OpenLayers.Symbolizer;
    window.Geo.View2D.Tile = OpenLayers.Tile;
    window.Geo.View2D.Icon = OpenLayers.Icon;
    window.Geo.Projection = OpenLayers.Projection;
    window.Geo.Rule = OpenLayers.Rule;
    window.Geo.Style = OpenLayers.Style;
    window.Geo.Style2 = OpenLayers.Style2;
    window.Geo.StyleMap = OpenLayers.StyleMap;
	window.Geo.Marker = OpenLayers.Marker;
	window.Geo.Event  = OpenLayers.Event;
	window.Geo.Events  = OpenLayers.Events;
	window.Geo.Util  = OpenLayers.Util;
	window.Geo.Console  = OpenLayers.Console;
	window.Geo.Lang  = OpenLayers.Lang;
	window.Geo.Kinetic  = OpenLayers.Kinetic;
	//Geo.View2D.Event已废弃，由Geo.Event取代
    window.Geo.View2D.Event = OpenLayers.Event;
	//Geo.View2D.Events已废弃，由Geo.Events取代
    window.Geo.View2D.Events = OpenLayers.Events;
	//BaseTypes.js中的基本对象类
	window.Geo.String = OpenLayers.String;
	window.Geo.Number = OpenLayers.Number;
	window.Geo.Function = OpenLayers.Function;
	window.Geo.Array = OpenLayers.Array;
	
    if (!Geo.singleFile) {
	    //导入js文件库
	    var scriptName = "GeoGlobeJSAPI.js";
	    var jsfiles = [
			"Animator.js",
			"AnimateZoomer.js",
	        "Util.js", 
			"Pyramid.js", 
			"SymbolizerManager.js", 
			"GeoMarker.js", 
			"hotfix_ol2_13.js",
			"Util/Uuid.js",
			"Util/Heatmap.js",
			"Util/Format/BusCapabilities.js",
			"Util/Format/GlobeTileCapabilities.js",
			"Util/Format/Pyramid.js",
	        "Util/Format/XML2JSON.js",
	        "Util/Format/VwmtsGetVersionInfo.js",
	        "Util/Format/VwmtsGetVersions.js",
			"Util/Format/VWMTSCapabilities.v1_0_0.js",
			"Util/Format/MapServiceQuery.js",
			"Util/Format/GeoTextFeatures.js",
			"Util/GeoAvoidObject.js",
			"Util/GeoPreAvoidContainer.js",
			
			"View2D/Map.js", 
			"View2D/Tile/TileFeature.js",
			"View2D/Layer/CWMS.js",
			"View2D/Layer/GlobeTile.js",
			"View2D/Layer/GeoWMTS.js",
			"View2D/Layer/DynamicMapService.js",
			"View2D/Layer/TileMapService.js",
			"View2D/Layer/GeoMarkers.js",
			"View2D/Layer/ArcGISTileLayer.js",
			"View2D/Layer/Buildings.js",
			"View2D/Layer/GeoThematicLayer.js",
			"View2D/Layer/HeatMapLayer.js",
			"View2D/Layer/ThematicTile.js",
			"View2D/Layer/GeoText.js",
			"View2D/Layer/HotareaWMTS.js",
	        "View2D/BaseLayerGroup.js", 
			"View2D/LayerGroup.js", 
			"View2D/FeatureManager.js", 
			"View2D/MarkerTag.js", 
			"View2D/Control/DrawCircle.js", 
			"View2D/Control/DrawPath.js", 
			"View2D/Control/DrawPoint.js", 
			"View2D/Control/DrawPolygon.js", 
			"View2D/Control/DrawRectangle.js",
			"View2D/Control/MagnifyingGlass.js",
			"View2D/Control/GeoPanZoom.js",
			"View2D/Control/PanZoomBarTitle.js",
			"View2D/Control/GeoOverviewMap.js",
			"View2D/Control/GeoSelectFeature.js",
			"View2D/Control/ZoomBar.js",
			"View2D/Control/Measure/AreaMeasure.js",
			"View2D/Control/Measure/DistanceMeasure.js",
			"View2D/Control/Measure/Angle.js",
			"View2D/Control/Measure/AngleMeasure.js",
			"View2D/Control/MapContextMenu.js",
			"View2D/Control/TimeSlider.js",
			"View2D/Control/PrintMap.js",
			"View2D/MenuItem.js",
			"View2D/TemporalRenderer.js",
			"View2D/ChartContainer.js",
			"View2D/Popup/GeoFrameCloud.js",
		/*
	        "ViewFl/swfobject.js",
	        "ViewFl/Map.js",
	        "ViewFl/Layer.js",
	        "ViewFl/Layer/GlobeTile.js",
			"ViewFl/Layer/WMTS.js",
			"ViewFl/Layer/WMS.js",
	        "ViewFl/Layer/Vector.js",
	        "ViewFl/BaseLayerGroup.js",
			"ViewFl/Handler.js",
	        "ViewFl/Handler/Point.js",
	        "ViewFl/Handler/Path.js",
	        "ViewFl/Handler/Polygon.js",
			"ViewFl/Handler/Click.js",
	        "ViewFl/Control.js",
	        "ViewFl/Control/Navigation.js",
	        "ViewFl/Control/PanZoom.js",
	        "ViewFl/Control/PanZoomBar.js",
	        "ViewFl/Control/ScaleLine.js",
	        "ViewFl/Control/MousePosition.js",
	        "ViewFl/Control/OverviewMap.js",
	        "ViewFl/Control/DrawFeature.js",
	        "ViewFl/Control/LayerScroll.js",
	        "ViewFl/Control/Measure.js",
	        "ViewFl/Control/SelectFeature.js",
	        "ViewFl/Control/ModifyFeature.js",
			"ViewFl/Control/ZoomBox.js",
			"ViewFl/Control/Mouse.js",
			"ViewFl/Control/SituationControl.js",
			"ViewFl/Control/GeoLayerManager.js",
			"ViewFl/Control/MeasureToolControl.js",
	        "ViewFl/Popup.js",
			"ViewFl/PopupFl.js",
			"ViewFl/Popup/Anchored.js",
			"ViewFl/Popup/AnchoredBubble.js",
			"ViewFl/Popup/Framed.js",
	        "ViewFl/Popup/FramedCloud.js",
			"ViewFl/Popup/FramedCloudFl.js",
		*/
			"View3D/Map.js", 
			"View3D/Layer.js", 
	        "View3D/BaseLayerGroup.js",
			"View3D/LayerGroup.js", 
			"View3D/Layer/GlobeTile.js", 
			"View3D/Layer/ArcgisRest.js",
			"View3D/Layer/Shape.js", 
			"View3D/Layer/Terrain.js", 
			"View3D/Layer/Vector.js", 
			"View3D/Layer/WMS.js", 
			"View3D/Layer/WMTS.js", 
			"View3D/Layer/WFS.js", 
			"View3D/Layer/WTFS.js", 
	        "View3D/Layer/Solid.js", 
	        "View3D/Layer/WCS.js", 
	        "View3D/Layer/Grid.js", 
	        "View3D/Layer/Model.js", 
			"View3D/Event/MouseEvent.js", 
			"View3D/Event/KeyEvent.js", 
			"View3D/Handler.js", 
			"View3D/Handler/KeybordDefaults.js", 
			"View3D/Handler/Mouse.js", 
			"View3D/Handler/Point.js", 
			"View3D/Handler/Path.js",
			"View3D/Handler/Polygon.js",
			"View3D/Handler/Box.js",
			"View3D/Handler/ModelChoose.js",
			"View3D/Handler/Feature.js",
			"View3D/Handler/Keyboard.js",
			"View3D/Control.js", 
			"View3D/Control/KeyboardDefaults.js", 
			"View3D/Control/Measure.js", 
			"View3D/Control/DrawPath.js", 
			"View3D/Control/DrawPoint.js", 
			"View3D/Control/DrawPolygon.js", 
			"View3D/Control/DrawFeature.js",
			"View3D/Control/SelectFeature.js", 
			"View3D/Control/Attribution.js",
			"View3D/Control/Box.js",
			"View3D/Control/Mouse.js",
			"View3D/Control/ModelChoose.js",
			"View3D/Control/Analysis.js",
			"View3D/Control/Keyboard.js",
			"View3D/Control/DrawBox.js", 
			"View3D/Fly.js", 
			"View3D/Popup.js", 
			"View3D/Popup/FramedCloud.js", 
			"View3D/FeatureManager.js", 
			"View3D/Control/Measure/PointInfo.js", 
			"View3D/Control/Measure/Distance.js", 
			"View3D/Control/Measure/Area.js", 
			"View3D/Control/Measure/Volume.js", 
			"View3D/Control/Measure/Excavate.js", 
			"View3D/Control/Measure/Flood.js", 
			"View3D/Control/Measure/Profile.js", 
			"View3D/Control/Measure/TwoPointThrough.js", 
			"CombineView.js", 
			"LayerManager.js", 
			"Request.js",
			"Analysis/AreasAndLengthsParameters.js", 
			"Analysis/BufferAnalysis.js",
			"Analysis/BufferParameters.js",
			"Analysis/DensifyParameters.js",
			"Analysis/DistanceParameters.js",
			"Analysis/GeneralizeParameters.js",
			"Analysis/GeometryService.js",
			"Analysis/LengthsParameters.js",
			"Analysis/OffsetParameters.js",
			"Analysis/ProjectParameters.js",
			"Analysis/RelationParameters.js",
			"Analysis/SuperposeAnalysis.js",
			"Analysis/TrimExtendParameters.js",
			"Analysis/Util.js", 
			"Query/WFSQuery.js", 
			"Query/WFSQueryForPage.js", 
			"Query/CatalogQuery.js", 
			"Query/ModelQuery.js", 
			"Query/MapServiceQuery.js",
			"Query/MapServiceQueryParameters.js",
			"Query/MapServiceQueryResult.js",
			"Query/MapServiceIdentify.js",
			"Query/MapServiceIdentifyParameters.js",
			"Query/MapServiceIdentifyResult.js",
			"Query/MapServiceDataFeatures.js",
			"Query/MapServiceDataFeaturesParameters.js",
			"Query/MapServiceDataFeaturesResult.js",
			"Query/MapServiceFind.js",
			"Query/MapServiceFindParameters.js",
			"Query/MapServiceFindResult.js",
			"Query/GeoCodingQuery.js",
			"Query/GeoCodingQuery/v1.js",
			"Query/GeoCodingQuery/v1_0_0.js",
			"Query/GeoCodingQuery/v1_1_0.js",
			
			"Tdt/Busline.js",
			"Tdt/BuslineQuery.js",
			"Tdt/BuslineQueryResult.js",
			"Tdt/BuslineSegment.js",
			"Tdt/ChangeCity.js",
			"Tdt/DriveQuery.js",
			"Tdt/DriveQueryResult.js",
			"Tdt/PlaceQuery.js",
			"Tdt/PlaceQueryResultPios.js",
			"Tdt/PlaceQueryResultStatistics.js",
			"Tdt/Util.js",
			"Tdt/Weather.js",
			
			"Strategy/AttributeCluster.js",
			"Strategy/GeoTextXYZ.js",
			
			"Service.js", 
			"Service/GlobeTile.js", 
			"Service/Bus.js", 
			"Service/Plot.js", 
			"Service/ShortestPath.js", 
			"Service/Route.js", 
			"Service/TAS.js", 
			"Service/WPS.js",
			"Service/WFS.js",  
			"Service/WFST.js",  
			"Service/WMS.js",
			"Service/WMTS.js",
			"Service/GeoWMTS.js",
			"Service/WCS.js",  
			"Service/CSW.js",
			"Service/CWMS.js",
	 		"Service/MapService.js",
			"Service/MapServiceLayerDetail.js",
			"Service/GeoCoding.js",
			"Service/GeoRoute.js",
			"Service/GeoRouteInfoResult.js",
			"Service/GeoRoutesResult.js",
			"Service/GeoText.js",
			"Service/Thematic.js"
			
		];
	    
	    var scriptLocation = "";
	    var isGlb = new RegExp("(^|(.*?\\/))(" + scriptName + ")(\\?|$)");
	    
	    var scripts = document.getElementsByTagName('script');
	    for (var i = 0, len = scripts.length; i < len; i++) {
	        var src = scripts[i].getAttribute('src');
	        if (src) {
	            var match = src.match(isGlb);
	            if (match) {
	                scriptLocation = match[1];
	                break;
	            }
	        }
	    }
	    
	    var agent = navigator.userAgent;
	    var docWrite = (agent.match("MSIE") || agent.match("Safari"));
	    if (docWrite) {
	        var allScriptTags = new Array(jsfiles.length);
	    }
	    
	    for (var i = 0, len = jsfiles.length; i < len; i++) {
	        if (docWrite) {
	            allScriptTags[i] = "<script src='" + scriptLocation + jsfiles[i] +
	            "'></script>";
	        }
	        else {
	            var s = document.createElement("script");
	            s.src = scriptLocation + jsfiles[i];
	            var h = document.getElementsByTagName("head").length ? document.getElementsByTagName("head")[0] : document.body;
	            h.appendChild(s);
	        }
	    }
	    if (docWrite) {
	        document.write(allScriptTags.join(""));
	    }
	}


	/**
	 * Property: scriptName
	 * {String} GeoGlobeJSAPI脚本文件名，默认值为"GeoGlobeJSAPI.js"。当前使用Geo.getScriptLocation方法
	 * 时，该方法将依据本属性值获取GeoGlobeJSAPI所在目录路径。如果引入GeoGlobeJSAPI所用的脚本文件名
	 * 不为默认值"GeoGlobeJSAPI.js"，用户可以根据实际情况自己修改。
	 */
	Geo.scriptName = (!Geo.singleFile) ? "GeoGlobeJSAPI/GeoGlobeJSAPI.js" : "GeoGlobeJS.min.js";
	
	/**
	 * Method: getScriptLocation
	 * 获取GeoGlobeJSAPI脚本文件名库脚本文件所在路径。
	 *
	 * Returns:
	 * {String} GeoGlobeJSAPI脚本文件所在路径。
	 */
	Geo.getScriptLocation = function () {
		var scriptLocation = "";            
		var isGV = new RegExp("(^|(.*?\\/))(" + Geo.scriptName + ")(\\?|$)");
	 
		var scripts = document.getElementsByTagName('script');
		for (var i=0, len=scripts.length; i<len; i++) {
			var src = scripts[i].getAttribute('src');
			if (src) {
				var match = src.match(isGV);
				if(match) {
					scriptLocation = match[1];
					break;
				}
			}
		}
		return scriptLocation;
	};
	
	/**
	 * Property: imagesPath
	 * {String} 指定图片所在路径,三维插件只能接受绝对地址的图片，此处图片路径如:http:www.geostar.com.cn/images/ 或 c:\\images\\。
	 */
	Geo.imagesPath = "";
	
	/**
	 * Method: createNS
	 * 创建名字空间,如果指定名字空间中的某一级已经存在不会覆盖已有内容。
	 * 
	 * Parameters:
	 * ns - {String} 名称空间。
	 * 
	 */		
	Geo.createNS = function(ns){
		var nsArr = ns.split(".");
		var currObj = window;
		for(var i=0; i<nsArr.length; i++){
			if(!currObj[nsArr[i]]){
				currObj[nsArr[i]] = {};
			}
			currObj = currObj[nsArr[i]];
		}
	}
	
	//此方法已废弃，更换为Geo.Request.setProxyHost
	Geo.setProxyHost = function(proxyHost){
		OpenLayers.ProxyHost = proxyHost;
	}
	
	//此方法已废弃，更换为Geo.Request.getProxyHost
	Geo.getProxyHost = function(){
		return OpenLayers.ProxyHost;
	}
	
    /**
	 * APIProperty: setDPI
	 * 设置DPI。即屏幕上的地图图片中，多少个屏幕像素点代表一英寸的距离。
	 * 
	 * Parameters:
	 * dpi - {Number} 一英寸的像素点个数。
	 */
	Geo.setDPI = function(dpi){
		if(!dpi){
			return;
		}
		OpenLayers.DOTS_PER_INCH = dpi;
	}
	
    /**
	 * Property: VERSION_NUMBER
	 * GeoGlobeSDK JS API的版本号。
	 */
	Geo.VERSION_NUMBER = "GeoGlobeJSAPI 5.2 -- $Version: 1.20.67 build-20141022 $";
	
	// 减少地图上一屏范围内对瓦片服务访问的次数。
	OpenLayers.Layer.WMTS.prototype.buffer = 0;
	OpenLayers.Layer.WMS.prototype.buffer = 0;
	// 修改拖拽地图时的“动能”滑动效果的摩擦系数，默认值设置为0.0035。值越大，摩擦力越大，滑动距离越小。
	OpenLayers.Kinetic.prototype.deceleration = 0.0033;
	//修改显示比例尺的单位
	OpenLayers.INCHES_PER_UNIT["公里"] = OpenLayers.INCHES_PER_UNIT["km"];
	OpenLayers.INCHES_PER_UNIT["米"] = OpenLayers.INCHES_PER_UNIT["m"];
	OpenLayers.INCHES_PER_UNIT["英里"] = OpenLayers.INCHES_PER_UNIT["mi"];
	OpenLayers.INCHES_PER_UNIT["英寸"] = OpenLayers.INCHES_PER_UNIT["ft"];
	//设置ol的国际化语言为中文
	OpenLayers.Lang.setCode("zh-CN");
})()


/**
 * Class: Geo.Animator
 * 矢量要素移动动画类。可以实现点要素在指定线要素上的移动，并且能控制移动的速度。
 */
Geo.Animator = Geo.Class({

    /**
     * APIProperty: id
     * {String} 唯一标识。
     */
    id: null,
    
    //动画队列
    _queue:null,
    
    //当前播放索引
    _currentIndex:0,

    /**
     * APIProperty: feature
     * {<Geo.Feature.Vector>} 动画要素。
     */    
    feature: null,

    /**
     * Property: isRepeat
     * {Boolean} 是否重复播放动画，默认为值true。
     */     
    isRepeat: true,


    /**
     * APIProperty: frequence
     * {Boolean} 刷新频率，默认值为5（单位：毫秒）。
     */      
    frequence: 5,
    
    /**
     * Constructor: Geo.Animator
     * 构造函数。矢量要素动画类实例。
     *
     * Parameters:
     * options - {Object} 对象相关选项设置。
     */
    initialize: function(options){
        this.id = OpenLayers.Util.createUniqueID("Geo.Animater_");
        this._queue = [];
    },
	
    /**
     * APIMethod: isPlaying
     * 是否在播放动画。
     * 
     * Returns:
     * {Boolean} 返回播放状态，true表示正在播放，false表示停止播放。
     */     
    isPlaying: function(){
		var length = this._queue.length;
		if(this._currentIndex == (length - 1)){
			return false;
		}else{
			return true;
		}
	},
	
    /**
     * APIMethod: isAtStart
     * 是否在起点。
     * 
     * Returns:
     * {Boolean} 返回是否在起点的状态，true表示在起点，false表示不在。
     */     
	isAtStart: function(){
		if(this._currentIndex == 0){
			return true;
		}else{
			return false;
		}
	},	
	
    /**
     * APIMethod: isAtEnd
     * 是否在终点。
     * 
     * Returns:
     * {Boolean} 返回是否在终点的状态，true表示在终点，false表示不在。
     */     
	isAtEnd: function(){
		var length = this._queue.length;
		if(this._currentIndex == (length - 1)){
			return true;
		}else{
			return false;
		}
	},	
    
	/**
     * APIMethod: setFeature
     * 添加动画要素。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 被移动的要素。
     */	
    setFeature:function(feature){
        this.feature = feature;
    },  
    
	/**
     * APIMethod: start
     * 开始播放动画。
     */	
    start: function(){
        var item = this._queue[this._currentIndex];
        if(item){
            var fn = OpenLayers.Function.bind(function(){
                this._stepRun(item);
            },this);
            item.interval = window.setInterval(fn, this.frequence);
        }
    }, 
    
	/**
     * APIMethod: stop
     * 停止播放动画。
     */	
    stop: function(){
        this._currentIndex = 0;
        
        //清掉队列中所有的计数器
        for(var i=0; i<this._queue.length; i++){
            var item = this._queue[i];
            window.clearInterval(item.interval);
            item.counter = 0;
        }
    },
    
	/**
     * APIMethod: pause
     * 暂停播放动画。
     */	
    pause: function(){
        var item = this._queue[this._currentIndex];
        window.clearInterval(item.interval);
    },
    
    _getQueueItem: function(){
        return {
            counter: 0,
            isStop: false,
			moveType:"velocity",
            doFn: function(){},
            checkStopFn: function(){
                return false;
            },
            interval: null,
            options: {}
        };
    },
    
    _addItem: function(doFn,checkStopFn,options){
        var item = this._getQueueItem();
        if(doFn){
            item.doFn = OpenLayers.Function.bind(doFn,this);
        }
        
        if(checkStopFn){
            item.checkStopFn = OpenLayers.Function.bind(checkStopFn,this);
        }
        item.options = options;
        this._queue.push(item);
    },
    
    _stepRun: function(item){
        
        
        var isStop = item.checkStopFn();
        if(!isStop){
            item.doFn(item);
            item.counter++;
        } else {
            window.clearInterval(item.interval);
            item.counter = 0;
            
            var next = OpenLayers.Util.indexOf(this._queue,item) + 1;
            var nextItem = this._queue[next];
            if(next !== 0 && nextItem){
                var fn = OpenLayers.Function.bind(function(){
                    this._stepRun(nextItem);
                },this);
                nextItem.interval = window.setInterval(fn,5);
                this._currentIndex = next;
            } else {
                this._currentIndex = 0;
                this.onStop();
            }
        }
        
    },
    
    onStop: function(){},
    
    onChange: function(feature,type){},
    
	/**
     * APIMethod: moveTo
     * 移动到指定位置。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * options - {Object} json格式的参数。
     * 
     * Returns:
     * {<Geo.Animator>}  矢量要素动画类对象。
     */	
    moveTo: function(lonlat,options){
        
        var feature = this.feature;
        var featureLonlat = new Geo.LonLat(feature.geometry.x,
                                                  feature.geometry.y);
        
        options = options || {};
		//默认步长是0.01
        var moveRatio = options.ratio || 0.01;
		var moveType = options.moveType || "velocity";
        options = {
            from: null,
            to: lonlat,
            currentPosition: null, //featureLonlat,
            moveType:moveType,
            step: moveRatio
        };
        
        var doFn = function(item){
            var feature = this.feature;
            var item = this._queue[this._currentIndex];
            this._moveFeature(feature,item);
            this.onChange(feature,"move");
        };
        
        var checkStopFn = function(){
            var item = this._queue[this._currentIndex];
            var currentPosition = new Geo.LonLat(feature.geometry.x,
                                                        feature.geometry.y);
            var options = item.options;
            options.from = options.from || currentPosition;
            options.currentPosition = currentPosition;
            
            var from = options.from;
            var to = options.to;
            
            return this._checkIsOver(from, to, currentPosition);
        }
        
        this._addItem(doFn, checkStopFn, options);
        return this;
    },
    
	/**
     * APIMethod: moveAlong
     * 沿路径移动。
     * 
     * Parameters:
     * path - {<Geo.Feature.Vector>} 路径线要素对象。
     * options - {Object} json格式的参数。
     * > ratio - {Number} 可选值，表示移动速度，缺省值是0.01。
     * > moveType - {String} 可选值，表示移动的方式，缺省值是"velocity"，可选值为："velocity"、"same_step"。
     * > "velocity"表示要素以ratio度的速度做匀速运动；"same_step"表示要素以ratio值的步长单位匀速运动。
     *
     * Examples:
	 * (code)
	 *      //设置路线以及速度
	 *  	animator.moveAlong(roadLine,{
	 *			ratio : 0.01 ,
	 *     		moveType : "velocity"
	 *		});
	 * (end)
     */	
    moveAlong: function(path,options){
        var nodes;
        if(path.CLASS_NAME == "OpenLayers.Feature.Vector"){
            nodes = this._getLonLatFromGeometry(path.geometry);
        }
        
        
        for(var i=0; i<nodes.length; i++){
            var newOptions = OpenLayers.Util.extend({},options);
            if(i==0){
                newOptions.ratio = 1;
            }
            this.moveTo(nodes[i],newOptions);
            
        }

    },
    
    _getLonLatFromGeometry: function(geometry){

        var points = geometry.components;
        var lonlats = [];
        for(var i=0; i<points.length; i++){
            lonlats.push(new Geo.LonLat(points[i].x,
                                               points[i].y));
        }
        return lonlats;
    },
    
    _moveFeature: function(feature,item){

        var options = item.options;
        var to = options.to;
        if(item.counter == 0){
            options.from = new Geo.LonLat(feature.geometry.x,
                                             feature.geometry.y);
        }
        var from = options.from;

        var percent = options.step;
        var lonlat = this._getMoveLonLat[options.moveType](from, to, percent * item.counter, percent);
        var angle = this._getMoveDirection(from, to);
        feature.style.rotation = angle;
        feature.move(lonlat);
        options.currentPosition = lonlat;

    },
    
    //检查是否过了
    _checkIsOver: function(from,to,middle){
        if(middle.lon == to.lon && middle.lat == to.lat){
            return true;
        }
        var isXOver = false, isYOver = false;
        var big, small;
        
        if(from.lon < to.lon){
            big = to.lon;
            small = from.lon;
        } else {
            small = to.lon;
            big = from.lon;
        }
        isXOver = (middle.lon > big) || (middle.lon < small);
        
        if(from.lat < to.lat){
            big = to.lat;
            small = from.lat;
        } else {
            small = to.lat;
            big = from.lat;
        }        
        isYOver = (middle.lat > big) || (middle.lat < small);
        
        return (isYOver && isYOver);
    },
    
    animate:function(){},
    
    fadeIn:function(){},
    
    fadeOut:function(){},
    
    hide:function(){},
    
    show:function(){},

    
    /**
     * 该方法用于返回一条线上的某一点的X坐标或Y坐标。
     * parameters:
     * from - {Number} 表示x或y。
     * to - {Number}表示x或y。
     *     当v1为某一点的x 坐标时，v2为另一点的x坐标。
     *     当v1为某一点的y 坐标时，v2为另一点的y坐标。
     *
     * percent表示步长。
     */
    _getMoveLonLat: {
		//匀速运动
		"same_step" : function(from, to, percent, step){
	        if(percent > 1){
	            percent = 1;
	        }
	        var lon, lat;
	        if(from.lon === to.lon ){
	            lon = from.lon;
	        } else {
	            lon = from.lon + percent * (to.lon - from.lon);
	        }
	        if (from.lat === to.lat) {
	            lat = from.lat;
	        } else {
	            lat = from.lat + percent * (to.lat - from.lat);
	        }
	        
	        if(from.lon < to.lon){
	            lon = (lon > to.lon) ? to.lon : lon;
	            lon = (lon < from.lon) ? from.lon : lon;
	        } 
	        if(from.lon > to.lon){
	            lon = (lon < to.lon) ? to.lon : lon;
	            lon = (lon > from.lon) ? from.lon : lon;
	        }
	        if(from.lat < to.lat){
	            lat = (lat > to.lat) ? to.lat : lat;
	            lat = (lat < from.lat) ? from.lat : lat;
	        } 
	        if(from.lat > to.lat){
	            lat = (lat < to.lat) ? to.lat : lat;
	            lat = (lat > from.lat) ? from.lat : lat;
	        }
	        return new Geo.LonLat(lon,lat);
	    },
		//相同的步长
		"velocity"	:	function(from, to, percent, step){
			var geo = (new OpenLayers.Geometry.Point(from.lon, from.lat)).distanceTo(new OpenLayers.Geometry.Point(to.lon, to.lat));
			var stepX = (to.lon - from.lon) / geo * step;
			var stepY = (to.lat - from.lat) / geo * step;
	        var lon, lat;
	        if(from.lon === to.lon ){
	            lon = from.lon;
	        } else {
	            lon = from.lon + stepX * percent;
	        }
	        if (from.lat === to.lat) {
	            lat = from.lat;
	        } else {
	            lat = from.lat + stepY * percent;
	        }
	        
	        if(from.lon < to.lon){
	            lon = (lon > to.lon) ? to.lon : lon;
	            lon = (lon < from.lon) ? from.lon : lon;
	        } 
	        if(from.lon > to.lon){
	            lon = (lon < to.lon) ? to.lon : lon;
	            lon = (lon > from.lon) ? from.lon : lon;
	        }
	        if(from.lat < to.lat){
	            lat = (lat > to.lat) ? to.lat : lat;
	            lat = (lat < from.lat) ? from.lat : lat;
	        } 
	        if(from.lat > to.lat){
	            lat = (lat < to.lat) ? to.lat : lat;
	            lat = (lat > from.lat) ? from.lat : lat;
	        }
	        return new Geo.LonLat(lon,lat);
	    }
	},
    
    
    /**
     * 该方法用于得到一条线的上的坐标，返回的坐标个数由用户输入的pointNum决定。
     * parameters:
     * from - {Object} 表示点坐标 例如:{x:10,y:10}。
     * to - {Object} 表示点坐标  例如:{x:5,y:5}。
     * pointNum {Number} 表示在该线上取多少个临时点。
     */
    _getPointsByNum: function(from, to, pointNum){
        var x1 = from.x;
        var y1 = from.y;
        var x0;
        var y0;
        var x2 = to.x;
        var y2 = to.y;
        var points = [];
        percentX = (x2 - x1) / (pointNum - 1);
        percentY = (y2 - y1) / (pointNum - 1);
        for (var i = 0; i < pointNum; i++) {
            x0 = x1 + percentX * i;
            y0 = y1 + percentY * i;
            points.push([x0, y0]);
        }
        return points;
    },
    
    /**
     * 该方法根据步长得到临时点。
     * parameters:
     * from - {Object} 表示线的一端。
     * to - {Object} 表示线的另一端。
     * percent 表示步长。
     */
    _getAllTempPointByPercent: function(from, to, percent){
        var tempPointArr = [];
        var i = 0;
        while (i < 1) {
            var x = getXorY(from.x, to.x, i);
            var y = getXorY(from.y, to.y, i);
            tempPointArr.push([x, y]);
            i += percent;
        }
        if (i >= 1) {
            tempPointArr.push([to.x, to.y]);
        }
        return tempPointArr;
    },
    
    //获取两点间线的角度
    _getMoveDirection: function(from, to){
        //以浮点型表示角度
        var dRotateAngle = Math.atan2(Math.abs(from.lon - to.lon), Math.abs(from.lat - to.lat));
        if (to.lon >= from.lon) {
            //第一象限
            if (to.lat >= from.lat) {
                dRotateAngle = dRotateAngle;
            }
            else {
                //第四象限
                dRotateAngle = Math.PI - dRotateAngle;
            }
            
        }
        else {
            //第二象限
            if (to.lat >= from.lat) {
                dRotateAngle = 2 * Math.PI - dRotateAngle;
            }
            else {
                //第四象限
                dRotateAngle = Math.PI + dRotateAngle;
            }
        }
        var angle = (dRotateAngle * 180) / Math.PI;
        return angle;
        
    },
    
    CLASS_NAME: "Geo.Animator"
});

/**
 * Class: Geo.AnimateZoomer
 * 地图图层的平滑缩放效果类。
 */
Geo.AnimateZoomer = Geo.Class({

    /**
     * Property: map
     * {<Geo.View2D.Map>} 二维地图对象。
     */
    map: null,
    
    /**
     * Property: currentStep
     * 动画当前帧号。
     */
    currentStep: 0,
    
    /**
     * APIProperty: totalStep
     * 动画帧数。
     */
    totalStep: 4,
    
    /**
     * APIProperty: intervalTime
     * 每帧间隔时间。
     */
    intervalTime: 90,
    
    /**
     * Property: animateIntervalId
     * 动画IntervalId。
     */
    animateIntervalId: null,
    
    /**
     * Property: bufferLayerContainer
     * 缓存图层容器，用于放置实现平滑效果的临时缓存图层。
     */
    bufferLayerContainer: null,
    
    /**
     * Property: zoomStep
     * 目标级别和当前级别的级别差。
     */
    zoomStep: null,
    
    /**
     * Property: layerLoaded
     * 当前平滑缩放的图层是否马上清除。
     */
    layerLoaded: false,
    
	/**
	 * Property: oraginPoint
	 * 原点位置。
	 */
    oraginPoint: null,
    
    /**
     * Constructor: Geo.AnimateZoomer
     * 构造函数。生成一个地图图层的平滑缩放效果对象。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 二维地图对象。
     * options - {Object} 相关选项设置。
     */
    initialize: function(map, options){
		this.handlers = {};
        if (map) {
            this.setMap(map);
        }
		OpenLayers.Util.extend(this, options);
		if (this.id == null) {
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }
    },
    
	/**
     * Method: setMap
     * 关联地图。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 二维地图对象。
	 */
    setMap: function(map){
        this.map = map;
        this.map.baseLayer.events.register("loadend", this, function(){
            this.layerLoaded = true;
            if (!this.isZoomAnimating()) {
                this.clearBufferLayer();
            }
        });
        
        this.handlers.wheel = new OpenLayers.Handler.MouseWheel(this, {
            "up": this.wheelUp,
            "down": this.wheelDown
        }, this.mouseWheelOptions);
		this.handlers.wheel.activate();
		
		var navs = this.map.getControlsByClass("OpenLayers.Control.Navigation");
		if(navs.length != 0){
			navs[0].disableZoomWheel();
		}

    },
	
    /** 
     * Method: wheelUp
     * 鼠标滚轮向上滚动。
     * 
     * Parameters:
     * evt - {Event}
     * delta - {Integer}
     */
    wheelUp: function(evt, delta) {
		var zoom = this.map.getZoom() + 1;
		if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
		if (this.map.enableAnimateZoomer) {
			this.playZoomAnimate(zoom, true);
		}
		this.wheelChange(evt, delta || 1);
    },

    /** 
     * Method: wheelDown
     * 鼠标滚轮向下滚动。
     * 
     * Parameters:
     * evt - {Event}
     * delta - {Integer}
     */
    wheelDown: function(evt, delta) {
		var zoom = this.map.getZoom() -1;
        if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
        if (this.map.enableAnimateZoomer) {
            this.playZoomAnimate(zoom, true);
        }
		this.wheelChange(evt, delta || -1);
    },
	
	/**
     * APIMethod: zoomIn
     * 地图放大一级。
	 */
    zoomIn: function(){
        this.zoomTo(this.map.getZoom() + 1);
    },
	
	/**
     * APIMethod: zoomOut
     * 地图缩小一级。
	 */
    zoomOut: function(){
        this.zoomTo(this.map.getZoom() - 1);
    },
    
    /** 
     * APIMethod: zoom
     * 平滑缩放至指定的级别。
     *
     * Parameters:
     * zoom - {Integer}
     */
    zoomTo: function(zoom){
        if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
		if (this.map.enableAnimateZoomer) {
			//this.layerLoaded = false;
        	this.playZoomAnimate(zoom);
		}
        this.map.zoomTo(zoom);
    },
    
    /** 
     * APIMethod: zoom
     * 地图缩放 zoomStep 级别。
     * 
     * Parameters:
     * zoomStep - {Integer} 目标级别和当前级别的级别差。
     */
    zoom: function(zoomStep){
        var map = this.map
        var zoom = map.getZoom() + zoomStep;
        
        if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
        this.playZoomAnimate(zoom);
        this.map.zoomTo(zoom);
    },
    
	/** 
     * APIMethod: playZoomAnimate
     * 开始播放动画。
     * 
     * Parameters:
     * zoom - {Integer} 目标级别。
     * lonlat - {<Geo.LonLat>} 平滑缩放的中心点，如果为null，则为地图的中心点。
     */
    playZoomAnimate: function(zoom, lonlat){
        if (lonlat) {
            // 设置为true。则鼠标滚轮滚动时，以鼠标光标为中心点扩散平滑缩放。
            this.zoomAnimateWheelEnabled = true;
        }
        else {
            // 设置为false。则级别平滑缩放，以地图中心点扩散平滑缩放。
            this.zoomAnimateWheelEnabled = false;
        }
        
        this.currentStep = 0;
        this.currentStep++;
        
        if (this.isZoomAnimating()) {
            this.stopZoomAnimate();
        }
        
        this.clearBufferLayer();
        
        //var layer = this.map.baseLayer;layer
        
        this.cloneLayersTile();
        
        if (this.bufferLayerContainer.childNodes.length == 0) {
            return;
        }
        
        this.hiddenAllLayers();
        
        var currentZoom, targetZoom;
        currentZoom = this.map.getZoom();
        targetZoom = zoom;
        this.zoomStep = targetZoom - currentZoom;
        
        this.oraginPoint = {
            top: parseInt(this.map.layerContainerDiv.style.top),
            left: parseInt(this.map.layerContainerDiv.style.left)
        }
		
		this.mousePosition = this.handlers.wheel.mousePosition;
		
        var zoomAnimateStep = OpenLayers.Function.bind(this.zoomAnimateStep, this);
		zoomAnimateStep();
        this.animateIntervalId = setInterval(zoomAnimateStep, this.intervalTime);
    },
    
	/** 
     * Method: zoomAnimateStep
     * 单步动画。
     */
    zoomAnimateStep: function(){
        if (this.shouldEndAnimate()) {
            this.stopZoomAnimate();
            if (this.layerLoaded) {
                this.clearBufferLayer();
            }
            else {
                this.backBufferLayer();
            }
            this.restoreAllLayers();
            return;
        }
        
        var ratioDelta = (Math.pow(2, this.zoomStep) - 1) / this.totalStep;
        var ratio = this.currentStep * ratioDelta;
        
        this.bufferLayerContainer.style.width = Math.round(100 * (1 + ratio)) + "px";
        this.bufferLayerContainer.style.height = Math.round(100 * (1 + ratio)) + "px";
        
        var centerPixel = this.map.getLayerPxFromLonLat(this.map.getCenter());
        //鼠标滚轮滚动时，以鼠标光标为中心点扩散平滑缩放。
        if (this.zoomAnimateWheelEnabled) {
            centerPixel = this.mousePosition || centerPixel;
        }
        centerPixel = centerPixel.add(-this.oraginPoint.left, -this.oraginPoint.top);
        
        var size = new OpenLayers.Size(1024, 512);
        
        var offsetRatioX = centerPixel.x / size.w;
        var offsetRatioY = centerPixel.y / size.h;
        var offsetX = Math.round(size.w * ratio * offsetRatioX);
        var offsetY = Math.round(size.h * ratio * offsetRatioY);
        
        this.bufferLayerContainer.style.left = this.oraginPoint.left - offsetX + "px";//
        this.bufferLayerContainer.style.top = this.oraginPoint.top - offsetY + "px";//
        this.currentStep++;
    },
    
	/** 
     * Method: frontBufferLayer
     * 把缓存图层的html元素容器显示移至地图前端。
     */
    frontBufferLayer: function(){
        this.bufferLayerContainer.style.zIndex = 746;
    },
	
	/** 
     * Method: backBufferLayer
     * 把缓存图层的html元素容器显示移至地图后端。
     */
    backBufferLayer: function(){
        this.bufferLayerContainer.style.zIndex = 99;
    },
    
	/** 
     * Method: stopZoomAnimate
     * 停止缩放动画，清除animateIntervalId。
     */
    stopZoomAnimate: function(){
        if (this.animateIntervalId) {
            clearInterval(this.animateIntervalId);
            this.animateIntervalId = null;
        }
        this.currentStep = 0;
    },
    
	/** 
     * Method: isZoomAnimating
     * 判断是否正处于动画中。
     */
    isZoomAnimating: function(){
        if (this.animateIntervalId) {
            return true;
        }
        return false;
    },
    
	/** 
     * Method: shouldEndAnimate
     * 根据当前帧号，判断是否应该结束动画。
     */
    shouldEndAnimate: function(){
        if (this.currentStep > this.totalStep) {
            return true;
        }
        return false;
    },
	
	/** 
     * Method: prepareAnimate
     */
    prepareAnimate: function(){
    
    },
	
	/** 
     * Method: hiddenAllLayers
     * 隐藏所有的图层。
     */
    hiddenAllLayers: function(){
        var layers = this.map.layers;
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            layer.div.style.visibility = "hidden";
        }
        
    },
	
	/** 
     * Method: restoreAllLayers
     * 显示所有的图层。
     */
    restoreAllLayers: function(){
        var layers = this.map.layers;
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            layer.div.style.visibility = "visible";
        }
        
    },
	
	/** 
     * Method: clearBufferLayer
     * 清除缓存的图层。
     */
    clearBufferLayer: function(){
        if (!this.map || !this.bufferLayerContainer) {
            return null;
        }
        
        this.map.layerContainerDiv.removeChild(this.bufferLayerContainer);
        this.bufferLayerContainer = null;
    },
    
	/** 
     * Method: cloneLayersTile
     * 复制当前显示的图层瓦片。
     */
    cloneLayersTile: function(){
    
        var bufferLayerContainer = document.createElement("div");
        bufferLayerContainer.id = "bufferLayerContainer";
        bufferLayerContainer.style.position = "absolute";
        bufferLayerContainer.style.zIndex = 749;
        bufferLayerContainer.style.width = "100px";
        bufferLayerContainer.style.height = "100px";
        
        bufferLayerContainer.style.left = this.map.layerContainerDiv.style.left;
        bufferLayerContainer.style.top = this.map.layerContainerDiv.style.top;
        
        for (var i = this.map.layers.length - 1; i >= 0; i--) {
            var layer = this.map.layers[i];
            // 复制当前显示的图层
            if (layer.div.style.display != "none") {
                if (layer.getVisibility() && layer.transitionEffect == "resize") {
                    var result = this.cloneSingleLayerTile(layer, bufferLayerContainer);
                }
            }
        }
        
        this.bufferLayerContainer = bufferLayerContainer;
        this.map.layerContainerDiv.appendChild(this.bufferLayerContainer);
        
        
    },
    
	/** 
     * Method: cloneSingleLayerTile
     * 复制单个图层瓦片至缓存图层的html元素容器内。
     * 
     * Parameters:
     * layer - {<Geo.View2D.Layer>} 图层对象。
     * bufferLayerContainer - {HTMLDivElement} 放置图层的html元素容器。
     */
    cloneSingleLayerTile: function(layer, bufferLayerContainer){
    
        if (!layer) {
            return;
        }
		
        var map = this.map;
        
        //瓦片图片矩阵
        var tileGrid = [];
        
        var grid = layer.grid;
        
        for (var i = 0, l1 = grid.length; i < l1; i++) {
            var tileGridRow = [];
            for (var j = 0, l2 = grid[i].length; j < l2; j++) {
                var tile = grid[i][j];
                var imgDiv = tile.imgDiv;
                var frame = tile.frame;
                var cloneImg;
                if (imgDiv && tile.shouldDraw) {
                    cloneImg = imgDiv.cloneNode(true);
					//cloneImg.className = "olTileImage1";
                    cloneImg.id = imgDiv.id + "_clone";
                    
                    //复制瓦片外框div样式到图片
					if(frame){
	                    cloneImg.style.position = frame.style.position;
	                    cloneImg.style.left = parseInt(frame.style.left) + "%";
	                    cloneImg.style.top = parseInt(frame.style.top) + "%";
	                    cloneImg.style.width = parseInt(frame.style.width) + "%";
	                    cloneImg.style.height = parseInt(frame.style.height) + "%";
	                    cloneImg.style.display = frame.style.display;
					}else{
						cloneImg.style.left = parseInt(cloneImg.style.left) + "%";
	                    cloneImg.style.top = parseInt(cloneImg.style.top) + "%";
	                    cloneImg.style.width = parseInt(cloneImg.style.width) + "%";
	                    cloneImg.style.height = parseInt(cloneImg.style.height) + "%";
					}
                    
                    cloneImg.style.zIndex = tile.layer.div.style.zIndex;
                    
                    bufferLayerContainer.appendChild(cloneImg);
                    
                    tileGridRow.push(cloneImg);
                }
            }
            tileGridRow.length && tileGrid.push(tileGridRow);
        }
    },
	
	/**
     * Method: wheelChange  
     *
     * Parameters:
     * evt - {Event}
     * deltaZ - {Integer}
     */
    wheelChange: function(evt, deltaZ) {
        var currentZoom = this.map.getZoom();
        var newZoom = this.map.getZoom() + Math.round(deltaZ);
        newZoom = Math.max(newZoom, 0);
        newZoom = Math.min(newZoom, this.map.getNumZoomLevels());
        if (newZoom === currentZoom) {
            return;
        }
        var size    = this.map.getSize();
        var deltaX  = size.w/2 - evt.xy.x;
        var deltaY  = evt.xy.y - size.h/2;
        var newRes  = this.map.baseLayer.getResolutionForZoom(newZoom);
        var zoomPoint = this.map.getLonLatFromPixel(evt.xy);
        var newCenter = new OpenLayers.LonLat(
                            zoomPoint.lon + deltaX * newRes,
                            zoomPoint.lat + deltaY * newRes );
        this.map.setCenter( newCenter, newZoom );
    },
	
	/**
     * Method: destroy
     * 销毁本对象。
     */
    destroy: function(){
        if (this.handler) {
            this.handler.destroy();
            this.handler = null;
        }
        if (this.handlers) {
            for (var key in this.handlers) {
                if (this.handlers.hasOwnProperty(key) &&
                typeof this.handlers[key].destroy == "function") {
                    this.handlers[key].destroy();
                }
            }
            this.handlers = null;
        }
    },
	
    CLASS_NAME: "Geo.AnimateZoomer"
});
	/**
	 * Class: Geo.Util
	 * 常用的一些函数。
	 */
	
	/**
	 * Property:englishColorToOx
	 * {Object} 颜色的英文字母表示法与RGB表示法对照表
	 */
	Geo.Util.englishColorToOx = {
		"black": "#000000",
		"blue":"#0000FF",
		"brown":"#A52A2A",
		"cyan":"#00FFFF",
		"gold":"#FFD700",
		"gray":"#808080",
		"green":"#008000",
		"lime":"#00FF00",
		"orange":"#FFA500",
		"red":"#FF0000",
		"white":"#FFFFFF",
		"yellow":"#FFFF00"
	};
	
	/**
     * Method: ToArgb
     * 
     * Parameters:
     * Rgb - {String} 颜色字符串,比如：#000000
     * Alpha - {Float} 取值范围：[0-1],0表示透明，1表示不透明
     * Returns:
     * {Integer} 
     */
	Geo.Util.ToArgb = function(Rgb, Alpha) {
		//将英文转换为"#"开头的颜色表示法
		var englishColorToOx = Geo.Util.englishColorToOx;
		for(var value in englishColorToOx) {
			if(value === Rgb) {
				Rgb = englishColorToOx[value].replace("#","");
			}
		}
		
        // rgb 颜色值
        var Rgb16 = parseInt(Rgb, 16);
        var strRGB = Rgb16.toString(2);
        var legnt = strRGB.length;
        if(legnt < 24) {
            for(i = 0; i < 24 - legnt; i++) {
                strRGB = "0" + strRGB;
            }
        }
        // int 值
        var argbStr = Alpha.toString(2) + strRGB;
        var flag = argbStr.substr(0, 1);
        if(flag == "1") {
            argbStr = argbStr.substr(1, 31);
            return 0 - (2147483647 - parseInt(argbStr, 2)) - 1;
        }
        else {
            return parseInt(Alpha.toString(2) + Rgb16.toString(2), 2);
        }
    };
	
	/**
     * APIMethod: getHexColor
     * 获取十六进制色码。
     * 
     * Parameters:
     * color - {String} 颜色字符串
     * 
     * Returns:
     * {String}
     */
	Geo.Util.getHexColor = function(color) {
		var _color = Geo.Util.englishColorToOx[color];
		var index = color.indexOf("#");
		var str = null;
		if(index == 0 && !_color) {
			var substr = color.substr(1);
			if(substr.length == 3) {
				str = substr.charAt(0)+substr.charAt(0)+substr.charAt(1)+substr.charAt(1)+ substr.charAt(2)+ substr.charAt(2);
			}else if(substr.length == 6) {
				str = substr;
			}
		}else if(index == -1 && _color) {
			str = _color.substr(1);
		}
		return "0x" + str;
	}
	
	/**
     * APIMethod: meterToDegree
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * Parameters:
	 * meter - {Number} 要转换的地理坐标。
	 * lonlat - {<Geo.LonLat>} 经纬度。
	 */
	Geo.Util.meterToDegree = function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(OpenLayers.Util.rad(templat)) );
	};
	
	/**
     * APIMethod: webColorToHex
     * 转换颜色字符串为十进制，例如："#0000ff"转换成0x000000ff。
     * 
     * Parameters:
     * webcolor - {String} 颜色字符串
     * 
     * Returns:
     * {Integer} 十进制颜色数
     */
	Geo.Util.webColorToHex = function(webcolor) {
		return new Number("0x00" + webcolor.replace("#",""));
	}
	
	/**
     * APIMethod: replaceAll
     * 在字符串中查找某字符串，并全部替换成另外一个字符串。
     * 
     * Parameters:
     * string - {String} 字符串
     * find - {String} 要查找的字符串
     * replace - {String} 替换目标字符串
     * 
     * Returns:
     * {String} 替换后的结果字符串
     */      
    Geo.Util.replaceAll = function(string, find, replace) {
        replace = replace ? replace : "";
        return string.replace(new RegExp(find, "gm"), replace);
    };
	
	Geo.Util.Format = {};/**
 * Class: Geo.Pyramid
 * 金字塔对象类。
 * 金字塔对象类可以实现地理范围（坐标）与瓦片行、列属性之间的转换。
 * 地图对象必须有一个金字塔属性。本类的实例默认为地理坐标系统360度
 * 顶层瓦片金字塔方案。另外，包含了比例尺，分辨率和级别之间的转换。
 */
Geo.Pyramid = Geo.Class({

	/**
     * APIProperty: name
     * {String} 金字塔名称。
     */
	name : null,
	
	/**
     * APIProperty: pyramidID
     * {String} 金字塔ID。
     */
	pyramidID : null,
	
	/**
     * APIProperty: description
     * {String} 金字塔描述。
     */
	description : null,
	
	/**
     * APIProperty: topLevelIndex
     * {Number} 最顶层级别。
     */
	topLevelIndex : null,
	
	/**
	 * APIProperty: resolutions
	 * 分辨率数组，如果设置了分辨率数组，则maxResolution和minResolution设置了就无效
	 */
	resolutions: null,
	
	/**
     * APIProperty: bottomLevelIndex
     * {Number} 最底层级别。
     */	
	bottomLevelIndex : null,
	
	/**
     * APIProperty: scaleX
     * {Number} X轴放大系数。
     */	
	scaleX : null,
	
	/**
     * APIProperty: scaleY
     * {Number} Y轴放大系数。
     */		
	scaleY : null,
	
	/**
     * APIProperty: tileSize
     * {<Geo.Size>} 瓦片尺寸。
     */			
	tileSize: null,
	
	/**
     * APIProperty: originRowIndex
     * {Number} 瓦片行起始编号。
     */	
	originRowIndex: null,
	
	/**
     * APIProperty: originColIndex
     * {Number} 瓦片列起始编号。
     */		
	originColIndex: null,
	
	/**
     * APIProperty: topTileFromX
     * {Float} 顶层瓦片X轴坐标起点。
     */		
	topTileFromX:null,
	
	/**
     * APIProperty: topTileFromY
     * {Float} 顶层瓦片Y轴坐标起点。
     */	
	topTileFromY: null,
	
	/**
     * APIProperty: topTileToX
     * {Float} 顶层瓦片X轴坐标终点。
     */	
	topTileToX: null,
	
	/**
     * APIProperty: topTileToY
     * {Float} 顶层瓦片Y轴坐标终点。
     */	
	topTileToY: null,
	
	/**
     * APIProperty: units
     * {String} 金字塔的单位优先于地图的单位。默认为'degrees'。
     * 值可能为：'degrees' (or 'dd'), 'm', 'ft', 'km', 'mi', 'inches'.
     */
    units: 'degrees',
	
	/**
	 * Constructor: Geo.Pyramid
	 * 构造函数。
	 * 
	 * Parameters:
	 * options - {object} 金字塔设置选项。
	 */
	initialize : function (options){
		
		if (!options || options ==={}){
			options = Geo.Pyramid.DEFAULT_PYRAMID;
		}
		OpenLayers.Util.extend(this, options);	
	},

	/**
	 * APIMethod: getMaxExtent
	 * 根据根据金字塔对象相关定义获取最大范围。
	 * 
	 * Returns:
	 * {<Geo.Bounds>} 图层最大范围。
	 */	
	getMaxExtent: function(){
		var left,bottom,right,top;
		
		if(this.topTileFromX < this.topTileToX){
			left = this.topTileFromX;
			right = this.topTileToX;
		} else {
			right = this.topTileFromX;
			left = this.topTileToX;
		}
		
		if(this.topTileFromY < this.topTileToY){
			bottom = this.topTileFromY;
			top = this.topTileToY;
		} else {
			top = this.topTileFromY;
			bottom = this.topTileToY;
		}
		return new Geo.Bounds(left,bottom,right,top);
	},
	
	/**
	 * APIMethod: getResolutionForLevel
	 * 根据分辨率获取级别。
	 *
	 * Parameters:
	 * resolution - 指定分辨率。
	 * 
	 * Returns:
	 * {Integer} 级别。
	 */
	getLevelForResolution: function(resolution){
        if (!resolution) {
            return 0;
        }
		var zoom, i, diff;
		var minDiff = Number.POSITIVE_INFINITY;
		var resolutions = this.getResolutions();
		for (i = 0, len = resolutions.length; i < len; i++) {
			//判断当前分辨率与金字塔中分辨率最接近的
	        diff = Math.abs(resolutions[i] - resolution);
	        if (diff > minDiff) {
	            break;
	        }
	        minDiff = diff;
		}
		zoom = Math.max(0, i - 1);//0和(i - 1)中取大数。
		return zoom ;
	},
	
	/**
	 * APIMethod: getLevelForScale
	 * 根据比例尺获取级别。
	 *
	 * Parameters:
	 * scale - 指定比例尺。
	 * 
	 * Returns:
	 * {Integer} 级别。
	 */
	getLevelForScale: function(scale){
		var resolution = OpenLayers.Util.getResolutionFromScale(scale, this.units);
		var zoom = this.getLevelForResolution(resolution);
        return zoom ;
	},
	
	/**
	 * APIMethod: getResolutionForScale
	 * 根据比例尺获取分辨率。
	 *
	 * Parameters:
	 * scale - 指定比例尺。
	 * units - {String} 单位。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getResolutionForScale: function(scale){
		var level = this.getLevelForScale(scale, this.units);
		var res = this.getResolutionForLevel(level)
        return res;
	},
	
	/**
	 * APIMethod: getResolutionForLevel
	 * 根据级别获取分辨率。
	 * 
	 * Parameters:
	 * level - 图层级别。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getResolutionForLevel: function(level){
		var maxResolution = (this.getTopTileSize().w / this.tileSize.w) 
		return maxResolution / Math.pow(2, level);		
	},
	
	/**
	 * APIMethod: getMaxResolution
	 * 根据最大级别获取分辨率。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getMaxResolution: function(){		
		return this.getResolutionForLevel(this.topLevelIndex)	
	},
	
	/**
	 * APIMethod: getResolutionForBottomLevel
	 * 根据最小级别获取分辨率。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getMinResolution: function(){		
		return this.getResolutionForLevel(this.bottomLevelIndex)	
	},
	
	/**
	 * APIMethod: getResolutions
	 * 获取分辨率数组。
	 * 
	 * Returns:
	 * {Array} 分辨率数组。
	 */
	getResolutions: function(){
		var resolutions = new Array();
		for (var i = this.topLevelIndex; i <= this.bottomLevelIndex; i++) {
			resolutions.push(this.getResolutionForLevel(i));
		}
		return resolutions;
	},
	
	/**
	 * APIMethod: getNumZoomLevels
	 * 获取级别差。
	 * 
	 * Returns:
	 *  {Integer} 级别差。
	 */
	getNumZoomLevels: function(){
		return this.bottomLevelIndex - this.topLevelIndex + 1;
	},
	
	/**
	 * APIMethod: getTopTileSize
	 * 获取顶层瓦片尺寸。
	 * 
	 * Returns:
	 * {<Geo.Size>} 瓦片大小。
	 */	
	getTopTileSize : function(){
		var w = Math.abs(this.topTileToX - this.topTileFromX);
		var h = Math.abs(this.topTileToY - this.topTileFromY);
		return new Geo.Size(w,h);
	},
	
	/**
	 * APIMethod: getTileIndex
	 * 根据坐标和级别，获取瓦片所在行列号。
	 * 
	 * Parameters:
	 * lonlat - 经纬度坐标。
	 * level - 图层级别。
	 * 
	 * Returns:
	 * {Object} 返回瓦片的行列号。
	 */
	getTileIndex: function(lonlat, level){
			
		var lon = lonlat.lon;
		var lat = lonlat.lat;
		var size = this.getTopTileSize()
		var degree = size.w / Math.pow(2,level);
		
		//金字塔宽高
		var width = this.maxExtent.getWidth();
		var height = this.maxExtent.getHeight();
		
		//总行列数
		var totalCol = Math.round(width / degree);
		var totalRow = Math.round(height / degree);
		
		//计算列索引号
		var isStartLeft = (this.topTileFromX < this.topTileToX) ? true : false;
		var colIndex = Math.ceil(Math.abs(lon - this.topTileFromX)/degree) - 1;
		if(!isStartLeft){
			colIndex = totalCol - colIndex;
		}
		
		var isStartTop = (this.topTileFromY > this.topTileToY) ? true : false;
		var rowIndex = Math.ceil(Math.abs(lat - this.topTileFromY)/degree) - 1;
		if (!isStartTop){
			rowIndex = totalRow - rowIndex;
		}
		
		return {
			col: colIndex,
			row: rowIndex
		}

	},
	
	/**
	 * APIMethod: getTileBoundsForGridIndex
	 * 根据行列号和层级计算瓦片范围。
	 * 
	 * Parameters:
	 * row - 行号。
	 * col - 列号。
	 * level - 层级
	 * 
	 * Returns:
	 * {Geo.Bounds} 瓦片范围。
	 */
	getTileBoundsForGridIndex: function(row, col, level) {
		var res = this.getResolutionForLevel(level);
		var leftTopLon = this.topTileFromX + row * this.tileSize.w * res;
		var leftTopLat = this.topTileFromY -  col * this.tileSize.h * res;
		var rightBottomLon = leftTopLon + this.tileSize.w * res;
		var rightBottomLat = leftTopLat - this.tileSize.h * res;
		var tileBounds = new Geo.Bounds(leftTopLon,rightBottomLat,rightBottomLon,leftTopLat);
		return tileBounds;
	},
	
	/**
	 * APIMethod: getTileInfoFromBounds
	 * 根据范围和级别获得最大最小行列号。
	 * 
	 * Parameters:
	 * bounds - 范围。
	 * level - 图层级别。
	 * 
	 * Returns:
	 * {Object} 返回最大最小行列号。
	 */
	getTileInfoFromBounds: function(bounds, level) {
		//判断原点
		var minTileObj = this.getTileIndex(new Geo.LonLat(bounds.left, bounds.top), level);
		var maxTileObj = this.getTileIndex(new Geo.LonLat(bounds.right, bounds.bottom), level);
		return {
			mincol: minTileObj.col,
			minrow: minTileObj.row,
			maxcol: maxTileObj.col,
			maxrow: maxTileObj.row
		}
	},
	
	/**
	 * 
	 */
	getTileInfoFromLonLat: this.getTileIndex,
	
	/**
	 * APIMethod: clone
	 * 复制对象。
	 * 
	 * Returns:
	 * {<Geo.Pyramid>} 金字塔对象。
	 */	
	clone: function(){
		return OpenLayers.Util.extend({},this);
	},
	
	CLASS_NAME : "Geo.Pyramid"
});

/**
 * APIProperty: Degree360
 * 360度金字塔定义。
 */
Geo.Pyramid.Degree360 = {
	//360度金字塔定义
	name : "360DegreePyramid",	
	topLevelIndex : 0,
	bottomLevelIndex : 20,
	scaleX : 2,
	scaleY :2,
	topTileFromX : -180.0,
	topTileFromY : 90.0,
	topTileToX : 180.0,
	topTileToY : -270.0,
	tileSize : new Geo.Size(256,256),
	originRowIndex : 0,
	originColIndex : 0,
	maxExtent : new Geo.Bounds(-180,-90,180,90)
};

/**
 * APIProperty: Degree18
 * 18度金字塔定义。
 */
Geo.Pyramid.Degree18 = {
	//18度金字塔定义
	name : "18DegreePyramid",
	topLevelIndex : 0,
	bottomLevelIndex : 20,
	scaleX : 2,
	scaleY :2,
	topTileFromX : -180.0,
	topTileFromY : -90.0,
	topTileToX : -162.0,
	topTileToY : -72.0,
	tileSize : new Geo.Size(256,256),
	originRowIndex : 0,
	originColIndex : 0,
	maxExtent : new Geo.Bounds(-180,-90,180,90)
};

/**
 * APIProperty: DEFAULT_PYRAMID
 * 默认金字塔定义（360度金字塔定义）。
 */
Geo.Pyramid.DEFAULT_PYRAMID = Geo.Pyramid.Degree360;/**
 * Class: Geo.SymbolizerManager
 * 符号组类。提供符号组的创建、删除和修改功能。默认提供常用的行业符号。
 */
Geo.SymbolizerManager = Geo.Class({

    /** 
     * Constructor: Geo.SymbolizerManager
     * Geo.SymbolizerManager类的构造函数。
     */
    initialize: function(){
    
    },
    
    /**
     * Method: getImagePath
     * 获取图片文件夹的相对路径。
     */
    getImagePath: function(){
        return Geo.getScriptLocation() + "images/";
    },
    
	/**
     * APIMethod: createSymbolizer
     * 创建符号组。
     * 
     * Parameters:
     * newSymbolizerType - {String} 新创建符号组的类型。
     * symbolizerGroup - {Array} 符号组内对象数组。
     * 		name {String} 新创建的符号组内单个符号对象的名称。
     * 		symbolizer {Object} 符号对象。
	 */
    createSymbolizer: function(newSymbolizerType, symbolizerGroup){
        Geo.SymbolizerManager.symbolizerGroup[newSymbolizerType] = {};
        for (var i = 0; i < symbolizerGroup.length; i++) {
			Geo.SymbolizerManager.symbolizerGroup[newSymbolizerType][symbolizerGroup[i].name] = symbolizerGroup[i].symbolizer;
        };
    },
    
	/**
     * APIMethod: updateSymbolizer
     * 根据符号组类型和符号名称，修改符号组内符号对象。
     * 
     * Parameters:
     * newSymbolizerType - {String} 符号组的类型。
     * name - {String} 被修改的符号组内单个符号对象的名称。
     * symbolizer - {Object} 新的符号对象。
	 */
    updateSymbolizer: function(symbolizerType, name, symbolizer){
        OpenLayers.Util.extend(Geo.SymbolizerManager.symbolizerGroup[symbolizerType][name], symbolizer);
    },
    
	/**
     * APIMethod: removeSymbolizer
     * 根据符号组类型和符号名称，删除符号组内符号对象。
     * 
     * Parameters:
     * symbolizerType - {String} 符号组的类型。
     * name - {String} 被删除的符号组内单个符号对象的名称。
	 */
    removeSymbolizer: function(symbolizerType, name){
        Geo.SymbolizerManager.symbolizerGroup[symbolizerType][name] = null;
        delete Geo.SymbolizerManager.symbolizerGroup[symbolizerType][name];
    },
    
	/**
     * APIMethod: getSymbolizerGroup
     * 获取符号组。
	 */
    getSymbolizerGroup: function(){
        return Geo.SymbolizerManager.symbolizerGroup;
    },
    
    CLASS_NAME: "Geo.SymbolizerManager"
});

/**
 * APIProperty: Geo.SymbolizerManager.symbolizerGroup
 * {Object} 符号组对象。
 */
Geo.SymbolizerManager.symbolizerGroup = {
    "COMMON": {
        "A": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "0.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "B": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "1.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "C": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "2.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "D": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "3.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "E": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "4.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "F": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "5.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "G": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "6.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "H": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "7.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "I": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "8.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "J": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "9.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        }
    }
};
/**
 * Class: Geo.GeoMarker
 * 吉奥标注类。可设置动画效果，自定义标签的标注类。
 */
Geo.GeoMarker = Geo.Class(Geo.Marker, {
    
    /** 
     * Constructor: Geo.GeoMarker
     * Geo.GeoMarker对象构造函数。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 标注的地理坐标。
     * icon - {<Geo.View2D.Icon>}  标注的显示小图标对象。
     * tag - {<Geo.View2D.MarkerTag>}  标注的自定义标签对象。
     */
    initialize: function(lonlat, icon, tag) {
		this.tag = tag;
		Geo.Marker.prototype.initialize.apply(this, arguments);
    },
	
	/**
     * APIMethod: setAnimation
	 * 设置标注点的动画效果。
	 * 
     * Parameters:
     * animationType - {Integer} 动画效果的标识。有坠落动画(Geo.GeoMarker.ANIMATION_DROP)和跳动动画(Geo.GeoMarker.ANIMATION_BOUNCE)。
     * height - {Integer} 跳动的像素高度值。默认值为20。
     * ga - {Integer} 加速度，单位是px/s^2(像素每平方秒)。默认值为500。
	 */
	setAnimation: function(animationType, height, ga) {
		if(animationType !== Geo.GeoMarker.ANIMATION_DROP && animationType !== Geo.GeoMarker.ANIMATION_BOUNCE){
			return;
		}
		//跳动的像素高度值。
		var height = height ? height : 20;
		height = (height < 0) ? 0 : height;
		if(height == 0){
			return;
		}
		//动画的频率，每多少毫秒一帧。
		var ga = ga ? ga : 500;
		ga = (ga < 0) ? 0 : ga;
		if(ga == 0){
			return;
		}
		
        this.timerId && clearInterval(this.timerId);
		var size = this.icon.size;
		var icon = this.icon;
		
		//加速度
        var g = ga;
        var t = 0;
        var y0 = -size.h - height;
		//设置动画效果后，标注小图标会从距离坐标位置height个像素高度开始坠落。
		icon.offset.y = y0;
        //icon.moveTo();
		var b = false;
        var timerCallback = function(){
            if (b && animationType === Geo.GeoMarker.ANIMATION_DROP) {
                clearInterval(this.timerId);
				this.timerId = null;
                return;
            }
            t += 0.01;
            //t秒之后，物体下落的高度
            var s = g * t * t / 2;
            //物体实际的高度
            var y = y0 + s;
            if (y > -size.h) {
                y = -size.h;
                if (animationType === Geo.GeoMarker.ANIMATION_BOUNCE) {
                    t = -t;
                }
                b = true;
            }
            icon.offset.y = y;
            icon.moveTo();
        };
		
		this.timerId = window.setInterval(
            OpenLayers.Function.bind(timerCallback, this),
            10);
		
    },
	
    /**
     * Method: setContentHTML
     * 更改标签内容。
     * 
     * html - {String} 
     */
    setContentHTML: function(html) {
		if(this.tag){
			this.tag.setContentHTML(html);
		}
    },
	
    /** 
    * Method: drawTag
    * 绘制标签div。
    * 
    * Parameters:
    * px - {<Geo.Pixel>}
    * 
    * Returns:
    * {DOMElement} 返回一个新的标签的DOM div。
    */
    drawTag: function(px) {
        if(this.tag){
			return this.tag.draw(px);
		}
		return null;
    }, 

    /**
     * APIMethod: isDrawnTag
     * 是否已经绘制。
     * 
     * Returns:
     * {Boolean} 是否已经绘制，返回值为布尔类型。
     */
    isDrawnTag: function() {
        var isDrawn = (this.tag && this.tag.isDrawn());
        return isDrawn;   
    },
	
    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        // erase any drawn features
        this.erase();

        this.map = null;

        this.events.destroy();
        this.events = null;

        if (this.icon != null) {
            this.icon.destroy();
            this.icon = null;
        }
        if (this.tag != null) {
            this.tag.destroy();
            this.tag = null;
        }
    },
	
	/** 
    * Method: erase
    * Erases any drawn elements for this marker.
    */
    erase: function() {
        if (this.icon != null) {
            this.icon.erase();
        }
        if (this.tag != null) {
            this.tag.erase();
        }
    },
	
    CLASS_NAME: "Geo.GeoMarker"
});

/**
 * Constant: ANIMATION_DROP
 * {Integer} 坠落动画。
 */
Geo.GeoMarker.ANIMATION_DROP = 1;

/**
 * Constant: ANIMATION_BOUNCE
 * {Integer} 跳动动画。 
 */
Geo.GeoMarker.ANIMATION_BOUNCE = 2;﻿    OpenLayers.Renderer.Canvas.prototype.drawText = function(location, style) {
        style = OpenLayers.Util.extend({
            fontColor: "#000000",
            labelAlign: "cm"
        }, style);

        //==========================修正Canvas视图无文本偏移问题
        if(style.labelXOffset || style.labelYOffset) {
            var xOffset = isNaN(style.labelXOffset) ? 0 : style.labelXOffset;
            var yOffset = isNaN(style.labelYOffset) ? 0 : style.labelYOffset;
            var res = this.getResolution();
            location.move(xOffset*res, yOffset*res);
        }
        //======================================================

        var pt = this.getLocalXY(location);

        this.setCanvasStyle("reset");
        this.canvas.fillStyle = style.fontColor;
        this.canvas.globalAlpha = style.fontOpacity || 1.0;
        var fontStyle = [style.fontStyle ? style.fontStyle : "normal",
                         "normal", // "font-variant" not supported
                         style.fontWeight ? style.fontWeight : "normal",
                         style.fontSize ? style.fontSize : "1em",
                         style.fontFamily ? style.fontFamily : "sans-serif"].join(" ");
        var labelRows = style.label.split('\n');
        var numRows = labelRows.length;






        if (this.canvas.fillText) {
            // HTML5
            this.canvas.font = fontStyle;




            this.canvas.textAlign =
                OpenLayers.Renderer.Canvas.LABEL_ALIGN[style.labelAlign[0]] ||
                "center";
            this.canvas.textBaseline =
                OpenLayers.Renderer.Canvas.LABEL_ALIGN[style.labelAlign[1]] ||
                "middle";
            var vfactor =
                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[1]];
            if (vfactor == null) {
                vfactor = -.5;
            }
            var lineHeight =
                this.canvas.measureText('Mg').height ||
                this.canvas.measureText('Mx').width;
            pt[1] += lineHeight*vfactor*(numRows-1);

            var degrees = style.labelRotation;//0;parseFloat();
            if(degrees){
                //debugger;
                this.canvas.save();
                this.canvas.translate(pt[0], pt[1]);
                this.canvas.rotate(degrees*Math.PI/180);
                this.canvas.fillText(labelRows[0],0,0);
                this.canvas.restore();
            } else{
                for (var i = 0; i < numRows; i++) {
                    this.canvas.fillText(labelRows[i], pt[0], pt[1] + (lineHeight*i));
                }
            }





        } else if (this.canvas.mozDrawText) {
            // Mozilla pre-Gecko1.9.1 (<FF3.1)
            this.canvas.mozTextStyle = fontStyle;
            // No built-in text alignment, so we measure and adjust the position
            var hfactor =
                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[0]];
            if (hfactor == null) {
                hfactor = -.5;
            }
            var vfactor =
                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[1]];
            if (vfactor == null) {
                vfactor = -.5;
            }
            var lineHeight = this.canvas.mozMeasureText('xx');
            pt[1] += lineHeight*(1 + (vfactor*numRows));
            for (var i = 0; i < numRows; i++) {
                var x = pt[0] + (hfactor*this.canvas.mozMeasureText(labelRows[i]));
                var y = pt[1] + (i*lineHeight);
                this.canvas.translate(x, y);
                this.canvas.mozDrawText(labelRows[i]);
                this.canvas.translate(-x, -y);
            }
        }
        this.setCanvasStyle("reset");
    }
	
	//解决地图定位到第0级后添加图层，地图级别自动跳转到最大一级的bug。
	OpenLayers.Map.prototype.zoom = null;/**
 * Class: Geo.Uuid
 * 包含Geo.Math.uuid()方法，用于生成一个随机的uuid。
 */

/*!
Math.uuid.js (v1.4)
http://www.broofa.com
mailto:robert@broofa.com

Copyright (c) 2010 Robert Kieffer
Dual licensed under the MIT and GPL licenses.
*/

/*
 * Generate a random uuid.
 *
 * USAGE: Math.uuid(length, radix)
 *   length - the desired number of characters
 *   radix  - the number of allowable values for each character.
 *
 * EXAMPLES:
 *   // No arguments  - returns RFC4122, version 4 ID
 *   >>> Math.uuid()
 *   "92329D39-6F5C-4520-ABFC-AAB64544E172"
 * 
 *   // One argument - returns ID of the specified length
 *   >>> Math.uuid(15)     // 15 character ID (default base=62)
 *   "VcydxgltxrVZSTV"
 *
 *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)
 *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)
 *   "01001010"
 *   >>> Math.uuid(8, 10) // 8 character ID (base=10)
 *   "47473046"
 *   >>> Math.uuid(8, 16) // 8 character ID (base=16)
 *   "098F4D35"
 */
(function() {
  // Private array of chars to use
  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); 

  Geo.Math.uuid = function (len, radix) {
    var chars = CHARS, uuid = [];
    radix = radix || chars.length;

    if (len) {
      // Compact form
      for (var i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];
    } else {
      // rfc4122, version 4 form
      var r;

      // rfc4122 requires these characters
      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
      uuid[14] = '4';

      // Fill in random data.  At i==19 set the high bits of clock sequence as
      // per rfc4122, sec. 4.1.5
      for (var i = 0; i < 36; i++) {
        if (!uuid[i]) {
          r = 0 | Math.random()*16;
          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
        }
      }
    }

    return uuid.join('');
  };

  // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance
  // by minimizing calls to random()
  Geo.Math.uuidFast = function() {
    var chars = CHARS, uuid = new Array(36), rnd=0, r;
    for (var i = 0; i < 36; i++) {
      if (i==8 || i==13 ||  i==18 || i==23) {
        uuid[i] = '-';
      } else if (i==14) {
        uuid[i] = '4';
      } else {
        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
        r = rnd & 0xf;
        rnd = rnd >> 4;
        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
      }
    }
    return uuid.join('');
  };

  // A more compact, but less performant, RFC4122v4 solution:
  Geo.Math.uuidCompact = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
      return v.toString(16);
    }).toUpperCase();
  };
})();
﻿/*
 * heatmap.js 1.0 -    JavaScript Heatmap Library
 *
 * Copyright (c) 2011, Patrick Wied (http://www.patrick-wied.at)
 * Dual-licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and the Beerware (http://en.wikipedia.org/wiki/Beerware) license.
 */

(function(w){
    // the heatmapFactory creates heatmap instances
    var heatmapFactory = (function(){

    // store object constructor
    // a heatmap contains a store
    // the store has to know about the heatmap in order to trigger heatmap updates when datapoints get added
    var store = function store(hmap){

        var _ = {
            // data is a two dimensional array
            // a datapoint gets saved as data[point-x-value][point-y-value]
            // the value at [point-x-value][point-y-value] is the occurrence of the datapoint
            data: [],
            // tight coupling of the heatmap object
            heatmap: hmap
        };
        // the max occurrence - the heatmaps radial gradient alpha transition is based on it
        this.max = 1;

        this.get = function(key){
            return _[key];
        };
        this.set = function(key, value){
            _[key] = value;
        };
    }

    store.prototype = {
        // function for adding datapoints to the store
        // datapoints are usually defined by x and y but could also contain a third parameter which represents the occurrence
        addDataPoint: function(x, y){
            if(x < 0 || y < 0)
                return;

            var me = this,
                heatmap = me.get("heatmap"),
                data = me.get("data");

            if(!data[x])
                data[x] = [];

            if(!data[x][y])
                data[x][y] = 0;

            // if count parameter is set increment by count otherwise by 1
            data[x][y]+=(arguments.length<3)?1:arguments[2];
            
            me.set("data", data);
            // do we have a new maximum?
            if(me.max < data[x][y]){
                // max changed, we need to redraw all existing(lower) datapoints
                heatmap.get("actx").clearRect(0,0,heatmap.get("width"),heatmap.get("height"));
                me.setDataSet({ max: data[x][y], data: data }, true);
                return;
            }
            heatmap.drawAlpha(x, y, data[x][y], true);
        },
        setDataSet: function(obj, internal){
            var me = this,
                heatmap = me.get("heatmap"),
                data = [],
                d = obj.data,
                dlen = d.length;
            // clear the heatmap before the data set gets drawn
            heatmap.clear();
            this.max = obj.max;
            // if a legend is set, update it
            heatmap.get("legend") && heatmap.get("legend").update(obj.max);
            
            if(internal != null && internal){
                for(var one in d){
                    // jump over undefined indexes
                    if(one === undefined)
                        continue;
                    for(var two in d[one]){
                        if(two === undefined)
                            continue;
                        // if both indexes are defined, push the values into the array
                        heatmap.drawAlpha(one, two, d[one][two], false);   
                    }
                }
            }else{
                while(dlen--){
                    var point = d[dlen];
                    heatmap.drawAlpha(point.x, point.y, point.count, false);
                    if(!data[point.x])
                        data[point.x] = [];

                    if(!data[point.x][point.y])
                        data[point.x][point.y] = 0;

                    data[point.x][point.y] = point.count;
                }
            }
            heatmap.colorize();
            this.set("data", d);
        },
        exportDataSet: function(){
            var me = this,
                data = me.get("data"),
                exportData = [];

            for(var one in data){
                // jump over undefined indexes
                if(one === undefined)
                    continue;
                for(var two in data[one]){
                    if(two === undefined)
                        continue;
                    // if both indexes are defined, push the values into the array
                    exportData.push({x: parseInt(one, 10), y: parseInt(two, 10), count: data[one][two]});
                }
            }

            return { max: me.max, data: exportData };
        },
        generateRandomDataSet: function(points){
            var heatmap = this.get("heatmap"),
            w = heatmap.get("width"),
            h = heatmap.get("height");
            var randomset = {},
            max = Math.floor(Math.random()*1000+1);
            randomset.max = max;
            var data = [];
            while(points--){
                data.push({x: Math.floor(Math.random()*w+1), y: Math.floor(Math.random()*h+1), count: Math.floor(Math.random()*max+1)});
            }
            randomset.data = data;
            this.setDataSet(randomset);
        }
    };

    var legend = function legend(config){
        this.config = config;

        var _ = {
            element: null,
            labelsEl: null,
            gradientCfg: null,
            ctx: null
        };
        this.get = function(key){
            return _[key];
        };
        this.set = function(key, value){
            _[key] = value;
        };
        this.init();
    };
    legend.prototype = {
        init: function(){
            var me = this,
                config = me.config,
                title = config.title || "Legend",
                position = config.position,
                offset = config.offset || 10,
                gconfig = config.gradient,
                labelsEl = document.createElement("ul"),
                labelsHtml = "",
                grad, element, gradient, positionCss = "";
 
            me.processGradientObject();
            
            // Positioning

            // top or bottom
            if(position.indexOf('t') > -1){
                positionCss += 'top:'+offset+'px;';
            }else{
                positionCss += 'bottom:'+offset+'px;';
            }

            // left or right
            if(position.indexOf('l') > -1){
                positionCss += 'left:'+offset+'px;';
            }else{
                positionCss += 'right:'+offset+'px;';
            }

            element = document.createElement("div");
            element.style.cssText = "border-radius:5px;position:absolute;"+positionCss+"font-family:Helvetica; width:256px;z-index:10000000000; background:rgba(255,255,255,1);padding:10px;border:1px solid black;margin:0;";
            element.innerHTML = "<h3 style='padding:0;margin:0;text-align:center;font-size:16px;'>"+title+"</h3>";
            // create gradient in canvas
            labelsEl.style.cssText = "position:relative;font-size:12px;display:block;list-style:none;list-style-type:none;margin:0;height:15px;";
            

            // create gradient element
            gradient = document.createElement("div");
            gradient.style.cssText = ["position:relative;display:block;width:256px;height:15px;border-bottom:1px solid black; background-image:url(",me.createGradientImage(),");"].join("");

            element.appendChild(labelsEl);
            element.appendChild(gradient);
            
            me.set("element", element);
            me.set("labelsEl", labelsEl);

            me.update(1);
        },
        processGradientObject: function(){
            // create array and sort it
            var me = this,
                gradientConfig = this.config.gradient,
                gradientArr = [];

            for(var key in gradientConfig){
                if(gradientConfig.hasOwnProperty(key)){
                    gradientArr.push({ stop: key, value: gradientConfig[key] });
                }
            }
            gradientArr.sort(function(a, b){
                return (a.stop - b.stop);
            });
            gradientArr.unshift({ stop: 0, value: 'rgba(0,0,0,0)' });

            me.set("gradientArr", gradientArr);
        },
        createGradientImage: function(){
            var me = this,
                gradArr = me.get("gradientArr"),
                length = gradArr.length,
                canvas = document.createElement("canvas"),
                ctx = canvas.getContext("2d"),
                grad;
            // the gradient in the legend including the ticks will be 256x15px
            canvas.width = "256";
            canvas.height = "15";

            grad = ctx.createLinearGradient(0,5,256,10);

            for(var i = 0; i < length; i++){
                grad.addColorStop(1/(length-1) * i, gradArr[i].value);
            }

            ctx.fillStyle = grad;
            ctx.fillRect(0,5,256,10);
            ctx.strokeStyle = "black";
            ctx.beginPath();
 
            for(var i = 0; i < length; i++){
                ctx.moveTo(((1/(length-1)*i*256) >> 0)+.5, 0);
                ctx.lineTo(((1/(length-1)*i*256) >> 0)+.5, (i==0)?15:5);
            }
            ctx.moveTo(255.5, 0);
            ctx.lineTo(255.5, 15);
            ctx.moveTo(255.5, 4.5);
            ctx.lineTo(0, 4.5);
            
            ctx.stroke();

            // we re-use the context for measuring the legends label widths
            me.set("ctx", ctx);

            return canvas.toDataURL();
        },
        getElement: function(){
            return this.get("element");
        },
        update: function(max){
            var me = this,
                gradient = me.get("gradientArr"),
                ctx = me.get("ctx"),
                labels = me.get("labelsEl"),
                labelText, labelsHtml = "", offset;

            for(var i = 0; i < gradient.length; i++){

                labelText = max*gradient[i].stop >> 0;
                offset = (ctx.measureText(labelText).width/2) >> 0;

                if(i == 0){
                    offset = 0;
                }
                if(i == gradient.length-1){
                    offset *= 2;
                }
                labelsHtml += '<li style="position:absolute;left:'+(((((1/(gradient.length-1)*i*256) || 0)) >> 0)-offset+.5)+'px">'+labelText+'</li>';
            }       
            labels.innerHTML = labelsHtml;
        }
    };

    // heatmap object constructor
    var heatmap = function heatmap(config){
        // private variables
        var _ = {
            radius : 40,
            element : {},
            canvas : {},
            acanvas: {},
            ctx : {},
            actx : {},
            legend: null,
            visible : true,
            width : 0,
            height : 0,
            max : false,
            gradient : false,
            opacity: 180,
            premultiplyAlpha: false,
            bounds: {
                l: 1000,
                r: 0,
                t: 1000,
                b: 0
            },
            debug: false
        };
        // heatmap store containing the datapoints and information about the maximum
        // accessible via instance.store
        this.store = new store(this);

        this.get = function(key){
            return _[key];
        };
        this.set = function(key, value){
            _[key] = value;
        };
        // configure the heatmap when an instance gets created
        this.configure(config);
        // and initialize it
        this.init();
    };

    // public functions
    heatmap.prototype = {
        configure: function(config){
                var me = this,
                    rout, rin;

                me.set("radius", config["radius"] || 40);
                me.set("element", (config.element instanceof Object)?config.element:document.getElementById(config.element));
                me.set("visible", (config.visible != null)?config.visible:true);
                me.set("max", config.max || false);
                me.set("gradient", config.gradient || { 0.45: "rgb(0,0,255)", 0.55: "rgb(0,255,255)", 0.65: "rgb(0,255,0)", 0.95: "yellow", 1.0: "rgb(255,0,0)"});    // default is the common blue to red gradient
                me.set("opacity", parseInt(255/(100/config.opacity), 10) || 180);
                me.set("width", config.width || 0);
                me.set("height", config.height || 0);
                me.set("debug", config.debug);

                if(config.legend){
                    var legendCfg = config.legend;
                    legendCfg.gradient = me.get("gradient");
                    me.set("legend", new legend(legendCfg));
                }
				me.set("map", config.map);
                
        },
        resize: function () {
                var me = this,
                    element = me.get("element"),
                    canvas = me.get("canvas"),
                    acanvas = me.get("acanvas");
                canvas.width = acanvas.width = me.get("width") || element.style.width.replace(/px/, "") || me.getWidth(element);
                this.set("width", canvas.width);
                canvas.height = acanvas.height = me.get("height") || element.style.height.replace(/px/, "") || me.getHeight(element);
                this.set("height", canvas.height);
        },

        init: function(){
                var me = this,
                    canvas = document.createElement("canvas"),
                    acanvas = document.createElement("canvas"),
                    ctx = canvas.getContext("2d"),
                    actx = acanvas.getContext("2d"),
                    element = me.get("element");

                
                me.initColorPalette();

                me.set("canvas", canvas);
                me.set("ctx", ctx);
                me.set("acanvas", acanvas);
                me.set("actx", actx);

                me.resize();
                canvas.style.cssText = acanvas.style.cssText = "position:absolute;top:0;left:0;z-index:10000000;";
                
                if(!me.get("visible"))
                    canvas.style.display = "none";

                element.appendChild(canvas);
                if(me.get("legend")){
					if(me.get("map")){
						me.get("map").viewPortDiv.appendChild(me.get("legend").getElement());
					}else{
						element.appendChild(me.get("legend").getElement());
					}
                }
                
                // debugging purposes only
                if(me.get("debug"))
                    document.body.appendChild(acanvas);
                
                actx.shadowOffsetX = 15000; 
                actx.shadowOffsetY = 15000; 
                actx.shadowBlur = 15; 
        },
        initColorPalette: function(){

            var me = this,
                canvas = document.createElement("canvas"),
                gradient = me.get("gradient"),
                ctx, grad, testData;

            canvas.width = "1";
            canvas.height = "256";
            ctx = canvas.getContext("2d");
            grad = ctx.createLinearGradient(0,0,1,256);

            // Test how the browser renders alpha by setting a partially transparent pixel
            // and reading the result.  A good browser will return a value reasonably close
            // to what was set.  Some browsers (e.g. on Android) will return a ridiculously wrong value.
            testData = ctx.getImageData(0,0,1,1);
            testData.data[0] = testData.data[3] = 64; // 25% red & alpha
            testData.data[1] = testData.data[2] = 0; // 0% blue & green
            ctx.putImageData(testData, 0, 0);
            testData = ctx.getImageData(0,0,1,1);
            me.set("premultiplyAlpha", (testData.data[0] < 60 || testData.data[0] > 70));
            
            for(var x in gradient){
                grad.addColorStop(x, gradient[x]);
            }

            ctx.fillStyle = grad;
            ctx.fillRect(0,0,1,256);

            me.set("gradient", ctx.getImageData(0,0,1,256).data);
        },
        getWidth: function(element){
            var width = element.offsetWidth;
            if(element.style.paddingLeft){
                width+=element.style.paddingLeft;
            }
            if(element.style.paddingRight){
                width+=element.style.paddingRight;
            }

            return width;
        },
        getHeight: function(element){
            var height = element.offsetHeight;
            if(element.style.paddingTop){
                height+=element.style.paddingTop;
            }
            if(element.style.paddingBottom){
                height+=element.style.paddingBottom;
            }

            return height;
        },
        colorize: function(x, y){
                // get the private variables
                var me = this,
                    width = me.get("width"),
                    radius = me.get("radius"),
                    height = me.get("height"),
                    actx = me.get("actx"),
                    ctx = me.get("ctx"),
                    x2 = radius * 3,
                    premultiplyAlpha = me.get("premultiplyAlpha"),
                    palette = me.get("gradient"),
                    opacity = me.get("opacity"),
                    bounds = me.get("bounds"),
                    left, top, bottom, right, 
                    image, imageData, length, alpha, offset, finalAlpha;
                
                if(x != null && y != null){
                    if(x+x2>width){
                        x=width-x2;
                    }
                    if(x<0){
                        x=0;
                    }
                    if(y<0){
                        y=0;
                    }
                    if(y+x2>height){
                        y=height-x2;
                    }
                    left = x;
                    top = y;
                    right = x + x2;
                    bottom = y + x2;

                }else{
                    if(bounds['l'] < 0){
                        left = 0;
                    }else{
                        left = bounds['l'];
                    }
                    if(bounds['r'] > width){
                        right = width;
                    }else{
                        right = bounds['r'];
                    }
                    if(bounds['t'] < 0){
                        top = 0;
                    }else{
                        top = bounds['t'];
                    }
                    if(bounds['b'] > height){
                        bottom = height;
                    }else{
                        bottom = bounds['b'];
                    }    
                }

                image = actx.getImageData(left, top, right-left, bottom-top);
                imageData = image.data;
                length = imageData.length;
                // loop thru the area
                for(var i=3; i < length; i+=4){

                    // [0] -> r, [1] -> g, [2] -> b, [3] -> alpha
                    alpha = imageData[i],
                    offset = alpha*4;

                    if(!offset)
                        continue;

                    // we ve started with i=3
                    // set the new r, g and b values
                    finalAlpha = (alpha < opacity)?alpha:opacity;
                    imageData[i-3]=palette[offset];
                    imageData[i-2]=palette[offset+1];
                    imageData[i-1]=palette[offset+2];
                    
                    if (premultiplyAlpha) {
                    	// To fix browsers that premultiply incorrectly, we'll pass in a value scaled
                    	// appropriately so when the multiplication happens the correct value will result.
                    	imageData[i-3] /= 255/finalAlpha;
                    	imageData[i-2] /= 255/finalAlpha;
                    	imageData[i-1] /= 255/finalAlpha;
                    }
                    
                    // we want the heatmap to have a gradient from transparent to the colors
                    // as long as alpha is lower than the defined opacity (maximum), we'll use the alpha value
                    imageData[i] = finalAlpha;
                }
                // the rgb data manipulation didn't affect the ImageData object(defined on the top)
                // after the manipulation process we have to set the manipulated data to the ImageData object
                image.data = imageData;
                ctx.putImageData(image, left, top);
        },
        drawAlpha: function(x, y, count, colorize){
                // storing the variables because they will be often used
                var me = this,
                    radius = me.get("radius"),
                    ctx = me.get("actx"),
                    max = me.get("max"),
                    bounds = me.get("bounds"),
                    xb = x - (1.5 * radius) >> 0, yb = y - (1.5 * radius) >> 0,
                    xc = x + (1.5 * radius) >> 0, yc = y + (1.5 * radius) >> 0;

                ctx.shadowColor = ('rgba(0,0,0,'+((count)?(count/me.store.max):'0.1')+')');

                ctx.shadowOffsetX = 15000; 
                ctx.shadowOffsetY = 15000; 
                ctx.shadowBlur = 15; 

                ctx.beginPath();
                ctx.arc(x - 15000, y - 15000, radius, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.fill();
                if(colorize){
                    // finally colorize the area
                    me.colorize(xb,yb);
                }else{
                    // or update the boundaries for the area that then should be colorized
                    if(xb < bounds["l"]){
                        bounds["l"] = xb;
                    }
                    if(yb < bounds["t"]){
                        bounds["t"] = yb;
                    }
                    if(xc > bounds['r']){
                        bounds['r'] = xc;
                    }
                    if(yc > bounds['b']){
                        bounds['b'] = yc;
                    }
                }
        },
        toggleDisplay: function(){
                var me = this,
                    visible = me.get("visible"),
                canvas = me.get("canvas");

                if(!visible)
                    canvas.style.display = "block";
                else
                    canvas.style.display = "none";

                me.set("visible", !visible);
        },
        // dataURL export
        getImageData: function(){
                return this.get("canvas").toDataURL();
        },
        clear: function(){
            var me = this,
                w = me.get("width"),
                h = me.get("height");

            me.store.set("data",[]);
            // @TODO: reset stores max to 1
            //me.store.max = 1;
            me.get("ctx").clearRect(0,0,w,h);
            me.get("actx").clearRect(0,0,w,h);
        },
        cleanup: function(){
            var me = this;
            me.get("element").removeChild(me.get("canvas"));
        }
    };

    return {
            create: function(config){
                return new heatmap(config);
            }, 
            util: {
                mousePosition: function(ev){
                    // this doesn't work right
                    // rather use
                    /*
                        // this = element to observe
                        var x = ev.pageX - this.offsetLeft;
                        var y = ev.pageY - this.offsetTop;

                    */
                    var x, y;

                    if (ev.layerX) { // Firefox
                        x = ev.layerX;
                        y = ev.layerY;
                    } else if (ev.offsetX) { // Opera
                        x = ev.offsetX;
                        y = ev.offsetY;
                    }
                    if(typeof(x)=='undefined')
                        return;

                    return [x,y];
                }
            }
        };
    })();
    w.h337 = w.heatmapFactory = heatmapFactory;
})(window);
/**
 * Class: Geo.Util.Format.BusCapabilities
 * 公交换乘服务Capabilities操作解析类，继承自Geo.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Format.XML>
 */
Geo.Util.Format.BusCapabilities = Geo.Class(Geo.Format.XML,{
	
    /**
     * APIProperty: tagName
     * {String} 常量"NETWORK_Capabilities" ,根据该服务的getCapabilities请求返回而定。
     */
	tagName: "NETWORK_Capabilities",

	 /**
     * APIMethod: read
     * 解析一个XML串并返回capabilitiesObj｛Object｝对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串。
     *
     * Returns:
     * ｛Object｝- capabilitiesObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var capabilitiesNode;
		if(data.nodeName != this.tagName){
			capabilitiesNode = data.getElementsByTagName(this.tagName);
		} else {
			capabilitiesNode = [data];
		}
		
		var capabilitiesObj = {};
		if(capabilitiesNode.length > 0){
			this.runChildNodes(capabilitiesObj, capabilitiesNode[0]);
		}
		return capabilitiesObj;
	},

	/**
     * Method: runChildNodes
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     *
     * Parameters:
     * obj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     * parentPath - {String}解析方法拼去，这里使用"capabilities"。
     * 
     */	
	runChildNodes: function(obj, node, parentPath) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
				if(parentPath){
					processor = this["read_" + parentPath + "_" + childNode.nodeName];
				} else{
					processor = this["read_" + childNode.nodeName];
				}
                
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },

	/**
     * Method: read_Service
     * 解析节点Service的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service: function(capabilitiesObj, node){
		var serviceObj = {};
		this.runChildNodes(serviceObj, node, "Service");
		capabilitiesObj.service = serviceObj;
	},

	/**
     * Method: read_Service_Name
     * 解析节点为Name的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_Name: function(servcieObj,node){
		var name = this.getChildValue(node);
		if(name) {
            servcieObj.name = name;
        }
	},

	/**
     * Method: read_Service_Title
     * 解析节点为Title的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象
     * node - ｛DOMElement｝ 需要解析的节点对象
     */		
	read_Service_Title: function(servcieObj,node){
		var title = this.getChildValue(node);
		if(title) {
            servcieObj.title = title;
        }
	},

	/**
     * Method: read_Service_Abstract
     * 解析节点为Abstract的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_Abstract: function(servcieObj,node){
		var serviceAbstract = this.getChildValue(node);
		if(serviceAbstract) {
            servcieObj.serviceAbstract = serviceAbstract;
        }
	},

	/**
     * Method: read_Service_KeywordList
     * 解析节点为KeywordList的节点。
     *
     * Parameters:
     * userScenarioObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Service_KeywordList: function(userScenarioObj,node){
	},

	/**
     * Method: read_Service_OnlineResource
     * 解析节点为OnlineResource的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_OnlineResource: function(servcieObj,node){
		var onlineResource = this.getChildValue(node);
		if(servcieObj) {
            servcieObj.onlineResource = onlineResource;
        }
	},

	/**
     * Method: read_Capability
     * 解析节点为Capability的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability: function(capabilitiesObj,node){
		var capaObj = {};
		this.runChildNodes(capaObj, node, "Capability");
		capabilitiesObj.capability = capaObj;
	},

	/**
     * Method: read_Capability_Request
     * 解析节点为Request的节点。
     *
     * Parameters:
     * capaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request: function(capaObj,node){
		var requestObj = {};
		this.runChildNodes(requestObj, node, "Capability_Request");
		capaObj.request = requestObj;
	},

	/**
     * Method: read_Capability_Request_GetCapabilities
     * 解析节点为GetCapabilities的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_GetCapabilities: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var getCapaObj ={};
		if(httpNode[0]){
			this.runChildNodes(getCapaObj, httpNode[0], "Capability_Request_GetCapabilities_DCPType_HTTP");
		}
		requestObj.getCapabilities = getCapaObj;
		
	},

	/**
     * Method: read_Capability_Request_GetCapabilities_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * getCapaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Get: function(getCapaObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            getCapaObj.getUrl = getUrl;
        }
	},

	/**
     * Method: read_Capability_Request_GetCapabilities_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Parameters:
     * getCapaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Post: function(getCapaObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            getCapaObj.postUrl = postUrl;
        }
	},
	
	/**
     * Method: read_Capability_Request_queryStation
     * 解析节点为queryStation的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryStation: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryStationObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryStationObj, httpNode[0], "Capability_Request_queryStation_DCPType_HTTP");
		}
		requestObj.queryStation = queryStationObj;
		
	},

	/**
     * Method: read_Capability_Request_queryStation_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryStationObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_queryStation_DCPType_HTTP_Get: function(queryStationObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryStationObj.getUrl = getUrl;
        }
	},
	
	read_Capability_Request_queryStation_DCPType_HTTP_Post: function(queryStationObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryStationObj.postUrl = postUrl;
        }
	},

	/**
     * Method: read_Capability_Request_queryLine
     * 解析节点为queryLine的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryLine: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryLineObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryLineObj, httpNode[0], "Capability_Request_queryLine_DCPType_HTTP");
		}
		requestObj.queryLine = queryLineObj;
		
	},

	/**
     * Method: read_Capability_Request_queryLine_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryLineObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */			
	read_Capability_Request_queryLine_DCPType_HTTP_Get: function(queryLineObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryLineObj.getUrl = getUrl;
        }
	},

	/**
     * Method: read_Capability_Request_queryLine_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Parameters:
     * queryLineObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryLine_DCPType_HTTP_Post: function(queryLineObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryLineObj.postUrl = postUrl;
        }	
	},

	/**
     * Method: read_Capability_Request_queryChange
     * 解析节点为queryChange的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryChangeObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryChangeObj, httpNode[0], "Capability_Request_queryChange_DCPType_HTTP");
		}
		
	},

	/**
     * Method: read_Capability_Request_queryChange_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryChangeObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Get: function(queryChangeObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryChangeObj.getUrl = getUrl;
        }
	},

	/**
     * Parameters: read_Capability_Request_queryChange_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Method:
     * queryChangeObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Post: function(queryChangeObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryChangeObj.postUrl = postUrl;
        }	
	},

	/**
     * Method: read_Capability_Networks
     * 解析节点为Networks的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Networks: function(capabilitiesObj,node){		
		var networkNodes = node.getElementsByTagName("Name");
		var networks = [];
		for(var i=0; i<networkNodes.length; i++){
			var network = this.getChildValue(networkNodes[i]);
			if(network){
				networks.push(network);
			}			
		}
		capabilitiesObj.networks = networks;
	},
	
	CLASS_NAME:"Geo.Util.Format.BusCapabilities"
});/**
 * Class: Geo.Util.Format.GlobeTileCapabilities
 * GlobeTile服务getCapabilities操作请求结果的XML解析器，继承自Geo.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Format.XML>
 */
Geo.Util.Format.GlobeTileCapabilities = Geo.Class(Geo.Format.XML,{
	
   /**
     * APIProperty: tagName
     * {String} 常量"ServiceCapabilities" ,根据该服务的getCapabilities请求返回而定。
     */
	tagName: "ServiceCapabilities",

	 /**
     * APIMethod: read
     * 解析一个XML串并返回capabilitiesObj{Object}对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串。
     *
     * Returns:
     * {Object}- capabilitiesObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var capabilitiesNode;
		if(data.nodeName != this.tagName){
			capabilitiesNode = data.getElementsByTagName(this.tagName);
		} else {
			capabilitiesNode = [data];
		}
		
		var capabilitiesObj = null;
		if(capabilitiesNode.length > 0){
			capabilitiesObj = {};
			this.runChildNodes(capabilitiesObj, capabilitiesNode[0], "capabilities");
		}
		return capabilitiesObj;
	},
	
	/**
     * Method: runChildNodes
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     *
     * Parameters:
     * obj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     * parentPath - {String}解析方法拼去，这里使用"capabilities"。
     * 
     */
	runChildNodes: function(obj, node, parentPath) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
                processor = this["read_" + parentPath + "_" + childNode.nodeName];
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },
	
	/**
     * Method: read_capabilities_Name
     * 解析节点为Name的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Name: function(capabilitiesObj, node){
		var name = this.getChildValue(node);
        if(name) {
            capabilitiesObj.name = name;
        }
	},
	
	/**
     * Method: read_capabilities_Service
     * 解析节点为Service的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Service: function(capabilitiesObj, node){
		var service = this.getChildValue(node);
        if(service) {
            capabilitiesObj.service = service;
        }
	},
	
	/**
     * Method: read_capabilities_Version
     * 解析节点为Version的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Version: function(capabilitiesObj, node){
		var version = this.getChildValue(node);
        if(version) {
            capabilitiesObj.version = version;
        }
	},
	
	/**
     * Method: read_capabilities_Abstract
     * 解析节点为Abstract的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Abstract: function(capabilitiesObj, node){
		var abstractValue = this.getChildValue(node);
        if(abstractValue) {
            capabilitiesObj.abstractValue = abstractValue;
        }
	},
	
	/**
     * Method: read_capabilities_ServerAddress
     * 解析节点为ServerAddress的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_ServerAddress: function(capabilitiesObj, node){
		var serverAddress = this.getChildValue(node);
        if(serverAddress) {
            capabilitiesObj.serverAddress = serverAddress;
        }
	},
	
	/**
     * Method: read_capabilities_OperationList
     * 解析节点为OperationList的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_OperationList: function(capabilitiesObj, node){
		var operationsNode = node.getElementsByTagName("Operations");
		if(operationsNode.length > 0){
			this.read_capabilities_OperationList_Operations(capabilitiesObj, operationsNode[0]);
		}
	},	
	
	/**
     * Method: read_capabilities_OperationList_Operations
     * 解析节点为Operations的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_OperationList_Operations: function(capabilitiesObj, node){
		var operationList = {};
		var operations = {};
		this.runChildNodes(operations, node, "capabilities_OperationList_Operations");
		operationList.operations = operations;
		capabilitiesObj.operationList = operationList;
	},	
	
	/**
     * Method: read_capabilities_OperationList_Operations_GetTile
     * 解析节点为GetTile的节点。
     *
     * Parameters:
     * operations - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_OperationList_Operations_GetTile: function(operations, node){
		var getTile = {};
		var format = [];
		var formatNode = node.getElementsByTagName("Format");
		if (formatNode.length > 0) {
			for(var i = 0; i < formatNode.length; i++){
				var formatValue = this.getChildValue(formatNode[i]);
				format.push(formatValue);
			}
			getTile.format = format;
		}
		operations.getTile = getTile;
	},
	
	/**
     * Method: read_capabilities_Data
     * 解析节点为Data的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data: function(capabilitiesObj, node){
		var tileDataNode = node.getElementsByTagName("TileData");
		if(tileDataNode.length > 0){
			this.read_capabilities_Data_TileData(capabilitiesObj, tileDataNode[0]);
		}
	},
	
	/**
     * Method: read_capabilities_Data_TileData
     * 解析节点为Data_TileData的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData: function(capabilitiesObj, node){
		var tileData = {}
		this.runChildNodes(tileData, node, "capabilities_Data_TileData");
		capabilitiesObj.tileData = tileData;
	},
	
	/**
     * Method: read_capabilities_Data_TileData_Tile
     * 解析节点为Tile的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_Tile: function(tileData, node){
		var tile = this.getChildValue(node);
        if(tile) {
            tileData.tile = tile;
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_CRS
     * 解析节点为CRS的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_CRS: function(tileData, node){
		var crs = this.getChildValue(node);
        if(crs) {
            tileData.crs = crs;
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_BoundBox
     * 解析节点为BoundBox的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_BoundBox: function(tileData, node){
		
		var boundBox = new Geo.Bounds(
			parseFloat(node.getAttribute("minx") || node.getAttribute("minX")),
			parseFloat(node.getAttribute("miny") || node.getAttribute("minY")),
			parseFloat(node.getAttribute("maxx") || node.getAttribute("maxX")),
			parseFloat(node.getAttribute("maxy") || node.getAttribute("maxY"))
		);
        tileData.boundBox = boundBox;
        
	},
	
	/**
     * Method: read_capabilities_Data_TileData_LevelZeroTileSizeX
     * 解析节点为LevelZeroTileSizeX的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_LevelZeroTileSizeX: function(tileData, node){
		var levelZeroTileSizeX = this.getChildValue(node);
        if(levelZeroTileSizeX) {
            tileData.levelZeroTileSizeX = parseInt(levelZeroTileSizeX);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_LevelZeroTileSizeY
     * 解析节点为LevelZeroTileSizeY的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_LevelZeroTileSizeY: function(tileData, node){
		var levelZeroTileSizeY = this.getChildValue(node);
        if(levelZeroTileSizeY) {
            tileData.levelZeroTileSizeY = parseInt(levelZeroTileSizeY);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TopLevel
     * 解析节点为TopLevel的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TopLevel: function(tileData, node){
		var topLevel = this.getChildValue(node);
        if(topLevel) {
            tileData.topLevel = parseInt(topLevel);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_BottomLevel
     * 解析节点为BottomLevel的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_BottomLevel: function(tileData, node){
		var bottomLevel = this.getChildValue(node);
        if(bottomLevel) {
            tileData.bottomLevel = parseInt(bottomLevel);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_DEMDataType
     * 解析节点为DEMDataType的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_DEMDataType: function(tileData, node){
		var demDataType = this.getChildValue(node);
        if(demDataType) {
            tileData.demDataType = demDataType;
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TileVersionTime
     * 解析节点为TileVersionTime的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TileVersionTime: function(tileData, node){
		var tileVerstionTime = this.getChildValue(node);
		if(tileVerstionTime){
			if(!tileData.tileVerstionTime){
				tileData.tileVerstionTime = []
			}
			tileData.tileVerstionTime.push(tileVerstionTime);
		}
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TilePixelsX
     * 解析节点为TilePixelsX的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TilePixelsX: function(tileData, node){
		var tilePixelsX = this.getChildValue(node);
        if(tilePixelsX) {
            tileData.tilePixelsX = parseInt(tilePixelsX);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TilePixelsY
     * 解析节点为TilePixelsY的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TilePixelsY: function(tileData, node){
		var tilePixelsY = this.getChildValue(node);
        if(tilePixelsY) {
            tileData.tilePixelsY = parseInt(tilePixelsY);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_CacheExpireTime
     * 解析节点为CacheExpireTime的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_CacheExpireTime: function(tileData, node){
		var cacheExpireTime = this.getChildValue(node);
        if(cacheExpireTime) {
            tileData.cacheExpireTime = parseInt(cacheExpireTime);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_Pyramid
     * 解析节点为Pyramid的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_Pyramid: function(tileData, node){
        var parser = new Geo.Util.Format.Pyramid();
		var pyramidObj = parser.read(node);
		tileData.pyramid = pyramidObj;
	},
	
	CLASS_NAME:"Geo.Util.Format.GlobeTileCapabilities"
});/**
 * Class: Geo.Util.Format.Pyramid
 * 金字塔XML描述解析器，继承自Geo.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Format.XML>
 */
Geo.Util.Format.Pyramid = Geo.Class(Geo.Format.XML,{
	
	 /**
     * APIProperty: tagName
     * {String} 金字塔标签名，默认为"Pyramid" 。
     */
	tagName: "Pyramid",

	/**
     * APIMethod: read
     * 解析金字塔XML描述字符串并返回解析后的JavaScript对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串。
     *
     * Returns:
     * {Object}- pyramidObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var pyramidNode;
		if(data.nodeName != this.tagName){
			pyramidNode = data.getElementsByTagName(this.tagName);
		} else {
			pyramidNode = [data];
		}
		var pyramidObj = {};
		if(pyramidNode.length > 0){
			this.runChildNodes(pyramidObj, pyramidNode[0]);
		}
		return pyramidObj;
	},
	
	/**
     * Method: runChildNodes
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     *
     * Parameters:
     * obj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     * 
     */
	runChildNodes: function(obj, node) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
                processor = this["read_Pyramid_" + childNode.nodeName];
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },
	
	/**
     * Method: read_Pyramid_Basic
     * 解析节点为Basic的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_Basic: function(pyramidObj, node){
		var basic = {
			name: node.getAttribute("Name"),
			pyramidID: node.getAttribute("PyramidID"),
			description: node.getAttribute("Description")
		};
		OpenLayers.Util.extend(pyramidObj, basic);
	},
	
	/**
     * Method: read_Pyramid_Level
     * 解析节点为Level的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_Level: function(pyramidObj, node){
		var level = {
			topLevelIndex: parseInt(node.getAttribute("TopLevelIndex")),
			bottomLevelIndex: parseInt(node.getAttribute("BottomLevelIndex")),
			scaleX: parseInt(node.getAttribute("ScaleX")),
			scaleY: parseInt(node.getAttribute("ScaleY"))
		};
		OpenLayers.Util.extend(pyramidObj, level);
	},
	
	/**
     * Method: read_Pyramid_TileBasic
     * 解析节点为TileBasic的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_TileBasic: function(pyramidObj, node){
		var tileBasic = {
			tileSizeX: parseFloat(node.getAttribute("TileSizeX")),
			tileSizeY: parseFloat(node.getAttribute("TileSizeY")),
			originRowIndex: parseInt(node.getAttribute("OriginRowIndex")),
			originColIndex: parseInt(node.getAttribute("OriginColIndex"))
		};
		OpenLayers.Util.extend(pyramidObj, tileBasic);
	},
	
	/**
     * Method: read_Pyramid_TopTile
     * 解析节点为TopTile的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_TopTile: function(pyramidObj, node){
		var topTile = {
			fromX: parseInt(node.getAttribute("FromX")),
			fromY: parseInt(node.getAttribute("FromY")),
			toX: parseInt(node.getAttribute("ToX")),
			toY: parseInt(node.getAttribute("ToY"))
		};
		OpenLayers.Util.extend(pyramidObj, topTile);
	},
	
	//无用，暂时关闭
	/*read_Pyramid_Const: function(pyramidObj, node){
		var constant = {
			pi: parseFloat(node.getAttribute("PI")),
			tolerance: parseFloat(node.getAttribute("Tolerance"))
		};
		OpenLayers.Util.extend(pyramidObj, constant);
	},*/
	
	/**
     * Method: read_Pyramid_Range
     * 解析节点为Range的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_Range: function(pyramidObj, node){
		var range = {
			xmin: parseInt(node.getAttribute("XMin")),
			xmax: parseInt(node.getAttribute("XMax")),
			ymin: parseInt(node.getAttribute("YMin")),
			ymax: parseInt(node.getAttribute("YMax"))
		};
		OpenLayers.Util.extend(pyramidObj, range);
	},
	
	CLASS_NAME: "Geo.Util.Format.Pyramid"	
});
/**
 * Class: Geo.Util.Format.XML2JSON
 * 将XML文件解析成Javascript对象。
 */
Geo.Util.Format.XML2JSON = Geo.Class({
	
	/**
	 * Constructor: Geo.Util.Format.XML2JSON
	 * Geo.Util.Format.XML2JSON构造函数。
	 */
	initialize: function(){
		
	},
	
    /**
	 * APIMethod: read
	 * 将传入的XML字符串解析成Javascript对象并返回。
	 *
	 * Parameters: 
	 * xmlcode - {String} XML字符串。
	 */	
	read: function(xmlcode,ignoretags,debug){
		if(!ignoretags){ignoretags=""};
		xmlcode=xmlcode.replace(/\s*\/>/g,'/>');
		xmlcode=xmlcode.replace(/<\?[^>]*>/g,"").replace(/<\![^>]*>/g,"");
		if (!ignoretags.sort){ignoretags=ignoretags.split(",")};
		var x=this.no_fast_endings(xmlcode);
		x=this.attris_to_tags(x);
		x=escape(x);
		x=x.split("%3C").join("<").split("%3E").join(">").split("%3D").join("=").split("%22").join("\"");
		for (var i=0;i<ignoretags.length;i++){
			x=x.replace(new RegExp("<"+ignoretags[i]+">","g"),"*$**"+ignoretags[i]+"**$*");
			x=x.replace(new RegExp("</"+ignoretags[i]+">","g"),"*$***"+ignoretags[i]+"**$*")
		};
		x='<JSONTAGWRAPPER>'+x+'</JSONTAGWRAPPER>';
		this.xmlobject={};
		
		//---------------------修正禁止属性小写后,出现jsontagwrapper变成数组
		var y=this.xml_to_object(x).JSONTAGWRAPPER;
		//var y=this.xml_to_object(x).jsontagwrapper;
		
		if(debug){y=this.show_json_structure(y,debug)};
		return y
	},
	
	xml_to_object:function(xmlcode){
		var x=xmlcode.replace(/<\//g,"?");
		x=x.split("<");
		var y=[];
		var level=0;
		var opentags=[];
		for (var i=1;i<x.length;i++){
			var tagname=x[i].split(">")[0];
			opentags.push(tagname);
			level++
			y.push(level+"<"+x[i].split("?")[0]);
			while(x[i].indexOf("?"+opentags[opentags.length-1]+">")>=0){level--;opentags.pop()}
		};
		var oldniva=-1;
		var objname="this.xmlobject";
		for (var i=0;i<y.length;i++){
			var preeval="";
			var niva=y[i].split("<")[0];
			var tagnamn=y[i].split("<")[1].split(">")[0];
			
			//---------------------修正:禁止将属性和标签统一成小写,并将命名空间的冒号转成下划线
			tagnamn = tagnamn.replace(/%3A/,"_");
			//tagnamn=tagnamn.toLowerCase();
			
			var rest=y[i].split(">")[1];
			if(niva<=oldniva){
				var tabort=oldniva-niva+1;
				for (var j=0;j<tabort;j++){objname=objname.substring(0,objname.lastIndexOf("."))}
			};
			objname+="."+tagnamn;
			var pobject=objname.substring(0,objname.lastIndexOf("."));
			if (eval("typeof "+pobject) != "object"){preeval+=pobject+"={value:"+pobject+"};\n"};
			var objlast=objname.substring(objname.lastIndexOf(".")+1);
			var already=false;
			for (k in eval(pobject)){if(k==objlast){already=true}};
			var onlywhites=true;
			for(var s=0;s<rest.length;s+=3){
				if(rest.charAt(s)!="%"){onlywhites=false}
			};
			if (rest!="" && !onlywhites){
				if(rest/1!=rest){
					rest="'"+rest.replace(/\'/g,"\\'")+"'";
					rest=rest.replace(/\*\$\*\*\*/g,"</");
					rest=rest.replace(/\*\$\*\*/g,"<");
					rest=rest.replace(/\*\*\$\*/g,">")
				}
			} 
			else {rest="{}"};
			if(rest.charAt(0)=="'"){rest='unescape('+rest+')'};
			if (already && !eval(objname+".sort")){preeval+=objname+"=["+objname+"];\n"};
			var before="=";after="";
			if (already){before=".push(";after=")"};
			var toeval=preeval+objname+before+rest+after;
			eval(toeval);
			if(eval(objname+".sort")){objname+="["+eval(objname+".length-1")+"]"};
			oldniva=niva
		};
		return this.xmlobject
	},
	show_json_structure:function(obj,debug,l){
		var x='';
		if (obj.sort){x+="[\n"} else {x+="{\n"};
		for (var i in obj){
			if (!obj.sort){x+=i+":"};
			if (typeof obj[i] == "object"){
				x+=this.show_json_structure(obj[i],false,1)
			}
			else {
				if(typeof obj[i]=="function"){
					var v=obj[i]+"";
					//v=v.replace(/\t/g,"");
					x+=v
				}
				else if(typeof obj[i]!="string"){x+=obj[i]+",\n"}
				else {x+="'"+obj[i].replace(/\'/g,"\\'").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r")+"',\n"}
			}
		};
		if (obj.sort){x+="],\n"} else {x+="},\n"};
		if (!l){
			x=x.substring(0,x.lastIndexOf(","));
			x=x.replace(new RegExp(",\n}","g"),"\n}");
			x=x.replace(new RegExp(",\n]","g"),"\n]");
			var y=x.split("\n");x="";
			var lvl=0;
			for (var i=0;i<y.length;i++){
				if(y[i].indexOf("}")>=0 || y[i].indexOf("]")>=0){lvl--};
				tabs="";for(var j=0;j<lvl;j++){tabs+="\t"};
				x+=tabs+y[i]+"\n";
				if(y[i].indexOf("{")>=0 || y[i].indexOf("[")>=0){lvl++}
			};
			if(debug=="html"){
				x=x.replace(/</g,"&lt;").replace(/>/g,"&gt;");
				x=x.replace(/\n/g,"<BR>").replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;")
			};
			if (debug=="compact"){x=x.replace(/\n/g,"").replace(/\t/g,"")}
		};
		return x
	},
	no_fast_endings:function(x){
		x=x.split("/>");
		for (var i=1;i<x.length;i++){
			var t=x[i-1].substring(x[i-1].lastIndexOf("<")+1).split(" ")[0];
			x[i]="></"+t+">"+x[i]
		}	;
		x=x.join("");
		return x
	},
	attris_to_tags: function(x){
		var d=' ="\''.split("");
		x=x.split(">");
		for (var i=0;i<x.length;i++){
			var temp=x[i].split("<");
			for (var r=0;r<4;r++){temp[0]=temp[0].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")};
			if(temp[1]){
				temp[1]=temp[1].replace(/'/g,'"');
				temp[1]=temp[1].split('"');
				for (var j=1;j<temp[1].length;j+=2){
					for (var r=0;r<4;r++){temp[1][j]=temp[1][j].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")}
				};
				temp[1]=temp[1].join('"')
			};
			x[i]=temp.join("<")
		};
		x=x.join(">");
		x=x.replace(/ ([^=]*)=([^ |>]*)/g,"><$1>$2</$1");
		x=x.replace(/>"/g,">").replace(/"</g,"<");
		for (var r=0;r<4;r++){x=x.replace(new RegExp("_jsonconvtemp"+r+"_","g"),d[r])}	;
		return x
	},
	
    CLASS_NAME: "Geo.Util.Format.XML2JSON"
});/**
 * Class: Geo.Util.Format.VwmtsGetVersionInfo
 * WMTS多时相服务getCapabilities操作请求结果的XML解析器，继承自Geo.Util.Format.XML2JSON类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Util.Format.XML2JSON>
 */
Geo.Util.Format.VwmtsGetVersionInfo = Geo.Class(Geo.Util.Format.XML2JSON, {
	
	 /**
     * APIMethod: read
     * 解析一个XML串并返回capabilitiesObj｛Object｝对象。
     *
     * Parameters:
     * xmlcode - {String} 一个XML字符串
     *
     * Returns:
     * ｛Object｝- capabilitiesObj
     */
    read: function(xmlcode){
        if(typeof data == "string") {
            data = Geo.Util.Format.XML2JSON.prototype.read.apply(this, [xmlcode]);
        }
		
		return data;
	},
	
	/**
     * APIProperty: CLASS_NAME
     * 类名标识
     */
	CLASS_NAME:"Geo.Util.Format.VwmtsGetVersionInfo"
});/**
 * Class: Geo.Util.Format.VwmtsGetVersions
 * WMTS多时相服务getCapabilities操作请求结果的XML解析器，继承自Geo.Util.Format.XML2JSON类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Util.Format.XML2JSON>
 */
Geo.Util.Format.VwmtsGetVersions = Geo.Class(Geo.Util.Format.XML2JSON, {
	
	/**
     * APIMethod: read
     * 解析一个XML串并返回versionsObj｛Object｝对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串
     *
     * Returns:
     * ｛Object｝- versionsObj
     */
    read: function(data){
        if(typeof data == "string") {
            data = Geo.Util.Format.XML2JSON.prototype.read.apply(this, [data]);
        }
		
		return data;
	},
	
	/**
     * APIProperty: CLASS_NAME
     * 类名标识
     */
	CLASS_NAME:"Geo.Util.Format.VwmtsGetVersions"
});/* Copyright (c) 2006-2010 by OpenLayers Contributors (see authors.txt for 
 * full list of contributors). Published under the Clear BSD license.  
 * See http://svn.openlayers.org/trunk/openlayers/license.txt for the
 * full text of the license. */

/**
 * @requires OpenLayers/Format/WMTSCapabilities.v1_0_0
 * @requires OpenLayers/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: VwmtsGetCapabilities.js
 * Read WMTS Capabilities version 1.0.0.
 * 
 * Inherits from:
 *  - <OpenLayers.Format.WMTSCapabilities.v1_0_0>
 */
OpenLayers.Format.VWMTSCapabilities = {};
OpenLayers.Format.VWMTSCapabilities.v1_0_0 = OpenLayers.Class(
    OpenLayers.Format.WMTSCapabilities.v1_0_0, {

    initialize: function(options) {
        OpenLayers.Format.WMTSCapabilities.v1_0_0.prototype.initialize.apply(this, arguments);
       
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {        
        "wmts": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, obj) {
                obj.contents = {};                
                obj.contents.layers = [];
                obj.contents.tileMatrixSets = {};                
                this.readChildNodes(node, obj.contents);
            },
            "Layer": function(node, obj) {
                var layer = {
                    styles: [],
                    formats: [],
                    tileMatrixSetLinks: [],
					dimensions:[]
                };
                layer.layers = [];
                this.readChildNodes(node, layer);
                obj.layers.push(layer);
            },
            "Style": function(node, obj) {
                var style = {};
                style.isDefault = (node.getAttribute("isDefault") === "true");
                this.readChildNodes(node, style);
                obj.styles.push(style);
            },
            "Format": function(node, obj) {
                obj.formats.push(this.getChildValue(node)); 
            },
			//多时相节点解析
			"Dimension": function(node, obj) {
				var dimension = {
					values:[]
				};
                this.readChildNodes(node, dimension);
                obj.dimensions.push(dimension);
            },
			"Value": function(node, obj) {
                obj.values.push(this.getChildValue(node));
            },
            "TileMatrixSetLink": function(node, obj) {
                var tileMatrixSetLink = {};
                this.readChildNodes(node, tileMatrixSetLink);
                obj.tileMatrixSetLinks.push(tileMatrixSetLink);
            },
            "TileMatrixSet": function(node, obj) {
                // node could be child of wmts:Contents or wmts:TileMatrixSetLink
                // duck type wmts:Contents by looking for layers
                if (obj.layers) {
                    // TileMatrixSet as object type in schema
                    var tileMatrixSet = {
                        matrixIds: []
                    };
                    this.readChildNodes(node, tileMatrixSet);
                    obj.tileMatrixSets[tileMatrixSet.identifier] = tileMatrixSet;
                } else {
                    // TileMatrixSet as string type in schema
                    obj.tileMatrixSet = this.getChildValue(node);
                }
            },
            "TileMatrix": function(node, obj) {
                var tileMatrix = {
                    supportedCRS: obj.supportedCRS
                };
                this.readChildNodes(node, tileMatrix);
                obj.matrixIds.push(tileMatrix);
            },
            "ScaleDenominator": function(node, obj) {
                obj.scaleDenominator = parseFloat(this.getChildValue(node)); 
            },
            "TopLeftCorner": function(node, obj) {
                var topLeftCorner = this.getChildValue(node);
                var coords = topLeftCorner.split(" ");
                // decide on axis order for the given CRS
                var yx;
                if (obj.supportedCRS) {
                    // extract out version from URN
                    var crs = obj.supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):.+:(\w+)$/, 
                        "urn:ogc:def:crs:$1::$2"
                    );
					//支持对老服务的判断
					var old = crs.search(/GEOGCS/);
					//新服务
					if(old === -1) {
						var crss = crs.split("urn:ogc:def:crs:");
						var epsg = crss[1].replace(/::/, ":");
						yx = OpenLayers.ProjAxisOrder.AxisOrder[epsg];
					}else {//老服务，老服务使用的是强制东西向的顺序
						yx = true;
					}
                }
				if(this.isReverse === true) {
					//如果是false,则是纬度，经度顺序
					if(yx === false) {
						if (yx) {
							obj.topLeftCorner = new OpenLayers.LonLat(
								coords[0], coords[1]
							);
						} else {
							obj.topLeftCorner = new OpenLayers.LonLat(
		                        coords[1], coords[0]
		                    );
						}
					}else if(yx === true) {//如果是true,则是经度，纬度顺序
						obj.topLeftCorner = new OpenLayers.LonLat(
							coords[1], coords[0]
						);
					}else {//未知投影,按经度，纬度顺序处理
						obj.topLeftCorner = new OpenLayers.LonLat(
							coords[1], coords[0]
						);
					}
				}else if(this.isReverse === false) {
					//如果是false,则表示EPSG号的轴向是纬度，经度顺序。
					if(yx === false) {
						if (yx) {
							obj.topLeftCorner = new OpenLayers.LonLat(
								coords[1], coords[0]
							);
						} else {//如果yx为false,则表示EPSG号的轴向是纬度，经度顺序
							obj.topLeftCorner = new OpenLayers.LonLat(
								coords[0], coords[1]
							);
						}
					}else if(yx === true) {//如果是true,则是经度，纬度顺序
						obj.topLeftCorner = new OpenLayers.LonLat(
							coords[0], coords[1]
						);
					}else {//未知投影,按经度，纬度顺序处理
						obj.topLeftCorner = new OpenLayers.LonLat(
							coords[0], coords[1]
						);
					}
				}
            },
            "TileWidth": function(node, obj) {
                obj.tileWidth = parseInt(this.getChildValue(node)); 
            },
            "TileHeight": function(node, obj) {
                obj.tileHeight = parseInt(this.getChildValue(node)); 
            },
            "MatrixWidth": function(node, obj) {
                obj.matrixWidth = parseInt(this.getChildValue(node)); 
            },
            "MatrixHeight": function(node, obj) {
                obj.matrixHeight = parseInt(this.getChildValue(node)); 
            },        
            "WSDL": function(node, obj) {
                obj.wsdl = {};
                obj.wsdl.href = node.getAttribute("xlink:href");
            },
            "ServiceMetadataURL": function(node, obj) {
                obj.serviceMetadataUrl = {};
                obj.serviceMetadataUrl.href = node.getAttribute("xlink:href");
            }            
        },
        "ows": OpenLayers.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "OpenLayers.Format.WMTSCapabilities.v1_0_0" 

});
/**
 * Class: Geo.Util.Format.MapServiceQuery
 * 解析地图服务query接口的查询结果
 */
Geo.Util.Format.MapServiceQuery = Geo.Class(Geo.Format.JSON, {
    
    /**
     * Constructor: Geo.Util.Format.MapServiceQuery
     * 创建一个地图服务查询接口解析器
     */

    /**
     * APIMethod: read
     * 传入一个json串，将json串转换为要素对象
     *
     * Parameters:
     * json - {String} 解析查询返回的json串
     *    输入参数举例：
     *    点：
     *    {
     *    	features:[{
     *    		attributes:{"NAME":"007"},
	 *		   "geometry": {
	 *		       "x": 116.38094,
	 *		       "y": 39.923614999999998
	 *		   }
     *    	}]
     *    }
     *    线：
     *     {"features": [
	 *		  {
	 *		   "attributes": {
	 *		    "NAME": "ÑÀÁÖÏß"
	 *		   },
	 *		   "geometry": {
	 *		    "paths": [
	 *		     [
	 *		      [
	 *		       122.09497,
	 *		       52.033745000000003
	 *		      ],
	 *		      [
	 *		       120.75324999999999,
	 *		       49.269401999999999
	 *		      ]
	 *		     ]
	 *		    ]
	 *		   }
	 *		  }]}
     *     面：
     *      {"features": [
	 *		  {
	 *		   "attributes": {
	 *		    "NAME": "ºÚÁú½­Ê¡"
	 *		   },
	 *		   "geometry": {
	 *		    "rings": [
	 *		     [
	 *		      [
	 *		       121.48844,
	 *		       53.332649000000004
	 *		      ],
	 *		      [
	 *		       125.62043,
	 *		       53.067318
	 *		      ],
	 *		      [
	 *		       130.99547000000001,
	 *		       47.698345000000003
	 *		      ]
	 *		     ]
	 *		    ]
	 *		   }
	 *		  }}
     * filter - {Function} 过滤查询结果
     *
     * Returns: 
     * {Array} 返回要素对象数组
     */
    read: function(json, filter) {
        var features = [];
        var obj = null;
        if (typeof json == "string") {
            obj = OpenLayers.Format.JSON.prototype.read.apply(this,
                                                              [json, filter]);
        } else { 
            obj = json;
        }    
        if(!obj) {
            return features;
        } else if(!obj.features) {
            OpenLayers.Console.error("Bad GeoJSON - no type: " + json);
        } else if(obj.features.length > 0) {
			for(var i = 0,j = obj.features.length; i < j; i++) {
				features.push(this.parseFeature(obj.features[i]));
			}
        }
        return features;
    },
	
	/**
     * APIMethod: write
     * 将一个要素或一个几何对象或者要素数组转换成json串
     * 
     * Parameters:
     * obj - {Object} 可以传递一个要素对象，一个geometry对象或者一个要素对象。注意:geometry对象只支持point,MultiLineString以及Polygon 
     * pretty - {Boolean} 是否序列号输出结果，默认为false
     *
     * Returns:
     * {String} 根据输入的要素或几何对象或要素数组得到与其对应的json串 
     */
    write: function(obj, pretty) {
      	var json = {};
		var features = [];
        if(OpenLayers.Util.isArray(obj)) {
            for(var i=0; i<obj.length; ++i) {
                var element = obj[i];
                if(!element instanceof OpenLayers.Feature.Vector) {
                    var msg = "该对象在数组中不是要素 " +
                              "" + element;
                    throw msg;
                }
                var geometry = this._getGeometryRepresentation(obj[i].geometry);
				var attributes = obj[i].attributes;
				var ajson = OpenLayers.Util.extend({}, {
					attributes:attributes,
					geometry:geometry
				});
				features.push(ajson);
            }
			json.features = features;
        } else if (obj.CLASS_NAME.indexOf("OpenLayers.Geometry") == 0) {
         	var geometry = this._getGeometryRepresentation(obj);
			json.geometry = geometry;
        } else if (obj instanceof OpenLayers.Feature.Vector) {
			var geometry = this._getGeometryRepresentation(obj.geometry);
			var attributes = obj.attributes;
			OpenLayers.Util.extend(json, {
				attributes:attributes,
				geometry:geometry
			});
        }
        return OpenLayers.Format.JSON.prototype.write.apply(this,
                                                            [json, pretty]);
    },
	
	/**
	 * 得到arcgis可以理解的几何表示法
	 * @param {Object} geometry
	 */
	_getGeometryRepresentation: function(geometry) {
		if(!geometry) {
			return undefined;
		}
		var name = geometry.CLASS_NAME;
		var jsonObj = null;
		switch(name) {
			case "OpenLayers.Geometry.Point":
				jsonObj = {x:geometry.x,y:geometry.y};
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				jsonObj = {rings:json.coordinates};
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				jsonObj = {paths:json.coordinates};
				break;		
			case "OpenLayers.Geometry.LineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				jsonObj = {paths:[json.coordinates]};
				break;		
		}
		return jsonObj;
	},
	
    /**
     * Method: parseFeature
     * 将表示要素的json对象转换成要素
     * Parameters:
     * obj - {Object}一个json对象
     *
     * Returns:
     * {<OpenLayers.Feature.Vector>} A feature.
     */
    parseFeature: function(obj) {
		var olGeometry = this._getGeometry(obj.geometry);
		var attributes = this._getAttribute(obj.attributes);
		var f = new OpenLayers.Feature.Vector(olGeometry,attributes);
        return  f;
    },
	
	/**
	 * 得到openlayers几何对象
	 * @param {Object} geometry
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
   
	/**
	 * 得到要素的属性信息
	 * @param {Object} geometry
	 */
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(Geo.Util.isArray(attrs))) {
			attrs = [attrs];
		}
		if(Geo.Util.isArray(attrs)) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * 将几何信息的json表示转换成
	 * @param {Object} geometry
	 */
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
		
    /**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: {
        /**
         * Method: extract.feature
         * Return a partial GeoJSON object representing a single feature.
         *
         * Parameters:
         * feature - {<OpenLayers.Feature.Vector>}
         *
         * Returns:
         * {Object} An object representing the point.
         */
        'feature': function(feature) {
            var geom = this.extract.geometry.apply(this, [feature.geometry]);
            var json = {
                "type": "Feature",
                "properties": feature.attributes,
                "geometry": geom
            };
            if (feature.fid != null) {
                json.id = feature.fid;
            }
            return json;
        },
        
        /**
         * Method: extract.geometry
         * Return a GeoJSON object representing a single geometry.
         *
         * Parameters:
         * geometry - {<OpenLayers.Geometry>}
         *
         * Returns:
         * {Object} An object representing the geometry.
         */
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }
            if (this.internalProjection && this.externalProjection) {
                geometry = geometry.clone();
                geometry.transform(this.internalProjection, 
                                   this.externalProjection);
            }                       
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            if(geometryType == "Collection") {
                json = {
                    "type": "GeometryCollection",
                    "geometries": data
                };
            } else {
                json = {
                    "type": geometryType,
                    "coordinates": data
                };
            }
            
            return json;
        },

        /**
         * Method: extract.point
         * Return an array of coordinates from a point.
         *
         * Parameters:
         * point - {<OpenLayers.Geometry.Point>}
         *
         * Returns: 
         * {Array} An array of coordinates representing the point.
         */
        'point': function(point) {
            return [point.x, point.y];
        },

        /**
         * Method: extract.multipoint
         * Return an array of point coordinates from a multipoint.
         *
         * Parameters:
         * multipoint - {<OpenLayers.Geometry.MultiPoint>}
         *
         * Returns:
         * {Array} An array of point coordinate arrays representing
         *     the multipoint.
         */
        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.linestring
         * Return an array of coordinate arrays from a linestring.
         *
         * Parameters:
         * linestring - {<OpenLayers.Geometry.LineString>}
         *
         * Returns:
         * {Array} An array of coordinate arrays representing
         *     the linestring.
         */
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        /**
         * Method: extract.multilinestring
         * Return an array of linestring arrays from a linestring.
         * 
         * Parameters:
         * linestring - {<OpenLayers.Geometry.MultiLineString>}
         * 
         * Returns:
         * {Array} An array of linestring arrays representing
         *     the multilinestring.
         */
        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.polygon
         * Return an array of linear ring arrays from a polygon.
         *
         * Parameters:
         * polygon - {<OpenLayers.Geometry.Polygon>}
         * 
         * Returns:
         * {Array} An array of linear ring arrays representing the polygon.
         */
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        },

        /**
         * Method: extract.multipolygon
         * Return an array of polygon arrays from a multipolygon.
         * 
         * Parameters:
         * multipolygon - {<OpenLayers.Geometry.MultiPolygon>}
         * 
         * Returns:
         * {Array} An array of polygon arrays representing
         *     the multipolygon
         */
        'multipolygon': function(multipolygon) {
            var array = [];
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
                array.push(this.extract.polygon.apply(this, [multipolygon.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.collection
         * Return an array of geometries from a geometry collection.
         * 
         * Parameters:
         * collection - {<OpenLayers.Geometry.Collection>}
         * 
         * Returns:
         * {Array} An array of geometry objects representing the geometry
         *     collection.
         */
        'collection': function(collection) {
            var len = collection.components.length;
            var array = new Array(len);
            for(var i=0; i<len; ++i) {
                array[i] = this.extract.geometry.apply(
                    this, [collection.components[i]]
                );
            }
            return array;
        }
    },

    CLASS_NAME: "Geo.Util.Format.MapServiceQuery" 
});     ﻿﻿﻿﻿﻿/**
 * Class: Geo.Util.Format.GeoTextFeatures
 * 文字服务结果解析器。
 * 
 * Inherits from:
 *  - <Geo.Format.JSON>
 */
Geo.Util.Format.GeoTextFeatures = Geo.Class(Geo.Format.JSON, {
	
	/**
	 * Property: json
	 * {Object} 结果对象。
	 */
	json: null,
	
	/**
	 * Property: layersStyle
	 * {Object} 图层样式。
	 */
	layersStyle: null,
	
	/**
	 * Property: commonFeatures
	 * 用于保存所有的线或面
	 * gid与几何对象的键值对
	 */
	commonFeatures:{},
	
	/**
	 * Constructor: Geo.Util.Format.GeoTextFeatures 
	 * Geo.Util.Format.GeoTextFeatures 构造函数。
	 */
	initialize: function(options) {
       OpenLayers.Util.extend(this, options);
    },
	
	/**
	 * Method: cleanCommonFeatures
	 * 清除要素。
	 */
	cleanCommonFeatures: function() {
		for(var feature in this.commonFeatures) {
			delete this.commonFeatures[feature];
		}
	},
	
	/**
	 * APIMethod: read
	 * 读取服务返回的JSON串。
	 * 
	 * Parameters:
	 * json {String} 服务返回的字符串
	 * return {Object} JSON对象
	 */
	read: function(json, filter) {
		var text = {};
		
		if (typeof json == "string") {
            this.json = OpenLayers.Format.JSON.prototype.read.apply(this,[json, filter]);
			if(this.json.error) {
				text = this.json;
				return text;
			}
			text["tile"] = this.features["tile"].apply(this, [this.json["tile"]]);
		}
		return text;
	},
	
	/**
	 * Method:_getGeometry
	 * 将OGC JSON 几何信息标示方法转换成openlayers几何表示法得到openlayers几何对象。
	 * 
	 * Parameters:
	 * geometry - {Object} OGC REST 方式表示几何信息。
	 * gid - {String} 要素ID。
	 * 
	 * Returns: 
     * {Geo.Geometry} 几何对象。
	 */
	_getGeometry: function(geometry,gid) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			geometry.gid = gid
			return geometry;
		}
	},
	
	/**
	 * Property:_geometryType
	 * 将几何信息的json表示转换成
	 */
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				if(geometry.length === 1) {
					var ps = [];
					for(var p = 0,points = geometry[0].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[0][p][0],geometry[0][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					return line;
				}else if(geometry.length > 1) {
					for(var i = 0, j = geometry.length; i < j; i++) {
						var ps = [];
						for(var p = 0,points = geometry[i].length; p < points;p++) {
							ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
						}
						var line = new OpenLayers.Geometry.LineString(ps);
						lines.push(line);
					}
					var paths = new OpenLayers.Geometry.MultiLineString(lines);
				}
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	convertLabelToMultiRow: function(label,featureStyle) {
		var defaultLabel = label;
		label = OpenLayers.String.trim(label);
		//换行算法开始----
		var labelLength = Math.ceil(label.length);
		var eachRowNumer = null;
		//每行显示多少条
		if(this.isCustomStyle && featureStyle && typeof featureStyle.maxCharactersPerLine === "number") {
			eachRowNumer = featureStyle.maxCharactersPerLine;
		}else {
			eachRowNumer = this.eachRowNumer;
		}
		//得到文字显示的行数
		var rowNumber = Math.ceil(label.length/eachRowNumer);
		if(rowNumber > 1) {
			//得到除了最后一行以外的其他行的子的个数
			var charNumerNoLast = Math.ceil(label.length/rowNumber);
			//最后一行
			var lastRowNumber = label.length - charNumerNoLast * (rowNumber - 1);
			var nowStr = "";
			for(var i = 0; i <= rowNumber - 1; i++) {
				if(i === rowNumber - 1) {
					nowStr+=(label.slice(label.length - (lastRowNumber),label.length));
					break;
				}
				nowStr+=(label.slice(i * charNumerNoLast,i * charNumerNoLast + charNumerNoLast)+"\n");
			}
			return nowStr;
		}
		//换行算法结束----
		return defaultLabel;
	},
	
	/**
	 * Property:featureTypes
	 * 根据几何信息生成要素。
	 */
	featureTypes : {
		"Point": function(geometry, featureJson,style) {
			if(!this.isCustomStyle) {
				var featureStyle = null;
				var url = null;
				var location = this.url.indexOf("/",this.url.length - 1);
				if(location != -1) {
					//TODO：图片格式可能是png，也可能是其他格式
					url = this.url + "Icon/"+ featureJson.grid+"?version=1.0.0&service=TEXT";
				}else {
					url = this.url + "/Icon/" + featureJson.grid+"?version=1.0.0&service=TEXT";
				}
				//	TODO:url需要想办法传入，此问题没解决
				if(typeof featureJson.grid === "number" && featureJson.text) {
					featureStyle = {
		                //设置点的图标. TODO:请求格式后面会有变化
		                externalGraphic: url,
						//标注名称
		                label: featureJson.text,
						graphicHeight:10,
						graphicWidth:10,
		                fontSize: "14px"
		            };
				}else if(!featureJson.grid && featureJson.text) {
				//	featureStyle = Geo.Util.extend({},OpenLayers.Feature.Vector.style['default']);
					featureStyle.label = featureJson.text;
				}else if(featureJson.grid && !featureJson.text){
					//有图标没有文字
					featureStyle = {
		                //设置点的图标. TODO:请求格式后面会有变化
		                externalGraphic: url,
						//标注名称
		                label: featureJson.text,
						graphicHeight:10,
						graphicWidth:10,
		                fontSize: "14px"
		            };
				}else {//没有图标且没有文字标注的点
			//		featureStyle = Geo.Util.extend({},OpenLayers.Feature.Vector.style['default']);
					featureStyle = {
		                //设置点的图标. TODO:请求格式后面会有变化
		                externalGraphic: url,
						//标注名称
		                label: " ",
						graphicHeight:10,
						graphicWidth:10,
		                fontSize: "14px"
		            };
					return null;
				}
				style = Geo.Util.extend(featureStyle,style);
			}
			if(!featureJson.text) {
				return null;
			}
			var featurStyle = Geo.Util.extend(featureStyle,style);
			featurStyle.label = this.convertLabelToMultiRow(featureJson.text,featureStyle);
			
            var labelFeature = new Geo.Feature.Vector(geometry, null, featurStyle);
			return labelFeature;
		},
		"LineString": function(geometry, featureJson,style) {

			var linestyle = null;
			//如果存在文字标注
			if(style && typeof featureJson.text === "string" && featureJson.text.length > 0) {
				linestyle = {
			        strokeColor: "#ee9900",
			        strokeOpacity: 1,
			        strokeWidth: 6
			    };
				linestyle.alongLineLabel = featureJson.text;
			}else {
				linestyle = Geo.Util.extend({
					strokeColor: "#ee9900",
			        strokeOpacity: 1,
			        strokeWidth: 6
				},linestyle);
				linestyle.alongLineLabel = featureJson.text;
			}
			linestyle = Geo.Util.extend(linestyle,style);
	        var lineStringFeature = new Geo.Feature.Vector(geometry,null,linestyle);
			return lineStringFeature;
		},
		"MultiLineString": function(geometry, featureJson,style) {
			var linestyle = null;
			if(style && typeof featureJson.text === "string") {
				style = Geo.Util.extend({alongLineLabel:featureJson.text},style);
				linestyle = {
			        strokeColor: "#ee9900",
			        strokeOpacity: 1,
			        strokeWidth: 6
			    };
				linestyle.alongLineLabel = featureJson.text;
			}else {
				linestyle = Geo.Util.extend({
					strokeColor: "#ee9900",
			        strokeOpacity: 1,
			        strokeWidth: 6
				},linestyle);
				linestyle.alongLineLabel = featureJson.text;
			}
			linestyle = Geo.Util.extend(linestyle,style);
	        var lineStringFeature = new Geo.Feature.Vector(geometry,null,linestyle);
			
			return lineStringFeature;
		},
		"Polygon": function(geometry, featureJson,style) {
			//面要素
			var polygonFeature = null;
			//如果有文字标注并且没有点图标的时候，文字就设置为样式的label。
			if(typeof featureJson.text === "string" && featureJson.text.length > 0 && featureJson.grid === undefined) {
				if(style) {
					style.label = featureJson.text;
				}
			}else if(typeof featureJson.text === "string" && featureJson.text.length > 0 && featureJson.grid !== undefined){
				if(style) {
					style.label = featureJson.text;
				}
			}
			var point = geometry.getCentroid();
			featureStyle = {
                //设置点的图标. TODO:可以开放一个参数，请求本地的图标
                externalGraphic: "",
				//标注名称
                label: featureJson.text,
				type:"polygon",
				graphicHeight:10,
				graphicWidth:10,
                fontSize: "14px"
            };
			pstyle = Geo.Util.extend(featureStyle,style);
			polygonFeature = new Geo.Feature.Vector(point,null,pstyle);
			return polygonFeature;
		},
		//fixed:面带图标的情况不予考虑
		"Polygon_markerTextPoint": function (geometry,grid,text,url) {
			//得到质心:TODO：后面可能会变成接口公开
			var centro = geometry.getCentroid();
			//	TODO:url需要想办法传入，此问题没解决
			var featureStyle = {
                //设置点的图标
                externalGraphic: (url+"/"+ grid +"?version=1.0.0&service=TEXT"),
                //设置图标的宽高
                graphicHeight:32,
                graphicWidth: 32,
				//标注名称
                label: text,
                fontSize: "12px"
            };
			//TODO:点的位置由数据的质心或中心点定
            var labelFeature = new Geo.Feature.Vector(centro, null, featureStyle);
			return labelFeature;
		}
	},
	
	/**
	 * Property:features
	 * 解析features接口
	 */	
	features: {
		"labelGeometry": function(labelGeometry) {//解析labelGeometry节点
			var geometryArray = [];
			for(var i = 0, len = labelGeometry.length; i < len; i++) {
				var geometry = this._getGeometry.apply(this, [labelGeometry[i]["geometry"],labelGeometry[i].gid]);
				if(geometry === undefined) {
					continue;
				}
				geometryArray.push(geometry)
			}
			return geometryArray;
		},
		"tile": function(tile) {//解析tiles节点
			var featurestileGroup = [];
			var FeaturesTileArr = [];
			for(var i = 0, len = tile.length; i < len; i++) {
				
				var features = this.features["layer"].apply(this, [tile[i].layer]);
				var featuresTile = new Geo.Util.Format.GeoTextFeatures.FeaturesTile({
					row: parseInt(tile[i].x),
					col: parseInt(tile[i].y),
					level: parseInt(tile[i].l),
					features: features
				});
				featurestileGroup.push(featuresTile);
			}
			
			return featurestileGroup;
		},
		"l": function() {},
		"x": function(){},
		"y": function(){},
		"layer": function(layers) {
			var layersArr = [];
			var features = [];
			for(var i = 0; i < layers.length; i++) {
				var style = null;
				if(this.layersStyle) {
					style = this.layersStyle[layers[i].layerName];
				}
				var layerFeatures = this.features["feature"].apply(this, [layers[i].feature,style]);
				features = features.concat(layerFeatures);
			}
			return features;
		},
		"layerName": function() {
			
		},
		"feature": function(features, style) {
			var labelGeometry = this.features["labelGeometry"].apply(this, [this.json.labelGeometry]);
			var featuresArr = [];
			for(var i = 0,len1 = features.length ; i < len1; i++) {
				//要素json对象
				var featureJson = features[i];
				for(var j = 0, len = labelGeometry.length; j < len; j++) {
					//如果gid与geometry 的id一致，那么就创建features
					if(labelGeometry[j].gid === featureJson.gid) {
						if(featureJson.gid in this.commonFeatures) {
							continue;
						}
						var feature = null;
						if(labelGeometry[j] instanceof Geo.Geometry.Polygon) {
							feature = this.featureTypes["Polygon"].apply(this, [labelGeometry[j],featureJson,style]);
							this.commonFeatures[featureJson.gid] = feature;
						}else if(labelGeometry[j] instanceof Geo.Geometry.LineString) {
							feature = this.featureTypes["LineString"].apply(this, [labelGeometry[j],featureJson,style]);
							this.commonFeatures[featureJson.gid] = feature;
						}else if(labelGeometry[j] instanceof Geo.Geometry.MultiLineString) {
							feature = this.featureTypes["MultiLineString"].apply(this, [labelGeometry[j],featureJson,style]);
						}else if(labelGeometry[j] instanceof Geo.Geometry.Point) {
							feature = this.featureTypes["Point"].apply(this, [labelGeometry[j],featureJson,style]);
							this.commonFeatures[featureJson.gid] = feature;
							if(feature == null) {
								continue;
							}
						}
						featuresArr.push(feature);
					}
				}
			}
			return featuresArr;
		}
	},
	
    CLASS_NAME: "Geo.Util.Format.GeoTextFeatures"
});

﻿﻿﻿﻿/**
 * Class: Geo.Util.Format.GeoTextFeatures
 * 文字服务瓦片类。说明：本类处理的是文字服务的点数据
 */
Geo.Util.Format.GeoTextFeatures.FeaturesTile = Geo.Class({
	
	id: null,
	
	/**
	 * Property: row
	 * {Integer} 行号。
	 */
	row: 0,
	
	/**
	 * Property: col
	 * {Integer} 列号。
	 */
	col: 0,
	
	/**
	 * Property: level
	 * {Integer} 层级。
	 */
	level: 0,
	
	/**
	 * Property: features
	 * {Array(Geo.Feature.Vector)} 点要素。
	 */
	features: null,
	
	/**
	 * Property: tileBounds
	 * {Geo.Bounds} 瓦片范围。
	 */
	tileBounds: null,
	
	/**
	 * Constructor: initialize
	 * 瓦片类构造器。
	 */
	initialize: function(options) {
       OpenLayers.Util.extend(this, options);
    },
	
	/**
	 * Method: destroy
	 * 销毁瓦片类。
	 */
	destroy: function(){
		this.features = [];
		this.features = null;
		this.tileBounds = null;
		this.id = null;
		this.row = null;
		this.col = null;
		this.level = null;
	}
});

/**
 * 沿线标签类
 */
Geo.Util.Format.GeoTextFeatures.LineLabelGroup = Geo.Class({
	
	/**
	 * Property: features
	 * {Array(Geo.Feature.Vector)} 沿线标注要素。
	 */
	features:[],
	
	/**
	 * Property: labelCharSpace
	 * {Array(Geo.Feature.Vector)} 沿线标注字间距。
	 */
	labelCharSpace: 5,
	
	/**
	 * Property: isVisibleLabel
	 * {Boolean} 标注是否可见。
	 */
	isVisibleLabel: true,
	
	/**
	 * Property: label
	 * {String} 标注名称。
	 */
	label: null,
	
	/**
	 * Constructor: initialize
	 * 沿线标签类。
	 */
	initialize: function(options) {
		this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
		OpenLayers.Util.extend(this, options);
		//防止一组文字标注单个字之间文字相交
		this.isIntersectLabelChar();
    },
	
	/**
	 * Method: getLabelCharBounds
	 * 得到单个文字的范围。
	 */
	getLabelCharBounds: function(feature, map) {
		var position = new Geo.LonLat(feature.geometry.x, feature.geometry.y);
        var charCount = feature.style.label.length;
        var res = map.getResolution();
        var size = new Geo.Size((parseInt(feature.style.fontSize))*charCount*res,parseInt(feature.style.fontSize)*res);
        var charBounds = new Geo.Bounds(position.lon-size.w/2, position.lat-size.h/2,
                                          position.lon+size.w/2, position.lat+size.h/2);
										  
						  
		return charBounds;
	},
	
	/**
	 * Method: isIntersectLabelChar
	 * 单个字之间是否相交。
	 */
	isIntersectLabelChar: function() {
		var features = this.features;
		for(var i = 0; i < features.length - 1; i++) {
			var precharBounds = this.getLabelCharBounds(features[i], map);
			var nextcharBounds = this.getLabelCharBounds(features[i + 1], map);
			var isIntersect = precharBounds.intersectsBounds(nextcharBounds, false);
			if(isIntersect) {
				this.isVisibleLabel = false;
				break;
			}
		}
	},
	
	/**
	 * Method: getLabelBounds
	 * 得到线上字所站的范围。
	 */
	getLabelBounds: function(map) {
		var labelBounds = null;
		var features = this.features;
		for(var i = 0; i < features.length; i++) {
			var charBounds = this.getLabelCharBounds(features[i], map);
			if(labelBounds == null) {
				labelBounds = charBounds;
			}else {
				labelBounds.extend(charBounds);
			}	
		}
		return labelBounds;
	},
	
	/**
	 * Method: destroy
	 * 销毁沿线标注对象。
	 */
	destroy: function() {
		this.features = [];
		this.features = null;
		this.labelCharSpace = null;
		this.isShowLabel = null;
		this.label = null;
	},
	
	CLASS_NAME:"LineLabelGroup"
	
});/**
 * Class: Geo.Util.GeoAvoidObject
 * 标注对象 。
 */
Geo.Util.GeoAvoidObject = Geo.Class({
    /**
     * APIProperty: positions
     * {Array} 。
     */
	positions: [],
	
	/**
     * APIProperty: postionIndex
     * {Int} 。
     */
	postionIndex: 0,
	
	 /**
     * APIProperty: rect
     * {Array} 。
     */
	rects: [],
	
	/**
     * APIProperty: featrueObject
     * {Object} 。
     */
	featrueObject:null,

	/**
	 * Constructor: Geo.Util.Text.GeoAvoidObject
	 * Geo.Util.Text.GeoAvoidObject构造函数。
	 */
	initialize: function(){
		
	},
	
	 /**
     * APIMethod: isIntersect
     * 判断当前标注对象与传入的标注对象是否相交  。
     *
     * Parameters:
     * other - {GeoAvoidObject}  传入的标注对象。
     *
     * Returns:
     * ｛Boolean｝
     */ 
	isIntersect:function(other){
		var offsetX = this.positions[this.postionIndex].x - other.positions[other.postionIndex].x;
		var offsetY = this.positions[this.postionIndex].y - other.positions[other.postionIndex].y;
		
		var rect = this.rects[this.postionIndex];
		var otherRect = other.rects[other.postionIndex];
		
		var absOffsetX = Math.abs(offsetX);
		var absOffsetY = Math.abs(offsetY);
		//外接矩形相离，不相交
		if(offsetX < 0)
		{
			if(absOffsetX > rect.w)
			{
				return false;
			}
		}
		else
		{
			if(absOffsetX > otherRect.w)
			{
				return false;
			}
		}
		
		if(offsetY <0)
		{
			if(absOffsetY > rect.h)
			{
				return false;
			}
		}
		else
		{
			if(absOffsetY > otherRect.h)
			{
				return false;
			}
		}
		
		return true;
	},
		
	CLASS_NAME:"Geo.Util.GeoAvoidObject"
});/**
 * Class: Geo.Util.GeoPreAvoidContainer
 * 先占位原则避让算法。
 * 
 */
Geo.Util.GeoPreAvoidContainer = Geo.Class({
    /**
     * APIProperty: array
     * {Array} 避让数据。
     */
	array: [],
	
	/**
	 * Constructor: Geo.Util.Text.GeoPreAvoidContainer
	 * Geo.Util.Text.GeoPreAvoidContainer构造函数。
	 */
	initialize: function(){
		
	},
	
	/**
     * APIMethod: append
     * 往避让容器中加入标注对象，经过避让算法后，如果避让成功，则增加到避让容器中，否则不加入 。
     *
     * Parameters:
     * avoid - {Object}  标注对象。
     *
     * Returns:
     * ｛Boolean｝
     */
	append:function(avoid){
		var flag = true;
		//循环标注的8个位置
		for(var i = 0;i < avoid.positions.length;i++)
		{
			flag = true;
			//给标注设置避让位置的索引号
			avoid.postionIndex = i;
			for ( var j = 0; j <this.array.length ; j++ )
			{
				//如果和容器中任意一个标注对象相交
				if ( avoid.isIntersect(this.array[j]) )
				{
					flag=false;
					break;
				}
			}
			//如果当前标注位置的标注对象与容器中任何一个标注对象都不相交，则加入到避让容器中
			if(flag)
			{
				this.array.push(avoid);
				return true;
			}
		}
		return false;
	},
	
	/**
     * APIMethod: getGeoAvoidObjects
     * 获取容器中的对象 。
     *
     * Returns:
     * ｛Array｝
     */
	getGeoAvoidObjects:function(){
		return this.array;
	},
	
	/**
     * APIMethod: getGeoAvoidObjects
     * 获取容器中的对象 。
     *
     * Returns:
     * ｛Array｝
     */
	clean:function(){
		this.array = new Array();
	},
	
	CLASS_NAME:"Geo.Util.GeoPreAvoidContainer"
});/**
 * Class: Geo.View2D.Map
 * 地图对象类，继承自Geo.Map类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Map>
 */
Geo.View2D.Map = Geo.Class(OpenLayers.Map, {

    /**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图的金字塔方案对象，默认值为Geo.Pyramid.DEFAULT_PYRAMID常量指定的360度金字塔方案。
     */
    pyramid: null,
    
    /**
     * APIProperty: allOverlays
     * {Boolean} 视图中所有图层是否都为覆盖图层，默认为false，也必须为false。
     */
    allOverlays: false,
    
    /**
     * APIProperty: layerGroup
     * {<Geo.LayerGroup>} 地图中加载的图层组对象的引用。
     */
    layerGroup: null,
	
	/**
     * APIProperty: EVENT_TYPES
     * {Array} 事件类型。
     */
    EVENT_TYPES: ["unloadLayerGroup", "loadlayergroup"],
    
    /**
     * APIProperty: overLayers
     * {Array} 所有的覆盖图层。
     */
    overLayers: null,
	
    /**
     * APIProperty: enableAnimateZoomer
     * {Boolean} 设置是否开启平滑缩放的效果。也能设置为一个对象。
     * 如果设置为一个对象，该对象被传递至{<Geo.AnimateZoomer>}的构造函数。
     * 默认为false
     */
    enableAnimateZoomer: false,
	
    /**
     * APIProperty: animateZoomer
     * {<Geo.AnimateZoomer>} 地图的图层平滑缩放效果对象。
     */
	animateZoomer: null,
    
    /**
     * Constructor: Geo.View2D.Map
     * Geo.View2D.Map构造函数。
     * 
     * Parameters:
     * div - {String} 地图对象将被渲染到哪个div 元素中。
     * options - {Object} 地图对象相关选项设置。
     */
    initialize: function(div, options){
		this.EVENT_TYPES =
            Geo.View2D.Map.prototype.EVENT_TYPES.concat(
            OpenLayers.Map.prototype.EVENT_TYPES
        );
        this.overLayers = [];
		options = options || {};
		if (options.controls == null) {
            this.controls = [ new Geo.View2D.Control.Navigation(),
                              new Geo.View2D.Control.PanZoomBar(),
                              new Geo.View2D.Control.ArgParser(),
							  new Geo.View2D.Control.MagnifyingGlass()
                            ];
        }else {
            this.controls = [];
        }
		
        OpenLayers.Map.prototype.initialize.apply(this, arguments);
		
		//视图中所有图层必须为为覆盖图层。
		this.allOverlays = false;
        this.pyramid = this.pyramid ? this.pyramid : new Geo.Pyramid();
        this.setPyramid(this.pyramid);
		
		//是否开启平滑缩放效果。 
		var config = {layerLoaded: true};
        if(typeof this.enableAnimateZoomer === "object") {
            config = OpenLayers.Util.extend(config, this.enableAnimateZoomer);
        }
        this.animateZoomer = this.enableAnimateZoomer ? new Geo.AnimateZoomer(this, config) : null;
    },
    
     /**
	 * APIMethod: addLayer
	 * 添加图层。一般情况下推荐使用addOverLayer方法，即将单个图层作为覆盖层添加。
	 *
	 * Parameters: 
	 * layer - {<Geo.View2D.Layer>} 二维视图图层对象。
	 */	
    
    //此方法将强行将添加图层isBaseLayer属性改为false
    //_notResetLayers为不公开参数，用于图层组加载时不更新基础层相关参数与重排列置顶层，解决图层组切换效率与跳级问题。
    //默认值为false，即让用户添加覆盖图层时会更新基础层相关参数与重排列置顶层。
    addLayer: function(layer,_notResetLayers){
        
        //强行将基础图层属性改为false
        layer.isBaseLayer = false;
        OpenLayers.Map.prototype.addLayer.apply(this, arguments);
        
        if(!_notResetLayers){
            this.updateBaseLayer();
            this.resetTopLayer();
        }
    },

    /**
	 * APIMethod: addOverLayer
	 * 将指定图层作为覆盖层添加。与addLayer方法不同的是，该图层的引用除了保存到地图对象的layers数组中，还将保存到overLayers数组。
	 * 覆盖层在基础图层组切换时，叠加顺序不受基础图层加载、卸载的影响，始终保持在所有基础图层的上方。
	 *
	 * Parameters: 
	 * layer - {<Geo.View2D.Layer>} 二维视图图层对象。
	 */		
    addOverLayer: function(layer){
        this.addLayer(layer);
        this.overLayers.push(layer);
    },
    
    removeLayer: function(layer){
        
        //移除在覆盖图层数组中的引用
        OpenLayers.Util.removeItem(this.overLayers, layer);
        OpenLayers.Map.prototype.removeLayer.apply(this, arguments);
    },
        
	/** 
     * APIMethod: raiseLayer
     * 调整图层顺序。
     *
     * Paremeters:
     * layer - {<Geo.View2D.Layer>} 图层对象的引用。
     * delta - {int} 图层调整的偏移量,当指定增量值为正时图层上移，当指定增量值为负时图层下移。
     */
	raiseLayer : function(layer, delta) {
		//要移动图层的当前位置
		var currentIndex = this.getLayerIndex(layer);
		//delta表示移动几位
	    var tempDelta = Math.abs(delta);
		if(delta > 0) {
			for (var i = currentIndex, len=this.layers.length; i<len; i++) {
				//若起大于0
				if(tempDelta == 0 || len <= i+1) {
					break;
				}
				if(!this.layers[i+1].displayInLayerSwitcher) {
					delta ++;
				}else {
					tempDelta--;
				}
        		
        	}
		}else if(delta < 0) {
			for (var i = currentIndex, len=this.layers.length;i >= 0; i--) {
        		if(tempDelta == 0 || i - 1 < 0) {
					break;
				}
				if(!this.layers[i-1].displayInLayerSwitcher) {
					delta = delta - 1;
				}else {
					tempDelta--;
				}
        	}
		}
		OpenLayers.Map.prototype.raiseLayer.apply(this, arguments);
	},

	
    /**
	 * APIMethod: resetTopLayer
	 * 将置顶图层重新排列。
	 */	
    resetTopLayer: function(){
        var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            if (layer.isOnTop && !layer.isBaseLayer) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
    },
	
	/**
	 * APIMethod: resetOverLayer
	 * 将覆盖图层重新排列。
	 */	
	resetOverLayer:function(){
		var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            
            //如果不是覆盖图层则视为底图图层将之移到最底层
            if (OpenLayers.Util.indexOf(this.overLayers,layer) != -1) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
	},
    
    /**
	 * APIMethod: setPyramid
	 * 设置金字塔,如果无参数默认为360度金字塔。
	 *
	 * Parameters: 
	 * pyramid - {<Geo.Pyramid>} 金字塔定义。
	 */	
    setPyramid: function(pyramid){
        if (!pyramid) {
            pyramid = new Geo.Pyramid();
        }
        this.pyramid = pyramid;
		this.numZoomLevels = this.pyramid.getNumZoomLevels();
        this.maxExtent = this.pyramid.maxExtent.clone();
		if(this.pyramid.resolutions && typeof this.pyramid.resolutions == 'object' && this.pyramid.resolutions.constructor == Array) {
			var resolutions = this.pyramid.resolutions;
			this.updateBaseLayer({
	            resolutions: resolutions,
	            maxExtent: this.maxExtent
	        });
		}else {
			this.maxResolution = this.pyramid.getMaxResolution();
        	this.minResolution = this.pyramid.getMinResolution();
			this.updateBaseLayer({
	            maxResolution: this.maxResolution,
	            minResolution: this.minResolution,
	            maxExtent: this.maxExtent
	        });
		}
    },
	
   /** 
    * APIMethod: removePopup
    * 移除浮云框
    * Parameters:
    * popup - {<Geo.View2D.Popup>}
    */
    removePopup: function(popup) {
        Geo.Util.removeItem(this.popups, popup);
        if (popup.div) {
            try { this.layerContainerDiv.removeChild(popup.div); }
            catch (e) { } // Popups sometimes apparently get disconnected
                      // from the layerContainerDiv, and cause complaints.
        }
		if(popup.calculateShadowLocation) {
			this.events.unregister("zoomend", popup,popup.calculateShadowLocation);
		}
		if(popup.shadowDiv) {
			 try {this.layerContainerDiv.removeChild(popup.shadowDiv); }
            catch (e) { }
		}
        popup.map = null;
    },
    
    /**
	 * APIMethod: updateBaseLayer
	 * 更新基础图层相关选项,如果无指定选项设置，则根据地图中所有图层相关设置更新基础图层选项。
	 *
	 * Parameters: 
	 * options - - {Object} 相关选项设置。
	 */	
    updateBaseLayer: function(options){
        var defOptions = {
            displayInLayerSwitcher: false,
            isBaseLayer: true
        }
        var blOptions = {};
        if (!options) {
			
			var resolutions = this.getResolutions();
			//优先使用数组，如果没有则使用最大最小分辨率
			if(OpenLayers.Util.isArray(resolutions)) {
				blOptions = {
	                resolutions: resolutions,
	                maxExtent: this.getLayersMaxExtent()
	            };
			}else {
				blOptions = {
	                maxResolution: this.getLayersMaxResolution(),
	                minResolution: this.getLayersMinResolution(),
	                maxExtent: this.getLayersMaxExtent()
	            };
			}
            
        }
        else {
            OpenLayers.Util.extend(blOptions, options);
        }
        OpenLayers.Util.extend(blOptions, defOptions);
        var bl = new OpenLayers.Layer("GeoGlobeBaseLayer", blOptions);
        
        if (this.baseLayer) {
            this.removeLayer(this.baseLayer);
        }
        OpenLayers.Map.prototype.addLayer.apply(this, [bl]);
    },
	
	getResolutions: function() {
		var resolutions = this.resolutions || this.pyramid.resolutions;
		return resolutions;
	},
    
    /**
	 * APIMethod: getLayersMaxResolution
	 * 获取地图中所有图层的最大分辨率，如果所有图层均无分辨率设置，则以地图金字塔最大分辨率为准。
	 * 
	 * Returns:
     * {Float} 分辨率。
	 */	
    getLayersMaxResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
			var layerOptions  = layers[i].getOptions();
			var layerMaxRes = layerOptions.maxResolution;
            if (layers[i].isBaseLayer || !layerMaxRes) {
				continue;
			}                
            res = res ? Math.max(res, layerMaxRes) : layerMaxRes;
        }
        var pyramidMaxRes = this.pyramid.getMaxResolution();
        res = (res <= 0 || res > pyramidMaxRes) ? pyramidMaxRes : res;
        return res;
    },
    
    /**
	 * APIMethod: getLayersMinResolution
	 * 获取地图中所有图层的最小分辨率，如果所有图层均无分辨率设置，则以地图金字塔最小分辨率为准。
	 * 
	 * Returns:
     * {Float} 分辨率。
	 */	
    getLayersMinResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
			var layerOptions  = layers[i].getOptions();
			var layerMinRes = layerOptions.minResolution;
            if(layers[i].isBaseLayer || !layerMinRes){
				continue;
			}
            res = res ? Math.min(res, layerMinRes) : layerMinRes;
        }
        var pyramidMinRes = this.pyramid.getMinResolution();
        res = (res <= 0 || res < pyramidMinRes) ? pyramidMinRes : res;
        return res;
    },
    
     /**
	 * APIMethod: getLayersMaxExtent
	 * 取所有图层的最大范围，如果所有图层均无最大范围，则以金字塔的最大范围为准。
	 * 
	 *  Returns:
     *  {<Geo.Bounds>}图层范围。
	 */	
    getLayersMaxExtent: function(){
        var extent = null;
        var layers = this.layers;
        for (var i = 0; i < layers.length; i++) {
            if (layers[i].isBaseLayer || !layers[i].maxExtent) 
                continue;
            if (extent) {
                extent.extend(layers[i].maxExtent);
            }
            else {
                extent = layers[i].maxExtent.clone();
            }
        }
        var pyramidMaxExtent = this.pyramid.maxExtent.clone();
        extent = extent ? extent : pyramidMaxExtent;
        return extent;
    },
	
    /**
     * APIMethod: loadLayerGroup
     * 加载指定方案到地图对象。
     *
     * Parameters: 
	 * layerGroup - {<Geo.LayerGroup>} 图层组，在该图层组中，序号值最大的图层在顶层，序号值最小的图层在底层。
     * 
     * Returns:
     * {Boolean} 装载方案是否成功。
     */
    loadLayerGroup: function(layerGroup){
        if (this.layerGroup == layerGroup) {
            var msg = "不能重复加载图层组到地图中！";
            OpenLayers.Console.warn(msg);
            return false;
        }
        this.unloadLayerGroup();
        layerGroup.setMap(this);
        this.layerGroup = layerGroup;
		
        this.updateBaseLayer();
		this.resetOverLayer();
        this.resetTopLayer();
		this.events.triggerEvent("loadlayergroup", {
            layerGroup: layerGroup,
			map : this
        });
    },
    
    /**
     * APIMethod: unloadLayerGroup
     * 卸载图层组。
     */
    unloadLayerGroup: function(){
		var layerGroup = this.layerGroup;
        if (!layerGroup) {
			return false;
		}
		layerGroup.removeMap();
        this.layerGroup = null;

    },
	
    CLASS_NAME: "Geo.View2D.Map"
});/**
 * Class: Geo.View2D.Tile.TileFeature
 * Geo.View2D.Tile.TileFeature的实例是存放在图层中的矢量块。
 *
 * Inherits from:
 *  - <Geo.View2D.Tile>
 */
Geo.View2D.Tile.TileFeature = Geo.Class(Geo.View2D.Tile, {
	
    /** 
     * Constructor: Geo.View2D.Tile.TileFeature
     * 创建Geo.View2D.Tile.TileFeature对象实例。
     * 
     * Parameters:
     * layer - {<Geo.View2D.Layer.HotareaWMTS>} 热区WMTS图层。
     * position - {<Geo.Pixel>} 位置。
     * bounds - {<Geo.Bounds>} 范围。
     * url - {<String>} 请求路径，一般为null。
     * size - {<Geo.Size>} 尺寸大小。
     * options - {Object} 参数选项。
     */   
    initialize: function(layer, position, bounds, url, size, options){
        Geo.View2D.Tile.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * Method: draw
     * Check that a tile should be drawn, and draw it.
     *
     * Returns:
     * {Boolean} Always returns true.
     */
    draw: function(){
        if (this.layer != this.layer.map.baseLayer && this.layer.reproject) {
            this.bounds = this.getBoundsFromBaseLayer(this.position);
        }
        var drawTile = Geo.View2D.Tile.prototype.draw.apply(this, arguments);
        
        return this.renderTile();
    },
    
    /** 
     * Method: renderTile
     * Show the tile.  To be implemented by subclasses.
     */
    renderTile: function(){
		
        this.url = this.layer.getURL(this.bounds);
        if (this.url == "") {
            return;
        }
        //alert(this.url);
        var isExist = false;
        for (var i = 0; i < this.layer.urls.length; i++) {
            if (this.layer.urls[i] == this.url) {
                isExist = true;
				
            }
        }
        
        if (!isExist) {
            this.layer.urls.push(this.url);
            
            var url = this.url;
            var params = {};
            var xhr = OpenLayers.Request.GET({
                url: url,
                params: params,
                scope: this,
                async: true, // true表示异步，false表示同步。
                success: function(result){
                    var geojsonStr = result.responseText;
                    if (geojsonStr == "" || geojsonStr == null) {
                        return;
                    }
                    //this.layer.vectorLayer.destroyFeatures();
                    if (this.layer && this.layer.vectorLayer) {
                        var geojsonFormat = new OpenLayers.Format.GeoJSON();
                        var features = geojsonFormat.read(geojsonStr);
                        var style = {
                            fillColor: "#ee9900",
                            fillOpacity: 0,
                            strokeColor: "#ee9900",//"#d9534f",//"#66FF66",
                            strokeOpacity: 0,
                            cursor: "pointer"
                        }
						var pointFeatures = [];
                        for (var i = 0; i < features.length; i++) {
                            features[i].style = style;
							
							features[i].attributes.type = features[i].data.type = "polygon";
							var displayname = features[i].attributes.displayname;
							var descriptionname = features[i].attributes.descriptionname;
							
							//创建点要素
							var lon = features[i].attributes.x;
							var lat = features[i].attributes.y;
		                    var p = new Geo.Geometry.Point(lon, lat);
							var picsymid = features[i].attributes.picsymid;
                            var f = new Geo.Feature.Vector(p, {
                                type: "point",
								relatedid: features[i].id,
                                picsymid: picsymid,
								displayname: displayname,
								descriptionname: descriptionname,
                                overPicUrl: this.layer.getPicURL(picsymid, true),
                                outPicUrl: this.layer.getPicURL(picsymid, false)
                            });
							
							//http://192.168.42.159:9010/MAP501/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetIcon&LAYER=kloo_hotarea&PICID=0&ISANTI=true
							//var imgPath = "http://" +  Cfg.host  +  "/" + Cfg.projectName + "/JsCodeDemo/js/images/common/" + i + ".png";
							features[i].attributes.relatedid = features[i].data.relatedid = f.id;
							
							
							var picUrl = this.layer.getPicURL(picsymid, false);
							var img = new Image();
							img.src = picUrl;
							var gw = img.width;
							var gh = img.height;
		                    f.style = {
		                        externalGraphic: picUrl,
				                graphicWidth: gw,
				                graphicHeight: gh,
				                graphicXOffset: parseInt(-gw/2),
				                graphicYOffset: parseInt(-gh/2),
								cursor: "pointer"
		                    };
		                    pointFeatures.push(f);
                        }
                        
                        this.layer.vectorLayer.addFeatures(features);
                        this.layer.vectorLayer.addFeatures(pointFeatures);
                    }
                },
                failure: function(result){
					//OpenLayers.Util.removeItem(this.layer.urls, this.url);
                    //alert("failure");
                }
            });
        }
        
    },
    
    moveTo: function(bounds, position, redraw){
        if (redraw == null) {
            redraw = true;
        }
        
        this.bounds = bounds.clone();
        this.position = position.clone();
        if (redraw) {
            this.draw();
        }
    },
	
    CLASS_NAME: "Geo.View2D.Tile.TileFeature"
});

/**
 * Class: Geo.View2D.Layer.GlobeTile
 * GeoGlobe瓦片图层类，继承自Geo.View2D.Layer.Grid类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Grid>
 */
Geo.View2D.Layer.GlobeTile = Geo.Class(Geo.View2D.Layer.Grid,{

	/**
	 * APIProperty: alwaysInRange
	 * {Boolean} 强制在任意分辨率下显示图层，默认false。
	 */
	alwaysInRange: false,
	
	/**
     * APIProperty: isBaseLayer
     * {Boolean} 是否基础层，默认为false。
     */
	isBaseLayer:false,
	
	/**
     * APIProperty: topLevel
     * {Integer} 图层顶层级别。
     */
	topLevel: null,
	
	/**
     * APIProperty: bottomLevel
     * {Integer} 图层底层级别。
     */
	bottomLevel: null,
	
	/**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	pyramid : null,
	
	/**
     * APIProperty: accessUrl
     * {String} 服务访问地址。
     */
	accessUrl : null,
	
	/**
     * APIProperty: mirrorUrl
     * {Array} 服务镜像地址。可以为一个服务设置多个地址，解决浏览器图片链接数限制问题。
     */
	mirrorUrl : null,
	
	/**
     * APIProperty: serviceName
     * {String} 服务访问名称。
     */
	serviceName : null,
	
	/**
     * APIProperty: verstionTime
     * {String} 时间版本。
     */
	verstionTime: "9999-01-01 00:00:00",
	
	/**
     * APIProperty: cacheExpireTime
     * {String} 缓存过期时间。
     */
	cacheExpireTime : "now",

	/**
     * APIProperty: buffer
     * {String} 瓦片缓存大小。
     */
	buffer:0,
	
	/**
     * APIProperty: transitionEffect
     * {String} 平滑缩放效果。
     */
	transitionEffect: null,
	
	/**
     * Constructor: Geo.View2D.Layer.GlobeTile
     * 创建GeoGlobe瓦片图层对象实例。
     *
     * Parameters:
     * name - {String} GeoGlobe瓦片图层名称。
     * url - {String} 瓦片服务地址。
     * options - {Object} 对象构造参数。
     * 
     * 示例:
     * (code)
     * new Geo.View2D.Layer.GlobeTile("天地图矢量注记", "http://tile0.tianditu.com/services/AB0512_Anno", {
     *      topLevel: 2,
     *      bottomLevel: 12,
     *      maxExtent: new Geo.Bounds(-180, -90, 180, 90)
     * })
     * (end)
     */
	initialize : function(name, url, options){
		
		this.name = name;
		this.url = url;
		this.convertUrl(this.url);
		
		//初始化图层的金字塔和顶层底层级别，如果无金字塔指定，则默认为360度金字塔
		if(!options){
			options = {};
		};
		options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		options.topLevel = options.topLevel ? options.topLevel : options.pyramid.topLevelIndex;
		options.bottomLevel = options.bottomLevel ? options.bottomLevel : options.pyramid.bottomLevelIndex;		
		
		//初始化图层的最大最小分辨率
		var maxRes = options.pyramid.getMaxResolution();
		options.maxResolution = options.pyramid.getResolutionForLevel(options.topLevel);
		options.minResolution = options.pyramid.getResolutionForLevel(options.bottomLevel);
		
		options.tileSize = options.pyramid.tileSize;
		
		var para = null;		
		var newArguments = [name, url, para, options];
		Geo.View2D.Layer.Grid.prototype.initialize.apply(this, newArguments);
		
	},
	
	/**
     * APIMethod: convertUrl
     * 将服务地址转换成实际瓦片图片访问地址。
	 * 
	 * Paramters:
	 * url - {String} 服务地址。
     */
	convertUrl: function(url){
		var tmpUrl = url.split("/services/");
		if (tmpUrl[0] && tmpUrl[1]) {
			this.accessUrl = tmpUrl[0] + "/DataServer";
			this.serviceName = tmpUrl[1];
		} else {
			OpenLayers.Console.error("解析GeoGlobe 2.0.0服务地址错误:" + url);
			return;
		}
	},
	
	/**
     * APIMethod: addTile
     * 添加瓦片。
     * 
     * Paramters:
	 * bounds - {<Geo.Bounds>}
	 * position - {<Geo.Pixel>}
	 * 
	 * Returns:
     * {<Geo.View2D.Tile.Image>} 瓦片图片。
     */
	addTile: function(bounds, position) {
		return new Geo.View2D.Tile.Image(this, position, bounds,
                                             null, this.tileSize);
    },
 
	/**
     * APIMethod: setVerstionTime
     * 设置历史版本,设置版本后会重新绘制本图层。
     * 
     * Paramters:
	 * verstion - {String} 历史版本号,格式为"2010-06-23 18:48:23"。
     */
    setVerstionTime: function(verstion){
    	if(verstion){
    		this.verstionTime = verstion;
    		this.redraw();
    	}
    },
	
	/**
     * APIMethod: getURL
     * 获取瓦片图片地址。
     * 
     * Paramters:
	 * bounds - {<Geo.Bounds>}
	 * 
	 * Returns:
     * {String} 瓦片图片地址。
     */
	getURL: function(bounds) {
	
		var blankUrl = OpenLayers.Util.getImagesLocation() + "blank.gif";		
		bounds = this.adjustBounds(bounds);	
		var pyramidMaxResolution = this.pyramid.getMaxResolution();
		
		var deg,level,x,y;
		level = this.pyramid.getLevelForResolution(this.map.getResolution());
        deg = this.pyramid.getTopTileSize().w / Math.pow(2,level);
        
		
		//判断原点
		//宽度为正，说明X轴向从左到右
		if(this.pyramid.topTileFromX < this.pyramid.topTileToX){
			x = Math.round((bounds.left - this.pyramid.topTileFromX)/deg);
		} else {
			x = Math.round((this.pyramid.topTileFromX - bounds.right)/deg);
		}
		//高度为正，说明Y轴向从下到上
		if (this.pyramid.topTileFromY < this.pyramid.topTileToY){
			y = Math.round((bounds.bottom - this.pyramid.topTileFromY)/deg);
		} else{
			y = Math.round((this.pyramid.topTileFromY - bounds.top)/deg);
		}	
		if (x < 0 || y < 0){
			  return OpenLayers.Util.getImagesLocation() + "blank.gif";
		}
		
		// 加入服务镜像地址处理，如果图层mirrorUrl不为空，则调用HTTPRequest父类的selectUrl方法
		// 从镜像地址数组取一条url
		var accessUrl = "";
		var urlPara = {};
		if(this.mirrorUrl == null){
			accessUrl = this.accessUrl;
			urlPara = {
				"T": this.serviceName,
				"X": x,
				"Y": y,
				"L": level,
				"INDATE": this.verstionTime
			}			
		} else {			
			accessUrl = this.selectUrl(x, this.mirrorUrl); 
			var tmpUrl = accessUrl.split("/services/");
			if (tmpUrl[0] && tmpUrl[1]) {
				accessUrl = tmpUrl[0] + "/DataServer";				
				urlPara = {
					"T": tmpUrl[1],
					"X": x,
					"Y": y,
					"L": level,
					"INDATE": this.verstionTime
				}
			} 
		}
		accessUrl = this.getFullRequestString(urlPara, accessUrl);
		//document.getElementById("output").innerHTML += accessUrl + " , " + bounds.toBBOX() + " " + this.calculateInRange() +" <br>";
		return accessUrl;
		
	},
	
	/**
     * APIMethod: selectUrl
     * 镜像地址分布方法,行号(x)与镜像地址数量取余数。
     * 
     * Parameters:
     * factor - {Integer}
     * urls - {Array(String)}
     * 
     * Returns:
     * {String} 选择地址。
     */
	selectUrl:function(factor, urls){
		var len = urls.length;
		var remainder = factor % len;
		return urls[remainder];
		
	},
	
	/**
     * APIMethod: getDataExtent
     * 获取获取图层范围。
     * 
     * Returns:
     * {<Geo.Bounds>}图层范围。
     */
	getDataExtent: function () {
        if (this.maxExtent){
			return this.maxExtent.clone();
		}
    },
	
	/**
     * APIMethod: clone
     * 复制图层对象。
     * 
     * Returns:
     * {<Geo.View2D.Layer.GlobeTile>} 被克隆的图层对象。
     */
    clone : function(obj){
		if (obj == null) {
			obj = new Geo.View2D.Layer.GlobeTile(this.name,
                                       this.url,
                                       this.options);
		}
	 	obj = Geo.View2D.Layer.Grid.prototype.clone.apply(this, [obj]);
	 	return obj;
	},	
	
	CLASS_NAME: "Geo.View2D.Layer.GlobeTile"
});

/**
 * Class: Geo.View2D.Layer.CWMS
 * CWMS图层类，继承自Geo.View2D.Layer.Grid类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Grid>
 */
Geo.View2D.Layer.CWMS = Geo.Class(Geo.View2D.Layer.Grid,{
	
	/**
	 * APIProperty: layerId
	 * {String} 图层的唯一编号。
	 */
	layerId : null,
	
	/**
	 * APIProperty: mapStyleId
	 * {String}当前请求图层样式的唯一编号。
	 */
	mapStyleId : null,
	
	/**
	 * APIProperty: srid
	 * {String}图层的参考坐标系id。
	 * 
	 */
	srid : null,
	
	/**
	 * APIProperty: sourceDate
	 * {Date}数据的最后更新日期。
	 */
	sourceDate : null,
	
	/**
	 * APIProperty: formatSuffix
	 * {String}输出图片格式。
	 */
	formatSuffix : null,
	
	/**
     * APIProperty: buffer
     * {String} 瓦片缓存大小。
     */
	buffer : 0,
	
	/**
     * Constructor: Geo.Service.CWMS
     * Geo.Service.CWMS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *    layerId - {String}图层Id 必填。
     *    mapstyleId - {String}当前请求图层样式的唯一编号 必填。
     *    srid -{String} 图层的参考坐标系 必填。
     *    sourceDate - {Date}据的最后更新日期 必填。
     *    formatSuffix - {String}输出图片格式 可选（默认值是png）。
     *    scales | resolutions - {Array} 比例尺或级别 必填。
     *    maxExtent - {<Geo.Bounds>} 图层的最大范围 必填。
     *  
     *  例子:
     *  (code)
     *  var cwmsLayer1 = new Geo.View2D.Layer.CWMS("cwms1","http://10.4.6.52:7001/CWMS1",{
	 *				layerId:"GeoGlobeMap_1",
	 *				mapStyleId:"GISP:1",
	 *				srid:"EPSG:4326",
	 *				sourceDate:myDate,
	 *				formatSuffix:"png",
	 *				scales:[4622333.678977588,2311166.839488794,1155583.419744397,577791.7098721985,288895.85493609926
	 *				,144447.92746804963,72223.96373402482,36111.98186701241],
	 *				maxExtent :Geo.Bounds.fromString("70.3125,5.625,146.25,56.25")
	 *			
	 *		});
     *  (end)
     */
	initialize: function(name, url, options){
		this.mapStyleId = options.mapStyleId;
		this.srid = options.srid;
		this.sourceDate = options.sourceDate;
		this.formatSuffix = options.formatSuffix || "png" ;
		var para = null;		
		var newArguments = [name, url, para, options];
		Geo.View2D.Layer.Grid.prototype.initialize.apply(this, newArguments);
	},
	
	/**
     * Method: addTile
     * addTile creates a tile, initializes it, and adds it to the layer div. 
     * 
     * Parameters:
     * bounds - {<Geo.Bounds>}
     * position - {<Geo.Pixel>}
     * 
     * Returns:
     * {<Geo.View2D.Tile.Image>} The added Geo.View2D.Tile.Image
     */
    addTile: function(bounds,position) {
        return new Geo.View2D.Tile.Image(this, position, bounds, 
                                         null, this.tileSize);
    },
	
	/**
     * APIMethod: getURL
     * 获取瓦片图片地址。
     * 
     * Paramters:
	 * bounds - {<Geo.Bounds>} 瓦片的范围。
	 * 
	 * Returns:
     * {String} 瓦片图片地址。
     */
	getURL: function(bounds) {
		bounds = this.adjustBounds(bounds);
        var res = this.map.getResolution();
		var fx = (bounds.left - this.map.maxExtent.left) / (res * this.tileSize.w);
		var fy = (this.map.maxExtent.top - bounds.top) / (res * this.tileSize.h);

        var col = Math.floor(fx);
        var row = Math.floor(fy);
		var cwms = new Geo.Service.CWMS(
			this.name,
			this.url
		);
		var currentRes = this.map.getResolution();
		var level = this.map.pyramid.getLevelForResolution(currentRes);
		
		var url = cwms.getMap({
			layerId : this.layerId,
			mapStyleId : this.mapStyleId,
			srid : this.srid,
			sourceDate : this.sourceDate,
			level : level,
			col : col,
			row : row,
			formatSuffix : this.formatSuffix
		});
		
		return url;
	},	
	
	CLASS_NAME: "Geo.View2D.Layer.CWMS"
});/**
 * Class: Geo.View2D.Layer.GeoWMTS
 * 吉奥多时相wmts类，继承自Geo.View2D.Layer.WMTS类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.WMTS>
 */
Geo.View2D.Layer.GeoWMTS = Geo.Class(Geo.View2D.Layer.WMTS, {
	
	/**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	pyramid : null,
	
	/**
     * APIProperty: time
     * {String} 时间版本。
     *  声明：time的值只能通过setVerstionTime方法才能改变。
     */
	time: "9999-01-01 00:00:00",
	
	/**
	 * APIProperty: userecent
	 * 为FALSE时只有存在指定时相的瓦片数据时，才返回瓦片数据，
	 * 否则返回提示。为TRUE时，只要存在不晚于指定时相的瓦片数据时，
	 * 返回其中最新的瓦片数据。默认为true。
	 */
	userecent: true,
	
	/**
     * Constructor: Geo.View2D.Layer.GeoWMTS
     * 创建GeoWMTS图层对象实例。
     *
     * Parameters:
     * name - {String} GeoGlobe瓦片图层名称。
     * url - {String} 瓦片服务地址。
     * options - {Object} 对象构造参数。
     * 
     * 示例:
     * (code)
     * 
     * (end)
     */
	initialize : function(options) {
		var params = {};
		if(options.params) {//支持老结构
			if(options.params.time) {
				this.time = options.params.time;
			}
			if(typeof options.params.userecent === "boolean") {
				this.userecent = options.params.userecent;
			}
		}else {//支持新结构
			if(options.time) {
				params.time = options.time;
				this.time = options.time;
			}
			if(typeof options.userecent === "boolean") {
				params.userecent = options.userecent;
				this.userecent = options.userecent;
			}
			options.params = params;
		}
		options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		Geo.View2D.Layer.WMTS.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: setVerstionTime
     * 设置历史版本,设置版本后会重新绘制本图层。
     * 
     * Paramters:
	 * verstion - {<String>} 历史版本号,格式为"2010-06-23 18:48:23"。
     */
    setVerstionTime: function(verstion){
    	if(verstion){
    		this.params.TIME = verstion;
			this.time = verstion;
    		this.redraw();
    	}
    },
	
	/**
     * APIMethod: setParams
     *  设置多时相相关参数。
     * 
     * Paramters:
	 *  params:
	 *   time - {String}时间版本。
	 *   userecent - {Boolean} 
	 *   为FALSE时只有存在指定时相的瓦片数据时，才返回瓦片数据，
	 *   否则返回提示。为TRUE时，只要存在不晚于指定时相的瓦片数据时，
	 *   返回其中最新的瓦片数据。默认为true。
     */
	setParams: function(params) {
		if(params.time) {
			this.params.TIME = params.time;
			this.time = params.time;
			var userecent = typeof params.userecent == "boolean" ? params.userecent : true;
			this.params.USERECENT = userecent;
			this.userecent = userecent;
			this.redraw();
		}
	},
	
    /** 
     * Method: getTileInfo
     * Get tile information for a given location at the current map resolution.
     *
     * Parameters:
     * loc - {<OpenLayers.LonLat} A location in map coordinates.
     *
     * Returns:
     * {Object} An object with "col", "row", "i", and "j" properties.  The col
     *     and row values are zero based tile indexes from the top left.  The
     *     i and j values are the number of pixels to the left and top 
     *     (respectively) of the given location within the target tile.
     */
    getTileInfo: function(lonlat) {
		var level = this.pyramid.getLevelForResolution(this.map.getResolution());
		var lon = lonlat.lon;
		var lat = lonlat.lat;
		var size = this.pyramid.getTopTileSize()
		var degree = size.w / Math.pow(2,level);
		
		//金字塔宽高
		var width = this.pyramid.maxExtent.getWidth();
		var height = this.pyramid.maxExtent.getHeight();
		
		//总行列数
		var totalCol = Math.round(width / degree);
		var totalRow = Math.round(height / degree);
		
		//计算列索引号
		var isStartLeft = (this.pyramid.topTileFromX < this.pyramid.topTileToX) ? true : false;
		var colIndex = Math.ceil(Math.abs(lon - this.pyramid.topTileFromX)/degree) - 1;
		if(!isStartLeft){
			colIndex = totalCol - colIndex;
		}
		
		var isStartTop = (this.pyramid.topTileFromY > this.pyramid.topTileToY) ? true : false;
		var rowIndex = Math.ceil(Math.abs(lat - this.pyramid.topTileFromY)/degree) - 1;
		if (!isStartTop){
			rowIndex = totalRow - rowIndex;
		}
		
		return {
			col: colIndex,
			row: rowIndex
		}
    },
	
	/**
     * APIMethod: clone
     * 复制图层对象。
     * 
     * Returns:
     * {<Geo.View2D.Layer.GlobeTile>} 被克隆的图层对象。
     */
    clone : function(obj){
		if (obj == null) {
			obj = new Geo.View2D.Layer.GeoWMTS(this.options);
		}
	 	obj = Geo.View2D.Layer.WMTS.prototype.clone.apply(this, [obj]);
	 	return obj;
	},	
	
	CLASS_NAME: "Geo.View2D.Layer.GeoWMTS"
});/**
 * Class: Geo.View2D.Layer.ArcGISTileLayer
 *	 ArcGIS瓦片图层是用于加载ArcGIS地图瓦片服务的图层。
 *	 本图层支持等比分辨率的地图瓦片服务或非等比分辨率的地图瓦片服务的加载。
 */ 
Geo.View2D.Layer.ArcGISTileLayer = Geo.Class(Geo.View2D.Layer.XYZ, {  

    /**
     * APIProperty: url
     * {String} ArcGIS地图瓦片服务地址
     */
    url: null,
	
	/**
     * Property: useArcGISServer
     * {String | Array} 
     */
	useArcGISServer:true,
    
   /**
    * Constructor: Geo.View2D.Layer.ArcGISTileLayer
    * 
    * Parameters: 
    * name - {String} 图层名称
    * url - {String} arcgis地图瓦片服务地址
    * 
    * 示例:
    * (code)
    * 	var arcgisTileLayer = new Geo.View2D.Layer.ArcGISTileLayer("arc", "http://192.168.32.64/ArcGIS/rest/services/2dmap/MapServer");
    * (end)
    */ 
    initialize: function(name, url, options) {
        OpenLayers.Layer.XYZ.prototype.initialize.apply(this, arguments);

        if (this.resolutions) {        
            this.serverResolutions = this.resolutions;
            this.maxExtent = this.getMaxExtentForResolution(this.resolutions[0]);
        }
		this.jsonp = new OpenLayers.Protocol.Script();
		this.jsonp.createRequest(url, {
            f: 'json',
            pretty: 'true'
        }, OpenLayers.Function.bind(this._loadTiles,this));
    }, 
	
	/** 
    * Method: _loadTiles
    * 访问服务能力描述信息的回调函数
    */
	_loadTiles: function(layerInfo) {
	        if (layerInfo) {
          
            var info = layerInfo;
            
            // build our extents
            var startingTileExtent = new OpenLayers.Bounds(
                info.fullExtent.xmin, 
                info.fullExtent.ymin, 
                info.fullExtent.xmax, 
                info.fullExtent.ymax  
            );

           
            this.projection = 'EPSG:' + info.spatialReference.wkid;
            this.sphericalMercator = (info.spatialReference.wkid == 102100);
            
            // convert esri units into openlayers units (basic feet or meters only)
            this.units = (info.units == "esriFeet") ? 'dd' : 'm';

            // optional extended section based on whether or not the server returned
            // specific tile information
            if (!!info.tileInfo) {            
                // either set the tiles based on rows/columns, or specific width/height
                this.tileSize = new OpenLayers.Size(
                    info.tileInfo.width || info.tileInfo.cols, 
                    info.tileInfo.height || info.tileInfo.rows
                );
                
                // this must be set when manually configuring this layer
                this.tileOrigin = new OpenLayers.LonLat(
                    info.tileInfo.origin.x, 
                    info.tileInfo.origin.y
                );

                var upperLeft = new OpenLayers.Geometry.Point(
                    startingTileExtent.left, 
                    startingTileExtent.top
                );
                
                var bottomRight = new OpenLayers.Geometry.Point(
                    startingTileExtent.right, 
                    startingTileExtent.bottom
                );            
                
                if (this.useScales) {
                    this.scales = [];
                } else {
                    this.resolutions = [];
                }
                
                this.lods = [];
                for(var key in info.tileInfo.lods) {
                    if (info.tileInfo.lods.hasOwnProperty(key)) {
                        var lod = info.tileInfo.lods[key];
                        if (this.useScales) {
                            this.scales.push(lod.scale);
                        } else {
                            this.resolutions.push(lod.resolution);
                        }
                    
                        var start = this.getContainingTileCoords(upperLeft, lod.resolution);
                        lod.startTileCol = start.x;
                        lod.startTileRow = start.y;
                    
                        var end = this.getContainingTileCoords(bottomRight, lod.resolution);
                        lod.endTileCol = end.x;
                        lod.endTileRow = end.y;    
                        this.lods.push(lod);
                    }
                }
				
                this.maxExtent = this.calculateMaxExtentWithLOD(this.lods[0]);

                this.serverResolutions = this.resolutions;
				
                if (this.overrideDPI && info.tileInfo.dpi) {
                    // see comment above for 'overrideDPI'
                    OpenLayers.DOTS_PER_INCH = info.tileInfo.dpi;
                }
            } 
       }
		
	},

	/** 
    * APIMethod: setMap
    * 添加图层到地图。
    */
	setMap: function() {
		OpenLayers.Layer.XYZ.prototype.setMap.apply(this, arguments);
		var that = this;
//		this.map.events.register("zoomend", this, function() {
//			
//			that.maxExtent = this.calculateMaxExtentWithLOD(that.lods[that.map.getZoom()]);
//		});
	},

   /** 
    * Method: getContainingTileCoords
    * Calculates the x/y pixel corresponding to the position of the tile
    *     that contains the given point and for the for the given resolution.
    * 
    * Parameters:
    * point - {<OpenLayers.Geometry.Point>} 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getContainingTileCoords: function(point, res) {
        return new OpenLayers.Pixel(
           Math.max(Math.floor((point.x - this.tileOrigin.lon) / (this.tileSize.w * res)),0),
           Math.max(Math.floor((this.tileOrigin.lat - point.y) / (this.tileSize.h * res)),0)
        );
    },
    
   /** 
    * Method: calculateMaxExtentWithLOD
    * Given a Level of Detail object from the server, this function
    *     calculates the actual max extent
    * 
    * Parameters: 
    * lod - {Object} a Level of Detail Object from the server capabilities object 
            representing a particular zoom level
    * 
    * Returns: 
    * {<OpenLayers.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithLOD: function(lod) {

        var numTileCols = (lod.endTileCol - lod.startTileCol) + 1;
        var numTileRows = (lod.endTileRow - lod.startTileRow) + 1;        

        var minX = this.tileOrigin.lon + (lod.startTileCol * this.tileSize.w * lod.resolution);
        var maxX = minX + (numTileCols * this.tileSize.w * lod.resolution);

        var maxY = this.tileOrigin.lat - (lod.startTileRow * this.tileSize.h * lod.resolution);
        var minY = maxY - (numTileRows * this.tileSize.h * lod.resolution);
        return new OpenLayers.Bounds(minX, minY, maxX, maxY);
   },
    
   /** 
    * Method: calculateMaxExtentWithExtent
    * 
    * Parameters: 
    * extent - {<OpenLayers.Bounds>} The 'suggested' extent for the layer
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithExtent: function(extent, res) {
        var upperLeft = new OpenLayers.Geometry.Point(extent.left, extent.top);
        var bottomRight = new OpenLayers.Geometry.Point(extent.right, extent.bottom);
        var start = this.getContainingTileCoords(upperLeft, res);
        var end = this.getContainingTileCoords(bottomRight, res);
        var lod = {
            resolution: res,
            startTileCol: start.x,
            startTileRow: start.y,
            endTileCol: end.x,
            endTileRow: end.y
        };
        return this.calculateMaxExtentWithLOD(lod);
   },
    
    /** 
    * Method: getUpperLeftTileCoord
    * 
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getUpperLeftTileCoord: function(res) {
        var upperLeft = new OpenLayers.Geometry.Point(
            this.maxExtent.left,
            this.maxExtent.top);
        return this.getContainingTileCoords(upperLeft, res);
    },

    /** 
    * Method: getLowerRightTileCoord
    *  
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Pixel>} The x/y pixel corresponding to the position
    * of the lower right tile for the given resolution.
    */
    getLowerRightTileCoord: function(res) {
        var bottomRight = new OpenLayers.Geometry.Point(
            this.maxExtent.right,
            this.maxExtent.bottom);
        return this.getContainingTileCoords(bottomRight, res);
    },
    
   /** 
    * Method: getMaxExtentForResolution
    * Since the max extent of a set of tiles can change from zoom level
    *     to zoom level, we need to be able to calculate that max extent 
    *     for a given resolution.
    *
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Bounds>} The extent for this resolution
    */ 
    getMaxExtentForResolution: function(res) {
        var start = this.getUpperLeftTileCoord(res);
        var end = this.getLowerRightTileCoord(res);

        var numTileCols = (end.x - start.x) + 1;
        var numTileRows = (end.y - start.y) + 1;

        var minX = this.tileOrigin.lon + (start.x * this.tileSize.w * res);
        var maxX = minX + (numTileCols * this.tileSize.w * res);
        
        var maxY = this.tileOrigin.lat - (start.y * this.tileSize.h * res);
        var minY = maxY - (numTileRows * this.tileSize.h * res);
        return new OpenLayers.Bounds(minX, minY, maxX, maxY);
    },
    
   /** 
    * APIMethod: clone 
    * 克隆本图层
    * 
    * Parameters: 
    * [obj] - {Object} 本图层对象的一个实例
    *  
    * Returns: 
    * {<Geo.View2D.Layer.ArcGISTileLayer>} 克隆对象
    */ 
    clone: function (obj) { 
        if (obj == null) { 
            obj = new Geo.View2D.Layer.ArcGISTileLayer(this.name, this.url, this.options);
        }
        return OpenLayers.Layer.XYZ.prototype.clone.apply(this, [obj]);
    },

    /**
     * Method: getMaxExtent
     * Get this layer's maximum extent.
     *
     * Returns:
     * {OpenLayers.Bounds}
     */
    getMaxExtent: function() {
        var resolution = this.map.getResolution();
        return this.maxExtent;// = this.getMaxExtentForResolution(resolution);
    },

    /**
     * Method: getTileOrigin
     * Determine the origin for aligning the grid of tiles.  
     *     The origin will be derived from the layer's <maxExtent> property. 
     *
     * Returns:
     * {<OpenLayers.LonLat>} The tile origin.
     */
    getTileOrigin: function() {
        var extent = this.getMaxExtent();
        return new OpenLayers.LonLat(extent.left, extent.bottom);
    },

   /**
    * Method: getURL
    * Determine the URL for a tile given the tile bounds.  This is should support
    *     urls that access tiles through an ArcGIS Server MapServer or directly through
    *     the hex folder structure using HTTP.  Just be sure to set the useArcGISServer
    *     property appropriately!  This is basically the same as 
    *     'OpenLayers.Layer.TMS.getURL',  but with the addition of hex addressing,
    *     and tile rounding.
    *
    * Parameters:
    * bounds - {<OpenLayers.Bounds>}
    *
    * Returns:
    * {String} The URL for a tile based on given bounds.
    */
    getURL: function (bounds) {
        var res = this.getResolution(); 

        // tile center
        var originTileX = (this.tileOrigin.lon + (res * this.tileSize.w/2)); 
        var originTileY = (this.tileOrigin.lat - (res * this.tileSize.h/2));

        var center = bounds.getCenterLonLat();
        var point = { x: center.lon, y: center.lat };
        var x = (Math.round(Math.abs((center.lon - originTileX) / (res * this.tileSize.w)))); 
        var y = (Math.round(Math.abs((originTileY - center.lat) / (res * this.tileSize.h)))); 
        var z = this.map.getZoom();

        // this prevents us from getting pink tiles (non-existant tiles)
        if (this.lods) {        
            var lod = this.lods[this.map.getZoom()];
            if ((x < lod.startTileCol || x > lod.endTileCol) 
                || (y < lod.startTileRow || y > lod.endTileRow)) {
                    return null;
            }
        }
        else {
            var start = this.getUpperLeftTileCoord(res);
            var end = this.getLowerRightTileCoord(res);
            if ((x < start.x || x >= end.x)
                || (y < start.y || y >= end.y)) {
                    return null;
            }        
        }

        // Construct the url string
        var url = this.url;
        var s = '' + x + y + z;

        if (OpenLayers.Util.isArray(url)) {
            url = this.selectUrl(s, url);
        }
		
        // Accessing tiles through ArcGIS Server uses a different path
        // structure than direct access via the folder structure.
        if (this.useArcGISServer) {
            // AGS MapServers have pretty url access to tiles
            url = url + '/tile/${z}/${y}/${x}';
        } else {
            // The tile images are stored using hex values on disk.
            x = 'C' + this.zeroPad(x, 8, 16);
            y = 'R' + this.zeroPad(y, 8, 16);
            z = 'L' + this.zeroPad(z, 2, 16);
            url = url + '/${z}/${y}/${x}.' + this.type;
        }

        // Write the values into our formatted url
        url = OpenLayers.String.format(url, {'x': x, 'y': y, 'z': z});

        return url;
    },

    /**
     * Method: zeroPad
     * Create a zero padded string optionally with a radix for casting numbers.
     *
     * Parameters:
     * num - {Number} The number to be zero padded.
     * len - {Number} The length of the string to be returned.
     * radix - {Number} An integer between 2 and 36 specifying the base to use
     *     for representing numeric values.
     */
    zeroPad: function(num, len, radix) {
		
        var str = num.toString(radix || 10);
        while (str.length < len) {
            str = "0" + str;
        }
        return str;
    },

    CLASS_NAME: 'Geo.View2D.Layer.ArcGISTileLayer' 
}); /**
 * Copyright (C) 2013 OSM Buildings, Jan Marsch
 * A leightweight JavaScript library for visualizing 3D building geometry on interactive maps.
 * @osmbuildings, http://osmbuildings.org
 */

var OSMBuildings = (function() {

    'use strict';



// object access shortcuts  ;  Int32Array:8位有符号整数
var Int32Array = Int32Array || Array,
	//Uint8Array:8位无符号整数
    Uint8Array = Uint8Array || Array,
    m = Math,
    exp = m.exp,
    log = m.log,
    sin = m.sin,
    cos = m.cos,
    tan = m.tan,
    atan = m.atan,
    min = m.min,
    max = m.max,
    ceil = m.ceil,
    floor = m.floor,
    doc = document;





var Color = (function() {

    function hsla2rgb(hsla) { // h belongs to [0, 360]; s,l,a belong to [0, 1]
        var r, g, b;

        if (hsla.s === 0) {
            r = g = b = hsla.l; // achromatic
        } else {
            var q = hsla.l < 0.5 ? hsla.l * (1+hsla.s) : hsla.l + hsla.s - hsla.l * hsla.s,
                p = 2 * hsla.l-q;
            hsla.h /= 360;
            r = hue2rgb(p, q, hsla.h + 1/3);
            g = hue2rgb(p, q, hsla.h);
            b = hue2rgb(p, q, hsla.h - 1/3);
        }
        return new Color(
            r * 255 <<0,
            g * 255 <<0,
            b * 255 <<0,
            hsla.a
        );
    }

    function hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q-p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q-p) * (2/3 - t) * 6;
        }
        return p;
    }

    function Color(r, g, b, a) { // r,g,b belong to [0, 255]; a belongs to [0,1]
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = arguments.length < 4 ? 1 : a;
    }

    var proto = Color.prototype;

    proto.toString = function() {
//        if (this.a === 1) {
//            return '#' + ((1 << 24) + (this.r << 16) + (this.g << 8) + this.b).toString(16).slice(1, 7);
//        }
        return 'rgba(' + [this.r <<0, this.g <<0, this.b <<0, this.a.toFixed(2)].join(',') + ')';
    };

    proto.setLightness = function(l) {
        var hsla = Color.toHSLA(this);
        hsla.l *= l;
        hsla.l = Math.min(1, Math.max(0, hsla.l));
        return hsla2rgb(hsla);
    };

    proto.setAlpha = function(a) {
        return new Color(this.r, this.g, this.b, this.a * a);
    };

    /*
     * str can be in any of the following forms:
     * "#[00-ff][00-ff][00-ff]", "#[00-ff][00-ff][00-ff][00-ff]",
     * "rgb([0-255],[0-255],[0-255])", "rgba([0-255],[0-255],[0-255],[0-1])",
     * "hsl([0-360],[0-1],[0-1])", "hsla([0-360],[0-1],[0-1],[0-1])"
     */
    Color.parse = function(str) {
        var m;
        str += '';
        if (~str.indexOf('#') && (m = str.match(/^#?(\w{2})(\w{2})(\w{2})(\w{2})?$/))) {
            return new Color(
                parseInt(m[1], 16),
                parseInt(m[2], 16),
                parseInt(m[3], 16),
                m[4] ? parseInt(m[4], 16) / 255 : 1
            );
        }

        if ((m = str.match(/rgba?\((\d+)\D+(\d+)\D+(\d+)(\D+([\d.]+))?\)/))) {
            return new Color(
                parseInt(m[1], 10),
                parseInt(m[2], 10),
                parseInt(m[3], 10),
                m[4] ? parseFloat(m[5]) : 1
            );
        }

        if ((m = str.match(/hsla?\(([\d.]+)\D+([\d.]+)\D+([\d.]+)(\D+([\d.]+))?\)/))) {
            return hsla2rgb({
                h: parseInt(m[1], 10),
                s: parseFloat(m[2]),
                l: parseFloat(m[3]),
                a: m[4] ? parseFloat(m[5]) : 1
            });
        }
    };

    Color.toHSLA = function(rgba) { // r,g,b belong to [0, 255]; a belongs to [0,1]
        var r = rgba.r/255,
            g = rgba.g/255,
            b = rgba.b/255,
            max = Math.max(r, g, b), min = Math.min(r, g, b),
            h, s, l = (max+min) / 2,
            d;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            d = max-min;
            s = l > 0.5 ? d / (2-max-min) : d / (max+min);
            switch (max) {
                case r: h = (g-b) / d + (g < b ? 6 : 0); break;
                case g: h = (b-r) / d + 2; break;
                case b: h = (r-g) / d + 4; break;
            }
            h /= 6;
        }

        return { h:h*360, s:s, l:l, a:rgba.a };
    };

    return Color;

}());



// calculations are based on http://aa.quae.nl/en/reken/zonpositie.html
// code credits to Vladimir Agafonkin (@mourner)

var getSunPosition = (function() {

    var m = Math,
      PI = m.PI,
      sin = m.sin,
      cos = m.cos,
      tan = m.tan,
      asin = m.asin,
      atan = m.atan2;

    var rad = PI/180,
      dayMs = 1000*60*60*24,
      J1970 = 2440588,
      J2000 = 2451545,
      e = rad*23.4397; // obliquity of the Earth

    function toJulian(date) {
      return date.valueOf()/dayMs - 0.5+J1970;
    }
    function toDays(date) {
      return toJulian(date)-J2000;
    }
    function getRightAscension(l, b) {
      return atan(sin(l)*cos(e) - tan(b)*sin(e), cos(l));
    }
    function getDeclination(l, b) {
      return asin(sin(b)*cos(e) + cos(b)*sin(e)*sin(l));
    }
    function getAzimuth(H, phi, dec) {
      return atan(sin(H), cos(H)*sin(phi) - tan(dec)*cos(phi));
    }
    function getAltitude(H, phi, dec) {
      return asin(sin(phi)*sin(dec) + cos(phi)*cos(dec)*cos(H));
    }
    function getSiderealTime(d, lw) {
      return rad * (280.16 + 360.9856235*d) - lw;
    }
    function getSolarMeanAnomaly(d) {
      return rad * (357.5291 + 0.98560028*d);
    }
    function getEquationOfCenter(M) {
      return rad * (1.9148*sin(M) + 0.0200 * sin(2*M) + 0.0003 * sin(3*M));
    }
    function getEclipticLongitude(M, C) {
      var P = rad*102.9372; // perihelion of the Earth
      return M+C+P+PI;
    }

    return function getSunPosition(date, lat, lon) {
      var lw = rad*-lon,
        phi = rad*lat,
        d = toDays(date),
        M = getSolarMeanAnomaly(d),
        C = getEquationOfCenter(M),
        L = getEclipticLongitude(M, C),
        D = getDeclination(L, 0),
        A = getRightAscension(L, 0),
        t = getSiderealTime(d, lw),
        H = t-A;

      return {
        altitude: getAltitude(H, phi, D),//垂直高度
        azimuth: getAzimuth(H, phi, D) - PI/2 // origin: north   //方向角
      };
    };

}());



var readGeoJSON = function(collection) {
    var i, il, j, jl, k, kl,
        res = [],
        feature,
        geometry, properties, coordinates,
        wallColor, roofColor,
        last,
        height,
        polygon, footprint, heightSum, holes,
        lat = 1, lon = 0, alt = 2,
        item;

    for (i = 0, il = collection.length; i < il; i++) {
        feature = collection[i];
        if (feature.type !== 'Feature') {
            continue;
        }

        geometry = feature.geometry;
        properties = feature.properties;

        if (geometry.type === 'LineString') {
            last = coordinates.length-1;
            if (coordinates[0][0] === coordinates[last][0] && coordinates[0][1] === coordinates[last][1]) {
                coordinates = geometry.coordinates;
            }
        }

        if (geometry.type === 'Polygon') {
            coordinates = geometry.coordinates;
        }

        // just use the outer ring
        if (geometry.type === 'MultiPolygon') {
            coordinates = geometry.coordinates[0];
        }

        if (!coordinates) {
            continue;
        }

        if (properties.color || properties.wallColor) {
            wallColor = properties.color || properties.wallColor;
        }

        if (properties.roofColor) {
            roofColor = properties.roofColor;
        }

        polygon   = coordinates[0];
        footprint = [];
        height    = properties.height;
        heightSum = 0;
        for (j = 0, jl = polygon.length; j < jl; j++) {
            footprint.push(polygon[j][lat], polygon[j][lon]);
            heightSum += height || polygon[j][alt] || 0;
        }

        holes = [];
        for (j = 1, jl = coordinates.length; j < jl; j++) {
            polygon = coordinates[i];
            holes[j-1] = [];
			//fixed:为了防止polygon.length报错
			if(!polygon) {
				continue;
			}
            for (k = 0, kl = polygon.length; k < kl; k++) {
                holes[j-1].push(polygon[k][lat], polygon[k][lon]);
            }
        }

        // one item per coordinates ring (usually just one ring)
        item = {
            id:properties.id || (footprint[0] + ',' + footprint[1]),
            footprint:makeWinding(footprint, 'CW')
        };
		//fixed:为了防止polygon为空，加了对几何信息的判断
		if(polygon) {
			 if (heightSum)            item.height    = heightSum/polygon.length <<0;
		}
       
        if (properties.minHeight) item.minHeight = properties.minHeight;
        if (wallColor)            item.wallColor = wallColor;
        if (roofColor)            item.roofColor = roofColor;
        if (holes.length)     item.holes = holes;
        res.push(item);
    }

    return res;
};



var readOSMXAPI = (function() {

    var YARD_TO_METER = 0.9144,
        FOOT_TO_METER = 0.3048,
        INCH_TO_METER = 0.0254,
        METERS_PER_LEVEL = 3;

    function parseDimension(str) {
        var value = parseFloat(str);

        if (~str.indexOf('m')) {
            return value <<0;
        }
        if (~str.indexOf('yd')) {
            return value*YARD_TO_METER <<0;
        }
        if (~str.indexOf('ft')) {
            return value*FOOT_TO_METER <<0;
        }
        if (~str.indexOf('\'')) {
            var parts = str.split('\'');
            var res = parts[0]*FOOT_TO_METER + parts[1]*INCH_TO_METER;
            return res <<0;
        }
        return value <<0;
    }

    var baseMaterials = {
        asphalt:'tar_paper',
        bitumen:'tar_paper',
        block:'stone',
        bricks:'brick',
        glas:'glass',
        glassfront:'glass',
        grass:'plants',
        masonry:'stone',
        granite:'stone',
        panels:'panel',
        paving_stones:'stone',
        plastered:'plaster',
        rooftiles:'roof_tiles',
        roofingfelt:'tar_paper',
        sandstone:'stone',
        sheet:'canvas',
        sheets:'canvas',
        shingle:'tar_paper',
        shingles:'tar_paper',
        slates:'slate',
        steel:'metal',
        tar:'tar_paper',
        tent:'canvas',
        thatch:'plants',
        tile:'roof_tiles',
        tiles:'roof_tiles'
    };

    // cardboard
    // eternit
    // limestone
    // straw

    var materialColors = {
        brick:'#cc7755',
        bronze:'#ffeecc',
        canvas:'#fff8f0',
        concrete:'#999999',
        copper:'#a0e0d0',
        glass:'#e8f8f8',
        gold:'#ffcc00',
        plants:'#009933',
        metal:'#aaaaaa',
        panel:'#fff8f0',
        plaster:'#999999',
        roof_tiles:'#f08060',
        silver:'#cccccc',
        slate:'#666666',
        stone:'#996666',
        tar_paper:'#333333',
        wood:'#deb887'
    };

    function parseMaterial(str) {
        str = str.toLowerCase();
        if (str[0] === '#') {
            return str;
        }
        return materialColors[baseMaterials[str] || str] || null;
    }

    function isBuilding(data) {
        var tags = data.tags;
        return (tags &&
            !tags.landuse &&
            (tags.building || tags['building:part']) &&
            (!tags.layer || tags.layer >= 0));
    }

//  living:'bricks',
//  nonliving:'tar_paper',
//  worship:'copper'

    function getBuildingType(tags) {
        if (tags.amenity === 'place_of_worship') {
            return 'worship';
        }

        var type = tags.building;
        if (type === 'yes' || type === 'roof') {
            type = tags['building:use'];
        }
        if (!type) {
            type = tags.amenity;
        }

        switch (type) {
            case 'apartments':
            case 'house':
            case 'residential':
            case 'hut':
                return 'living';
            case 'church':
                return 'worship';
        }

        return 'nonliving';
    }

    function getRelationWays(members) {
        var m, outer, inner = [];
        for (var i = 0, il = members.length; i < il; i++) {
            m = members[i];
            if (m.type !== 'way' || !ways[m.ref]) {
                continue;
            }
            if (!m.role || m.role === 'outer') {
                outer = ways[m.ref];
                continue;
            }
            if (m.role === 'inner' || m.role === 'enclave') {
                inner.push(ways[m.ref]);
                continue;
            }
        }
        if (!outer || !outer.tags) {
            return;
        }
        return { outer:outer, inner:inner };
    }

    function getFootprint(points) {
        if (!points) {
            return;
        }

        var footprint = [], p;
        for (var i = 0, il = points.length; i < il; i++) {
            p = nodes[ points[i] ];
            footprint.push(p[0], p[1]);
        }

        // do not close polygon yet
        if (footprint[footprint.length-2] !== footprint[0] && footprint[footprint.length-1] !== footprint[1]) {
            footprint.push(footprint[0], footprint[1]);
        }

        // can't span a polygon with just 2 points (+ start & end)
        if (footprint.length < 8) {
            return;
        }

        return footprint;
    }

    function mergeTags(dst, src) {
        for (var p in src) {
            if (!dst[p]) {
                dst[p] = src[p];
            }
        }
        return dst;
    }

    function filterTags(tags) {
        var height = 0, minHeight = 0;

        if (tags.height) {
            height = parseDimension(tags.height);
        }
        if (!height && tags['building:height']) {
            height = parseDimension(tags['building:height']);
        }

        if (!height && tags.levels) {
            height = tags.levels*METERS_PER_LEVEL <<0;
        }
        if (!height && tags['building:levels']) {
            height = tags['building:levels']*METERS_PER_LEVEL <<0;
        }

        // min_height
        if (tags.min_height) {
            minHeight = parseDimension(tags.min_height);
        }
        if (!minHeight && tags['building:min_height']) {
            minHeight = parseDimension(tags['building:min_height']);
        }

        if (!minHeight && tags.min_level) {
            minHeight = tags.min_level*METERS_PER_LEVEL <<0;
        }
        if (!minHeight && tags['building:min_level']) {
            minHeight = tags['building:min_level']*METERS_PER_LEVEL <<0;
        }

        var wallColor, roofColor;

        // wall material
        if (tags['building:material']) {
            wallColor = parseMaterial(tags['building:material']);
        }
        if (tags['building:facade:material']) {
            wallColor = parseMaterial(tags['building:facade:material']);
        }
        if (tags['building:cladding']) {
            wallColor = parseMaterial(tags['building:cladding']);
        }
        // wall color
        if (tags['building:color']) {
            wallColor = tags['building:color'];
        }
        if (tags['building:colour']) {
            wallColor = tags['building:colour'];
        }

        // roof material
        if (tags['roof:material']) {
            roofColor = parseMaterial(tags['roof:material']);
        }
        if (tags['building:roof:material']) {
            roofColor = parseMaterial(tags['building:roof:material']);
        }
        // roof color
        if (tags['roof:color']) {
            roofColor = tags['roof:color'];
        }
        if (tags['roof:colour']) {
            roofColor = tags['roof:colour'];
        }
        if (tags['building:roof:color']) {
            roofColor = tags['building:roof:color'];
        }
        if (tags['building:roof:colour']) {
            roofColor = tags['building:roof:colour'];
        }

        return {
            height:    height,
            minHeight: minHeight,
            wallColor: wallColor,
            roofColor: roofColor
        };
    }

    function processNode(node) {
        nodes[node.id] = [node.lat, node.lon];
    }

    function processWay(way) {
        var tags, footprint;
        if (isBuilding(way)) {
            tags = filterTags(way.tags);
            if ((footprint = getFootprint(way.nodes))) {
                addResult(way.id, tags, footprint);
            }
        } else {
            tags = way.tags;
            if (!tags || (!tags.highway && !tags.railway && !tags.landuse)) { // TODO: add more filters
                ways[way.id] = way;
            }
        }
    }

    function processRelation(relation) {
        var relationWays, outerWay, holes = [],
            tags, outerFootprint, innerFootprint;
        if (isBuilding(relation) && (relation.tags.type === 'multipolygon' || relation.tags.type === 'building')) {
            if ((relationWays = getRelationWays(relation.members))) {
                var relTags = filterTags(relation.tags);
                if ((outerWay = relationWays.outer)) {
                    tags = filterTags(outerWay.tags);
                    if ((outerFootprint = getFootprint(outerWay.nodes))) {
                        tags = mergeTags(tags, relTags);
                        for (var i = 0, il = relationWays.inner.length; i < il; i++) {
                            if ((innerFootprint = getFootprint(relationWays.inner[i].nodes))) {
                                holes.push(makeWinding(innerFootprint, 'CCW'));
                            }
                        }
                        addResult(outerWay.id, tags, outerFootprint, holes.length ? holes : null);
                    }
                }
            }
        }
    }

    function addResult(id, tags, footprint, holes) {
        var item = { id:id, footprint:makeWinding(footprint, 'CW'), holes:holes };
        if (tags.height)    item.height    = tags.height;
        if (tags.minHeight) item.minHeight = tags.minHeight;
        if (tags.wallColor) item.wallColor = tags.wallColor;
        if (tags.roofColor) item.roofColor = tags.roofColor;
        if (holes)      item.holes = holes;
        res.push(item);
    }

    var nodes, ways, res;

    return function(data) {
        nodes = {};
        ways = {};
        res = [];

        var item;
        for (var i = 0, il = data.length; i < il; i++) {
            item = data[i];
            switch(item.type ) {
                case 'node':     processNode(item);     break;
                case 'way':      processWay(item);      break;
                case 'relation': processRelation(item); break;
            }
        }

        return res;
    };
})();



// constants, shared to all instances
var VERSION      = '0.1.8a',
    ATTRIBUTION  = '&copy; <a href="http://osmbuildings.org">OSM Buildings</a>',
    OSM_XAPI_URL = 'http://overpass-api.de/api/interpreter?data=[out:json];(way[%22building%22]({s},{w},{n},{e});node(w);way[%22building:part%22=%22yes%22]({s},{w},{n},{e});node(w);relation[%22building%22]({s},{w},{n},{e});way(r);node(w););out;',
//  OSM_XAPI_URL = 'http://overpass.osm.rambler.ru/cgi/interpreter?data=[out:json];(way[%22building%22]({s},{w},{n},{e});node(w);way[%22building:part%22=%22yes%22]({s},{w},{n},{e});node(w);relation[%22building%22]({s},{w},{n},{e});way(r);node(w););out;',

    PI         = Math.PI,
    HALF_PI    = PI/2,
    QUARTER_PI = PI/4,
    RAD        = 180/PI,

    MAP_TILE_SIZE  = 256,    // map tile size in pixels
    DATA_TILE_SIZE = 0.0075, // data tile size in geo coordinates, smaller: less data to load but more requests

    MIN_ZOOM = 15,

    LAT = 'latitude', LON = 'longitude',

    DEFAULT_HEIGHT = 15,
    HEIGHT_SCALE = 3;



function getDistance(p1, p2) {
    var dx = p1[0]-p2[0],
        dy = p1[1]-p2[1];
    return dx*dx + dy*dy;
}
//不理解
function crop(num) {
    return (num*10000 << 0) / 10000;
}

function getCenter(points) {
    var len, x = 0, y = 0;
    for (var i = 0, il = points.length-3; i < il; i += 2) {
        x += points[i];
        y += points[i+1];
    }
    len = (points.length-2) / 2;
    return [x/len <<0, y/len <<0];
}

function getSquareSegmentDistance(px, py, p1x, p1y, p2x, p2y) {
    var dx = p2x-p1x,
        dy = p2y-p1y,
        t;
    if (dx !== 0 || dy !== 0) {
        t = ((px-p1x) * dx + (py-p1y) * dy) / (dx*dx + dy*dy);
        if (t > 1) {
            p1x = p2x;
            p1y = p2y;
        } else if (t > 0) {
            p1x += dx*t;
            p1y += dy*t;
        }
    }
    dx = px-p1x;
    dy = py-p1y;
    return dx*dx + dy*dy;
}

function simplify(points) {
    var sqTolerance = 2,
        len = points.length/2,
        markers = new Uint8Array(len),

        first = 0,
        last  = len - 1,

        i,
        maxSqDist,
        sqDist,
        index,

        firstStack = [],
        lastStack  = [],

        newPoints  = [];

    markers[first] = markers[last] = 1;

    while (last) {
        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSquareSegmentDistance(
                points[i    *2], points[i    *2 + 1],
                points[first*2], points[first*2 + 1],
                points[last *2], points[last *2 + 1]
            );
            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            markers[index] = 1;

            firstStack.push(first);
            lastStack.push(index);

            firstStack.push(index);
            lastStack.push(last);
        }

        first = firstStack.pop();
        last = lastStack.pop();
    }

    for (i = 0; i < len; i++) {
        if (markers[i]) {
            newPoints.push(points[i*2], points[i*2 + 1]);
        }
    }

    return newPoints;
}

// detect polygon winding direction: clockwise or counter clockwise
function getWinding(points) {
    var x1, y1, x2, y2,
        a = 0,
        i, il;
    for (i = 0, il = points.length-3; i < il; i += 2) {
        x1 = points[i];
        y1 = points[i+1];
        x2 = points[i+2];
        y2 = points[i+3];
        a += x1*y2 - x2*y1;
    }
    return (a/2) > 0 ? 'CW' : 'CCW';
}

// make polygon winding clockwise. This is needed for proper backface culling on client side.
function makeWinding(points, direction) {
    var winding = getWinding(points);
    if (winding === direction) {
        return points;
    }
    var revPoints = [];
    for (var i = points.length-2; i >= 0; i -= 2) {
        revPoints.push(points[i], points[i+1]);
    }
    return revPoints;
}



    var osmb = function(url) {



// private variables, specific to an instance
var width = 0, height = 0,
    halfWidth = 0, halfHeight = 0,
    originX = 0, originY = 0,
    zoom, size,

    activeRequest,

    context,
	//设置墙的默认颜色
    defaultWallColor = new Color(200, 190, 180),
	//建筑左右两边墙的亮度
    defaultAltColor  = defaultWallColor.setLightness(0.8),
	//建筑屋顶的亮度
    defaultRoofColor = defaultWallColor.setLightness(1.2),

    wallColorAlpha = defaultWallColor + '',
    altColorAlpha  = defaultAltColor + '',
    roofColorAlpha = defaultRoofColor + '',
	//淡出因数：
    fadeFactor = 1,
    animTimer,
    zoomAlpha = 1,

    minZoom = MIN_ZOOM,
    maxZoom = 20,
    maxHeight,

    camX, camY, camZ,

    isZooming;



function pixelToGeo(x, y) {
    var res = {};
    x /= size;
    y /= size;
    res[LAT] = y <= 0  ? 90 : y >= 1 ? -90 : RAD * (2 * atan(exp(PI * (1 - 2 * y))) - HALF_PI),
    res[LON] = (x === 1 ?  1 : (x % 1 + 1) % 1) * 360 - 180;
    return res;
}

function geoToPixel(lat, lon) {
    var latitude  = min(1, max(0, 0.5 - (log(tan(QUARTER_PI + HALF_PI * lat / 180)) / PI) / 2)),
        longitude = lon / 360 + 0.5;
    return {
        x: longitude*size <<0,
        y: latitude *size <<0
    };
}

function fromRange(sVal, sMin, sMax, dMin, dMax) {
    sVal = min(max(sVal, sMin), sMax);
    var rel = (sVal-sMin) / (sMax-sMin),
        range = dMax-dMin;
    return min(max(dMin + rel*range, dMin), dMax);
}

function xhr(_url, param, callback) {
    var url = _url.replace(/\{ *([\w_]+) *\}/g, function(tag, key) {
        return param[key] || tag;
    });

    var req = 'XDomainRequest' in window ? new XDomainRequest() : new XMLHttpRequest();

    function changeState(state) {
        if ('XDomainRequest' in window && state !== req.readyState) {
            req.readyState = state;
            if (req.onreadystatechange) {
                req.onreadystatechange();
            }
        }
    }

    req.onerror = function() {
        req.status = 500;
        req.statusText = 'Error';
        changeState(4);
    };

    req.ontimeout = function() {
        req.status = 408;
        req.statusText = 'Timeout';
        changeState(4);
    };

    req.onprogress = function() {
        changeState(3);
    };

    req.onload = function() {
        req.status = 200;
        req.statusText = 'Ok';
        changeState(4);
    };

    req.onreadystatechange = function() {
        if (req.readyState !== 4) {
            return;
        }
        if (!req.status || req.status < 200 || req.status > 299) {
            return;
        }
        if (callback && req.responseText) {
            callback(JSON.parse(req.responseText));
        }
    };

    changeState(0);
    req.open('GET', url);
    changeState(1);
    req.send(null);
    changeState(2);

    return req;
}



var Cache = (function() {

    var _time = new Date();
    var _data = {};

    var me = {};

    me.add = function(key, data) {
        _data[key] = { data:data, time:Date.now() };
    };

    me.get = function(key) {
        return _data[key] && _data[key].data;
    };
	//清除缓存数据
    me.purge = function() {
        _time.setMinutes(_time.getMinutes()-5);
        for (var key in _data) {
            if (_data[key].time < _time) {
                delete _data[key];
            }
        }
    };

    return me;

}());



var Data = (function() {

    var _url;
    var _index = {}; // maintain a list of cached items in order to fade in new ones

    function _closureParse(cacheKey) {
        return function(res) {
            _parse(res, cacheKey);
        };
    }

    function _parse(data, cacheKey) {
        if (!data) {
            return;
        }

        var items;
        if (data.type === 'FeatureCollection') { // GeoJSON
            items = readGeoJSON(data.features);
        } else if (data.osm3s) { // XAPI,本（readOSMXAPI）方法不是GeoJSON的返回方法，暂不考虑
            items = readOSMXAPI(data.elements);
        }

        if (cacheKey) {//添加数据到缓存
            Cache.add(cacheKey, items);
        }

        _add(items, true);
    }

    function _getFootprint(polygon) {
        var footprint = new Int32Array(polygon.length),
            px;
        for (var i = 0, il = polygon.length-1; i < il; i+=2) {
            px = geoToPixel(polygon[i], polygon[i+1]);
            footprint[i]   = px.x;
            footprint[i+1] = px.y;
        }
		//稀疏数据
        footprint = simplify(footprint);
        if (footprint.length < 8) { // 3 points + end==start (*2)
            return;
        }
        return footprint;
    }
	//不清楚isNew的含义
    function _add(data, isNew) {
        var items = _scale(data, zoom, isNew);

        var item;
        for (var i = 0, il = items.length; i < il; i++) {
            item = items[i];
            if (!_index[item.id]) {
                item.scale = isNew ? 0 : 1;
                me.renderItems.push(items[i]);
                _index[item.id] = 1;
            }
        }
        fadeIn();
    }

    function _scale(items, zoom) {
        var i, il, j, jl,
            res = [],
            item,
			//footprint屋底
            height, minHeight, footprint,
			//roof屋顶，wall:墙
            color, wallColor, altColor, roofColor,
            holes, innerFootprint,
            zoomDelta = maxZoom-zoom;

        for (i = 0, il = items.length; i < il; i++) {

            item = items[i];
			//?:HEIGHT_SCALE是一个什么概念
            height = (item.height || DEFAULT_HEIGHT)*HEIGHT_SCALE >> zoomDelta;
            if (!height) {
                continue;
            }

            minHeight = item.minHeight*HEIGHT_SCALE >> zoomDelta;
            if (minHeight > maxHeight) {
                continue;
            }

            if (!(footprint = _getFootprint(item.footprint))) {
                continue;
            }

            holes = [];
            if (item.holes) {
                for (j = 0, jl = item.holes.length; j < jl; j++) {
                    if ((innerFootprint = _getFootprint(item.holes[j]))) {
                        holes.push(innerFootprint);
                    }
                }
            }

            wallColor = null;
            altColor  = null;
            if (item.wallColor) {
                if ((color = Color.parse(item.wallColor))) {
					//带透明度的颜色，zoomAlpha是透明度
                    wallColor = color.setAlpha(zoomAlpha);
                    altColor  = '' + wallColor.setLightness(0.8);
                    wallColor = '' + wallColor;
                }
            }

            roofColor = null;
            if (item.roofColor) {
                if ((color = Color.parse(item.roofColor))) {
                    roofColor = '' + color.setAlpha(zoomAlpha);
                }
            }

            res.push({
                id:        item.id,
                footprint: footprint,
                height:    min(height, maxHeight),
                minHeight: minHeight,
                wallColor: wallColor,
                altColor:  altColor,
                roofColor: roofColor,
                center:    getCenter(footprint),
                holes:     holes.length ? holes : null
            });
        }

        return res;
    }

    var me = {};

    me.renderItems = []; // TODO: move to renderer

    me.load = function(url) {
        _url = url || OSM_XAPI_URL;
        me.update();
    };

    me.update = function() {
        if (!_url || zoom < MIN_ZOOM) {
            return;
        }

        var nw = pixelToGeo(originX,       originY),
            se = pixelToGeo(originX+width, originY+height),
            sizeLat = DATA_TILE_SIZE,
            sizeLon = DATA_TILE_SIZE*2;

        var bounds = {
            n: ceil( nw.latitude /sizeLat) * sizeLat,
            e: ceil( se.longitude/sizeLon) * sizeLon,
            s: floor(se.latitude /sizeLat) * sizeLat,
            w: floor(nw.longitude/sizeLon) * sizeLon
        };

        Cache.purge();
        me.renderItems = [];
        _index = {};

        var lat, lon,
            cached, key;

        for (lat = bounds.s; lat <= bounds.n; lat += sizeLat) {
            for (lon = bounds.w; lon <= bounds.e; lon += sizeLon) {
                key = lat + ',' + lon;
                if ((cached = Cache.get(key))) {
                    _add(cached);
                } else {
                    xhr(_url, {
                        n: crop(lat+sizeLat),
                        e: crop(lon+sizeLon),
                        s: crop(lat),
                        w: crop(lon)
                    }, _closureParse(key));
                }
            }
        }
    };

    me.set = function(data) {
        me.renderItems = [];
        _index = {};
        _parse(data);
    };

    return me;

}());




function fadeIn() {
    if (animTimer) {
        return;
    }

    animTimer = setInterval(function() {
        var item, needed = false;
        for (var i = 0, il = Data.renderItems.length; i < il; i++) {
            item = Data.renderItems[i];
            if (item.scale < 1) {
                item.scale += 0.5*0.2; // amount*easing
                if (item.scale > 1) {
                    item.scale = 1;
                }
                needed = true;
            }
        }

        renderAll();

        if (!needed) {
            clearInterval(animTimer);
            animTimer = null;
        }
    }, 33);
}

function renderAll() {
    Shadows.render();
    FlatBuildings.render();
    render();
}

function render() {
	////clearRect相当于相橡皮擦，把矩形的内容把擦掉
    context.clearRect(0, 0, width, height);

    // show on high zoom levels only and avoid rendering during zoom
    if (zoom < minZoom || isZooming) {
        return;
    }

    var i, il, j, jl,
        item,
        h, _h, mh, _mh,
        flatMaxHeight = FlatBuildings.MAX_HEIGHT,
        sortCam = [camX+originX, camY+originY],
        vp = {
            minX: originX,
            maxX: originX+width,
            minY: originY,
            maxY: originY+height
        },
        footprint, roof, holes,
        isVisible,
        wallColor, altColor;

    // TODO: FlatBuildings are drawn separately, data has to be split
    Data.renderItems.sort(function(a, b) {
        return getDistance(b.center, sortCam)/b.height - getDistance(a.center, sortCam)/a.height;
    });

    for (i = 0, il = Data.renderItems.length; i < il; i++) {
        item = Data.renderItems[i];

        if (item.height <= flatMaxHeight) {
            continue;
        }

        isVisible = false;
        footprint = item.footprint;
        for (j = 0, jl = footprint.length - 1; j < jl; j += 2) {
            // checking footprint is sufficient for visibility
            // TODO: pre-filter by data tile position
            if (!isVisible) {
                isVisible = (footprint[j] > vp.minX && footprint[j] < vp.maxX && footprint[j+1] > vp.minY && footprint[j+1] < vp.maxY);
            }
        }

        if (!isVisible) {
            continue;
        }

        // when fading in, use a dynamic height
        h = item.scale < 1 ? item.height*item.scale : item.height;
        // precalculating projection height factor
        _h = camZ / (camZ-h);

        _mh = 0;
        if (item.minHeight) {
            mh = item.scale < 1 ? item.minHeight*item.scale : item.minHeight;
            _mh = camZ / (camZ-mh);
        }

        wallColor = item.wallColor || wallColorAlpha;
        altColor  = item.altColor  || altColorAlpha;
        roof = renderPolygon(footprint, _h, _mh, wallColor, altColor);

        holes = [];
        if (item.holes) {
            for (j = 0, jl = item.holes.length; j < jl; j++) {
                holes[j] = renderPolygon(item.holes[j], _h, _mh, wallColor, altColor);
            }
        }

        // fill roof and optionally stroke it
        context.fillStyle   = item.roofColor || roofColorAlpha;
        context.strokeStyle = altColor;
        drawShape(roof, true, holes);
    }
}

function renderPolygon(polygon, h, mh, wallColor, altColor) {
    var a = { x:0, y:0 }, b = { x:0, y:0 },
        _a, _b,
        roof = [];
    for (var i = 0, il = polygon.length-3; i < il; i += 2) {
        a.x = polygon[i]  -originX;
        a.y = polygon[i+1]-originY;
        b.x = polygon[i+2]-originX;
        b.y = polygon[i+3]-originY;

        // project 3d to 2d on extruded footprint
        _a = project(a.x, a.y, h);
        _b = project(b.x, b.y, h);

        if (mh) {
            a = project(a.x, a.y, mh);
            b = project(b.x, b.y, mh);
        }

        // backface culling check
        if ((b.x-a.x) * (_a.y-a.y) > (_a.x-a.x) * (b.y-a.y)) {
            // depending on direction, set wall shading
            if ((a.x < b.x && a.y < b.y) || (a.x > b.x && a.y > b.y)) {
				//填充颜色
                context.fillStyle = altColor;
            } else {
                context.fillStyle = wallColor;
            }
            drawShape([
                b.x, b.y,
                a.x, a.y,
                _a.x, _a.y,
                _b.x, _b.y
            ]);
        }
        roof[i]   = _a.x;
        roof[i+1] = _a.y;
    }

    return roof;
}

function drawShape(points, stroke, holes) {
    if (!points.length) {
        return;
    }

    var i, il, j, jl;
    context.beginPath();

    context.moveTo(points[0], points[1]);
    for (i = 2, il = points.length; i < il; i += 2) {
        context.lineTo(points[i], points[i+1]);
    }

    if (holes) {
        for (i = 0, il = holes.length; i < il; i++) {
            points = holes[i];
            context.moveTo(points[0], points[1]);
            for (j = 2, jl = points.length; j < jl; j += 2) {
                context.lineTo(points[j], points[j+1]);
            }
        }
    }

    context.closePath();
    if (stroke) {
        context.stroke();
    }
    context.fill();
}

function project(x, y, m) {
    return {
        x: (x-camX) * m + camX <<0,
        y: (y-camY) * m + camY <<0
    };
}

/*
function debugMarker(x, y, color, size) {
    context.fillStyle = color || '#ffcc00';
    context.beginPath();
    context.arc(x, y, size || 3, 0, PI*2, true);
    context.closePath();
    context.fill();
}

function debugLine(ax, ay, bx, by, color) {
    context.strokeStyle = color || '#ff0000';
    context.beginPath();
    context.moveTo(ax, ay);
    context.lineTo(bx, by);
    context.closePath();
    context.stroke();
}
*/



var Shadows = (function() {

    var _context;
    var _enabled = true;
    var _color = new Color(0, 0, 0);
    var _date = null;
    var _direction = { x:0, y:0 };

    function _project(x, y, h) {
        return {
            x: x + _direction.x*h,
            y: y + _direction.y*h
        };
    }

    var me = {};

    me.setContext = function(context) {
        _context = context;
        // TODO: fix bad Date() syntax
        me.setDate(new Date().setHours(10)); // => render()
    };

    me.enable = function(flag) {
        _enabled = !!flag;
        // should call me.render() but it is usually set by setStyle() and there a renderAll() is called
    };

    me.render = function() {
        var center, sun, length, alpha, colorStr;

        _context.clearRect(0, 0, width, height);

        // show on high zoom levels only and avoid rendering during zoom
        if (!_enabled || zoom < minZoom || isZooming) {
            return;
        }

        // TODO: at some point, calculate me just on demand
        center = pixelToGeo(originX+halfWidth, originY+halfHeight);
        sun = getSunPosition(_date, center.latitude, center.longitude);

        if (sun.altitude <= 0) {
            return;
        }

        length = 1 / tan(sun.altitude);
        alpha = 0.4 / length;
        _direction.x = cos(sun.azimuth) * length;
        _direction.y = sin(sun.azimuth) * length;

        // TODO: maybe introduce Color.setAlpha()
        _color.a = alpha;
        colorStr = _color + '';

        var i, il, j, jl,
            item,
            f, h, g,
            x, y,
            footprint,
            mode,
            isVisible,
            ax, ay, bx, by,
            a, b, _a, _b,
            points,
            allFootprints = [];

        _context.beginPath();

        for (i = 0, il = Data.renderItems.length; i < il; i++) {
            item = Data.renderItems[i];

// TODO: no shadows when buildings are too flat => don't add them to renderItems then
//        if (item.height <= FlatBuildings.MAX_HEIGHT) {
//            continue;
//        }

            isVisible = false;
            f = item.footprint;
            footprint = [];
            for (j = 0, jl = f.length - 1; j < jl; j += 2) {
                footprint[j]   = x = f[j]  -originX;
                footprint[j+1] = y = f[j+1]-originY;

                // TODO: checking footprint is sufficient for visibility - NOT VALID FOR SHADOWS!
                if (!isVisible) {
                    isVisible = (x > 0 && x < width && y > 0 && y < height);
                }
            }

            if (!isVisible) {
                continue;
            }

            // when fading in, use a dynamic height
            h = item.scale < 1 ? item.height*item.scale : item.height;

            // prepare same calculations for min_height if applicable
            if (item.minHeight) {
                g = item.scale < 1 ? item.minHeight*item.scale : item.minHeight;
            }

            mode = null;

            for (j = 0, jl = footprint.length-3; j < jl; j += 2) {
                ax = footprint[j];
                ay = footprint[j+1];
                bx = footprint[j+2];
                by = footprint[j+3];

                _a = _project(ax, ay, h);
                _b = _project(bx, by, h);

                if (item.minHeight) {
                    a = _project(ax, ay, g);
                    b = _project(bx, by, g);
                    ax = a.x;
                    ay = a.y;
                    bx = b.x;
                    by = b.y;
                }

                if ((bx-ax) * (_a.y-ay) > (_a.x-ax) * (by-ay)) {
                    if (mode === 1) {
                        _context.lineTo(ax, ay);
                    }
                    mode = 0;
                    if (!j) {
                        _context.moveTo(ax, ay);
                    }
                    _context.lineTo(bx, by);
                } else {
                    if (mode === 0) {
                        _context.lineTo(_a.x, _a.y);
                    }
                    mode = 1;
                    if (!j) {
                        _context.moveTo(_a.x, _a.y);
                    }
                    _context.lineTo(_b.x, _b.y);
                }
            }

            _context.closePath();

            allFootprints.push(footprint);
        }

        _context.fillStyle = colorStr;
        _context.fill();

        // now draw all the footprints as negative clipping mask
        _context.globalCompositeOperation = 'destination-out';
        _context.beginPath();
        for (i = 0, il = allFootprints.length; i < il; i++) {
            points = allFootprints[i];
            _context.moveTo(points[0], points[1]);
            for (j = 2, jl = points.length; j < jl; j += 2) {
                _context.lineTo(points[j], points[j+1]);
            }
            _context.lineTo(points[0], points[1]);
            _context.closePath();
        }
        _context.fillStyle = '#00ff00';
        _context.fill();
        _context.globalCompositeOperation = 'source-over';
    };

    me.setDate = function(date) {
        _date = date;
        me.render();
    };

    return me;

}());



var FlatBuildings = (function() {

    var _context;

    var me = {};

    me.MAX_HEIGHT = 8;

    me.setContext = function(context) {
        _context = context;
    };

    me.render = function() {
        _context.clearRect(0, 0, width, height);

        // show on high zoom levels only and avoid rendering during zoom
        if (zoom < minZoom || isZooming) {
            return;
        }

        var i, il, j, jl,
            item,
            f,
            x, y,
            footprint,
            isVisible,
            ax, ay;

        _context.beginPath();

        for (i = 0, il = Data.renderItems.length; i < il; i++) {
            item = Data.renderItems[i];

            if (item.height > me.MAX_HEIGHT) {
                continue;
            }

            isVisible = false;
            f = item.footprint;
            footprint = [];
            for (j = 0, jl = f.length-1; j < jl; j += 2) {
                footprint[j]   = x = f[j]  -originX;
                footprint[j+1] = y = f[j+1]-originY;

                // checking footprint is sufficient for visibility
                if (!isVisible) {
                    isVisible = (x > 0 && x < width && y > 0 && y < height);
                }
            }

            if (!isVisible) {
                continue;
            }

            for (j = 0, jl = footprint.length-3; j < jl; j += 2) {
                ax = footprint[j];
                ay = footprint[j + 1];
                if (!j) {
                    _context.moveTo(ax, ay);
                } else {
                    _context.lineTo(ax, ay);
                }
            }

            _context.closePath();
        }

        _context.fillStyle   = roofColorAlpha;
        _context.strokeStyle = altColorAlpha;

        _context.stroke();
        _context.fill();
    };

    return me;

}());



var Layers = (function() {

    var _container = doc.createElement('DIV');
    _container.style.pointerEvents = 'none';
    _container.style.position = 'absolute';
    _container.style.left = 0;
    _container.style.top  = 0;

    var _items = [];

    // TODO: improve this to _createItem(Layer) => layer.setContext(context)
    Shadows.setContext(      _createItem());
    FlatBuildings.setContext(_createItem());
    context = _createItem(); // default (global) render context

    function _createItem() {
        var canvas = doc.createElement('CANVAS');
        canvas.style.webkitTransform = 'translate3d(0,0,0)'; // turn on hw acceleration
        canvas.style.imageRendering = 'optimizeSpeed';
        canvas.style.position = 'absolute';
        canvas.style.left = 0;
        canvas.style.top  = 0;

        var context = canvas.getContext('2d');
        context.lineCap   = 'round';
        context.lineJoin  = 'round';
        context.lineWidth = 1;

        context.mozImageSmoothingEnabled    = false;
        context.webkitImageSmoothingEnabled = false;

        _items.push(canvas);
        _container.appendChild(canvas);

        return context;
    }

    var me = {};

    me.appendTo = function(parentNode) {
        parentNode.appendChild(_container);
        return _container;
    };

    me.setSize = function(w, h) {
        for (var i = 0, il = _items.length; i < il; i++) {
            _items[i].width  = w;
            _items[i].height = h;
        }
    };

    return me;

}());



function setSize(w, h) {
    width  = w;
    height = h;
    halfWidth  = width /2 <<0;
    halfHeight = height/2 <<0;
    camX = halfWidth;
    camY = height;
	//window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。
	//公式表示就是：window.devicePixelRatio = 物理像素 / dips
    camZ = width / (1.5 / (window.devicePixelRatio || 1)) / tan(90/2) <<0; // adapting cam pos to field of view (90°), 1.5 is an empirical correction factor
    Layers.setSize(width, height);
    // TODO: change of maxHeight needs to adjust building heights!
    maxHeight = camZ-50;
}

function setOrigin(x, y) {
    originX = x;
    originY = y;
}

function setZoom(z) {
    zoom = z;
    size = MAP_TILE_SIZE <<zoom;

    zoomAlpha = 1 - fromRange(zoom, minZoom, maxZoom, 0, 0.3);

    wallColorAlpha = defaultWallColor.setAlpha(zoomAlpha) + '';
    altColorAlpha  = defaultAltColor.setAlpha( zoomAlpha) + '';
    roofColorAlpha = defaultRoofColor.setAlpha(zoomAlpha) + '';
}

function setCam(x, y) {
    camX = x;
    camY = y;
}

function setStyle(style) {
    style = style || {};
    if (style.color || style.wallColor) {
        defaultWallColor = Color.parse(style.color || style.wallColor);
        wallColorAlpha = defaultWallColor.setAlpha(zoomAlpha) + '';
		//设置墙的左右面透明度
        defaultAltColor = defaultWallColor.setLightness(0.8);
        altColorAlpha = defaultAltColor.setAlpha(zoomAlpha) + '';
		//设置墙的左右面透明度
        defaultRoofColor = defaultWallColor.setLightness(1.2);
        roofColorAlpha = defaultRoofColor.setAlpha(zoomAlpha) + '';
    }

    if (style.roofColor) {
        defaultRoofColor = Color.parse(style.roofColor);
        roofColorAlpha = defaultRoofColor.setAlpha(zoomAlpha) + '';
    }

    if (style.shadows !== undefined) {
        Shadows.enable(style.shadows);
    }

    renderAll();
}



this.onResize = function(e) {
    setSize(e.width, e.height);
    renderAll();
    Data.update();
}

function onMoveEnd(e) {
    renderAll();
    Data.update(); // => fadeIn() => renderAll()
}

function onZoomStart(e) {
    isZooming = true;
    // effectively clears because of isZooming flag
    renderAll();
}

function onZoomEnd(e) {
    isZooming = false;
    setZoom(e.zoom);
    Data.update(); // => fadeIn()
    renderAll();
}



this.setStyle = function(style) {
    setStyle(style);
};

this.setCamOffset = function(x, y) {
    camX = halfWidth + x;
    camY = height    + y;
};

this.setMaxZoom = function(z) {
    maxZoom = z;
};

this.setDate = function(date) {
    Shadows.setDate(date);
};

this.appendTo = function(parentNode) {
    return Layers.appendTo(parentNode);
};

this.loadData = function(url) {
    Data.load(url);
};

this.setData = function(data) {
    Data.set(data);
};

this.onMoveEnd   = onMoveEnd;
this.onZoomEnd   = onZoomEnd;
this.onZoomStart = onZoomStart;
this.setOrigin   = setOrigin;
this.setSize     = setSize;
this.setZoom     = setZoom;
this.render      = render;
this.renderAll   = renderAll;



    };

    osmb.VERSION     = VERSION;
    osmb.ATTRIBUTION = ATTRIBUTION;

    return osmb;

}());



/**
 *  Class: Geo.View2D.Layer.Buildings
 *  3D楼块图层是通过OGC的地图服务查询接口或Arcgis的地图服务查询接口获取矢量数据，并在地图
 *  上生成立体矢量数据的图层。
 *  
 *	Inherits from:
 *  	- <Geo.View2D.Layer>
 */
Geo.View2D.Layer.Buildings = Geo.Class(Geo.View2D.Layer, {

	/** 
     * APIProperty: name
     * {String} 服务名称
     */
    name: 'GEO Buildings',
	
	/**
	 * APIProperty: url
	 * {String} 地图服务服务地址
	 */
	url: null,
	
	/**
	 * APIProperty: minLevel
	 * {Integer}设置查询的最小级别，超出了最小级别则不做查询。默认值：15，取值范围[15-20]，其中minLevel必须要小于或等于maxLevel。
	 */
	minLevel: 15,
	
	/**
	 * APIProperty: maxLevel
	 * {Integer}设置查询的最大级别，超出了设定的最大级别则不做查询。默认值：20，取值范围[15-20]，其中maxLevel必须要大于或等于minLevel。
	 */
	maxLevel: 20,
	
	/**
	 *	Property: featureExt
	 *	本属性用于减少服务器负荷
	 */
	featureExt: null,
	
	/**
	 *	APIProperty: heightScaleRatio
	 *	{Integer} 房屋高度的夸张系数
	 */
	heightScaleRatio: 1,
	
	/**
	 *	APIProperty: heightAttribute
	 *	{Integer} 高度属性名称
	 */
	heightAttribute: "HRG",
	
	/**
	 * APIProperty: query
	 * {Geo.Query.MapServiceQueryParameters} 3D楼块查询条件对象查询条件。
	 * >如果用户不创建Geo.Query.MapServiceQueryParameters对象，那么图层将会创建一个默认的Geo.Query.MapServiceQueryParameters对象。
	 * >说明：
	 * >query对象的geometry属性：如果用户不设置geometry属性，那么geometry属性会根据地图当前可视范围以及extentScaleRatio计算得到。
	 * >如果用户设置了本属性，则以用户设置的为准。
	 */
	query: null,
	
	/**
	 *	APIProperty: extentScaleRatio
	 *	{float} 请求范围比率，默认值为2.1。目的是减少服务器负担，扩大请求范围。
	 */
	extentScaleRatio: 2.1,
	
	/**
	 *	APIProperty: zoomOffset
	 *	{Integer} 地图的级别偏移量
	 */
	zoomOffset: 0,
	
	/**
	 *	Property: dxSum
	 *	图层移动后的偏移
	 */
    dxSum: 0,
    
	/**
	 *	Property: dySum
	 *	图层移动后的偏移
	 */
    dySum: 0,
		
	/**
     * Constructor: Geo.View2D.Layer.Buildings
     *
     * Example:
     * (code)
     * 	var geoBuildings = new Geo.View2D.Layer.Buildings();
	 *	map.addLayer(geoBuildings);
     * (end)
     *
     * Parameters:
     * 	name - {String} 图层名称
     * 	url - {String} 地图服务
     * 	options - {Object} 参数对象，可选参数值如下：
     * 	>	query - {Geo.Query.MapServiceQueryParameters}(可选) 3D楼块查询条件对象
     * 	>	extentScaleRatio - {float} (可选) 请求范围比率，默认值为2.1 
     * 	>	heightAttribute - {Integer} (可选) 楼块高度的属性名
     * 	>	heightScaleRatio - {Integer} (可选) 房屋高度的夸张系数，默认值为1
     *  >	zoomOffset - {Integer} (可选) 地图级别偏移量
     * 	>	minLevel - {Integer} (可选) 最小级别
     * 	>	maxLevel - {Integer} (可选) 最大级别
     */
    initialize: function(name, url, options) {
		
		//判断浏览器是否支持canvas画布
		if (!(!!document.createElement('canvas').getContext)) {
			alert('您的浏览器不支持当前的canvas矢量渲染方式，请使用支持HTML5的浏览器运行。');
		}
        options = options || {};
		
//	   	options.projection = 'EPSG:900913';
		
		this.format = new Geo.Format.JSON();
		if(options.query instanceof Geo.Query.MapServiceQueryParameters) {
			
			this.query = options.query;
			
		}else {
			this.query = new Geo.Query.MapServiceQueryParameters();
			
		}
		this.query.returnGeometry = true;
		
		if(typeof url == "string") {
			this.url = url;
			//构造图层类,Geo.View2D.Layer.Buildings类依赖Geo.Query.MapServiceQueryParameters类以及Geo.Query.MapServiceQuery类
			this.mapServiceQuery = new Geo.Query.MapServiceQuery(url);
			var format = this.format;
			this.mapServiceQuery.queryTemp = function(queryParameter ,successFn, failFn) {
				var params = this._getParamsFromQueryParameter(queryParameter);	
				var DEFAULT_PARAMS = {
					f:"json",
					pretty:true
				}
				Geo.Util.applyDefaults(
			        params, DEFAULT_PARAMS
			    );
				OpenLayers.loadURL(this.url,params,this,function(result) {
					var res = format.read(result.responseText);
					successFn(res);
				},failFn);
			}
		}
		
		Geo.View2D.Layer.prototype.initialize.apply(this, [name, options]);
    },
	
	/**
	 * Method: _loadData
	 */
	_loadData: function() {
		if (this.timerId != null) {
            window.clearTimeout(this.timerId);
        }
		//根据当前地图视口范围，按照比例，得到一个更大的范围,根据这个更大的范围进行查询
		 this.timerId = window.setTimeout(
			OpenLayers.Function.bind(function() {
			if(this.mapServiceQuery instanceof Geo.Query.MapServiceQuery) {
				if(this.featureExt && this.featureExt.featureExt) {
					var isContain = this.featureExt.featureExt.containsBounds(this.map.getExtent());
					if(isContain && this.featureExt.zoom === this.map.zoom) {
						return;
					}
					this.featureExt = {
						featureExt: this.map.getExtent().scale(this.extentScaleRatio),
						zoom: this.map.zoom
					};
					this.query.geometry = this.featureExt.featureExt;
				}else {
					this.featureExt = {
						featureExt : this.map.getExtent().scale(this.extentScaleRatio),
						zoom: this.map.zoom
					};
					this.query.geometry = this.featureExt.featureExt;
				}
				this.mapServiceQuery.queryTemp(this.query, Geo.Function.bind( this._onQueryComplete, this));
			}
		}, this) ,500);
    },
	
	_getPolygon: function() {
		//当前范围
		var currentExtent = this.map.getExtent().scale(this.extentScaleRatio);
		var featureExt = this.featureExt;
		var polygon = null;
		//之前的范围
		if(featureExt instanceof Geo.Bounds) {
			if(currentExtent.left > featureExt.left && currentExtent.bottom > featureExt.bottom) {
				var pointLB = new Geo.Geometry.Point(currentExtent.left,currentExtent.bottom);
				var pointMT = new Geo.Geometry.Point(featureExt.right,featureExt.top);
				var pointMB = new Geo.Geometry.Point(featureExt.right,currentExtent.bottom);
				var pointRB = new Geo.Geometry.Point(currentExtent.right,currentExtent.bottom);
				var pointRT = new Geo.Geometry.Point(currentExtent.right,currentExtent.top);
				var pointLT = new Geo.Geometry.Point(currentExtent.left,currentExtent.top);
				polygon = new Geo.Geometry.Polygon(new Geo.Geometry.LinearRing([pointLB,pointMT,pointMB,pointRB,pointRT,pointLT,pointLB]));
			}else if(currentExtent.left > featureExt.left && currentExtent.bottom < featureExt.bottom) {
				var pointLB = new Geo.Geometry.Point(currentExtent.left,currentExtent.bottom);
				var pointLM = new Geo.Geometry.Point(currentExtent.left,featureExt.bottom);
				var pointMM = new Geo.Geometry.Point(featureExt.right,featureExt.bottom);
				var pointMT = new Geo.Geometry.Point(featureExt.right,currentExtent.top);
				var pointRT = new Geo.Geometry.Point(currentExtent.right,currentExtent.top);
				var pointLT = new Geo.Geometry.Point(currentExtent.left,currentExtent.bottom);
				polygon = new Geo.Geometry.Polygon(new Geo.Geometry.LinearRing([pointLB,pointLM,pointMM,pointMT,pointRT,pointLT,pointLB]));
			}else if(currentExtent.bottom > featureExt.bottom && currentExtent.right < featureExt.right) {
				var pointLT = new Geo.Geometry.Point(currentExtent.left,currentExtent.top);
				var pointLB = new Geo.Geometry.Point(currentExtent.left,currentExtent.bottom);
				var pointRB = new Geo.Geometry.Point(featureExt.left,currentExtent.bottom);
				var pointRM = new Geo.Geometry.Point(featureExt.left,featureExt.top);
				var pointMR = new Geo.Geometry.Point(currentExtent.right,featureExt.top);
				var pointRT = new Geo.Geometry.Point(currentExtent.right,currentExtent.top);
				polygon = new Geo.Geometry.Polygon(new Geo.Geometry.LinearRing([pointLT,pointLB,pointRB,pointRM,pointMR,pointRT,pointLT]));
			}else if(currentExtent.bottom < featureExt.bottom && currentExtent.right < featureExt.right) {
				var pointLB = new Geo.Geometry.Point(currentExtent.left,currentExtent.bottom);
				var pointRB = new Geo.Geometry.Point(currentExtent.right,currentExtent.bottom);
				var pointRM = new Geo.Geometry.Point(currentExtent.right,featureExt.bottom);
				var pointMT = new Geo.Geometry.Point(featureExt.left,featureExt.bottom);
				var pointRT = new Geo.Geometry.Point(featureExt.left,currentExtent.top);
				var pointLT = new Geo.Geometry.Point(currentExtent.left,currentExtent.top);
				polygon = new Geo.Geometry.Polygon(new Geo.Geometry.LinearRing([pointLB,pointRB,pointRM,pointMT,pointRT,pointLT,pointLB]));
			}
		}
		return polygon;
	},
	
	/**
	 * Method: _onQueryComplete
	 */
	_onQueryComplete: function(result) {
		if(Geo.Util.isArray(result.features)) {
			if(result.features.length <= 0 ) {   
			   alert("没有数据!");   
			    return;   
			}
			this.geoJSON(result.features);
		}
	},
	
//	/**
//	 * Method: _onResize
//	 * TODO:改变地图窗口大小的时候，执行本方法，目前暂未注册事件
//	 */
//	_onResize: function(extent, width, height) {
//      if (this.osmb) {
//        this.osmb.setSize(width,height );
//        this.osmb.render();
//      };
//    },
	
	/**
	 * APIMethod: loadData
	 * json {String} 加载本地json数据
	 */
	loadData: function(json) {
		if(!(typeof this.url === "string")) {
			var json = this.format.read(json);
		
			this.features = json.features;
			var zoom = this.zoomOffset +  this.map.getZoom();
			if(this.features && this.features.length > 0 && this.maxLevel >= zoom && this.minLevel <= zoom) {
				this.geoJSON(json.features);
			}
		}
	},
	
	/**
	 * Method: geoJSON
	 * features {Array(Geo.Feature.Vector)} 要素集合
	 */
	geoJSON: function(features) {
		var oids = {};
		var jfs = [];
		this._oids = {};
		for (var i = 0; i < features.length; i++) {
			var f = features[i];
			var gj = {
				"type": "Feature",
				"geometry": {
					"type": "Polygon",
					"coordinates": f.geometry.rings
				},
				"properties": {
					"height": f.attributes[this.heightAttribute] * this.heightScaleRatio+40,//parseInt(f.attributes["OID"]/100+2000),//f.attributes["hgt"],//
					"isNew":1
				}
			}
			jfs[i] = gj;
		}
		this.osmb.setData({
			"type": "FeatureCollection",
			"features": jfs
		});
    },
	
	/**
	 * Method: setOrigin
	 */
    setOrigin: function() {
        var origin = this.map.getLonLatFromPixel(new Geo.Pixel(0, 0)),
            res = this.map.resolution,
            ext = this.maxExtent,
            x = Math.round((origin.lon - ext.left) / res),
            y = Math.round((ext.top - origin.lat) / res);
        this.osmb.setOrigin(x, y);
    },
	
	/**
	 * APIMethod: setMap
	 * map {Geo.View2D.Map} 
	 */
    setMap: function(map) {
		
        if (!this.map) {
            Geo.View2D.Layer.prototype.setMap.call(this, map);
        }

        if (!this.osmb) {
            this.osmb = new OSMBuildings();
            this.container = this.osmb.appendTo(this.div);
        }
	//	this._loadData();
		
        this.osmb.setSize(this.map.size.w, this.map.size.h);
		
        this.osmb.setZoom(this.map.zoom);
		
        this.setOrigin();
		
		this.map.events.register("zoomend", this, this._zoomend);
		//注册地图移动等事件
		this.map.events.register("moveend", this, this._moveend);
    },
	
	_zoomend: function() {
		if(typeof this.url === "string") {
			var extent = this.map.getExtent();
			//在指定级别范围内查询
			if(this.maxLevel >= this.map.getZoom() && this.minLevel <= this.map.getZoom()) {
			//	this._loadData();
			}
		}else if(this.url === undefined || this.url === null) {
			var zoom = this.zoomOffset +  this.map.getZoom();
			if(this.features && this.features.length > 0 && this.maxLevel >= zoom && this.minLevel <= zoom) {
				this.geoJSON(this.features);
			}
		} 
	},
	
	/**
	 * Method: _moveend
	 */
	_moveend: function(zoomChanged) {
	},
	
	/**
	 * Method: removeMap
	 * 
	 */
    removeMap: function(map) {
		this.map.events.unregister("zoomend", this, this._zoomend);
		//注册地图移动等事件
		this.map.events.unregister("moveend", this, this._moveend);
        this.container.parentNode.removeChild(this.container);
		this.osmb = null;
		this.query = null;
		this.mapServiceQuery = null;
		this.format = null;
        Geo.View2D.Layer.prototype.removeMap.call(this, map);
    },
	
	/**
	 * APIMethod: onMapResize
	 * 地图容器大小改变。当地图容器大小发生改变时，调用此方法调整3D楼块数据的位置。
	 */
    onMapResize: function() {
        Geo.View2D.Layer.prototype.onMapResize.call(this);
        this.osmb.onResize({ width: this.map.size.w, height: this.map.size.h });
    },

	/**
	 * Method: moveTo
	 */
    moveTo: function(bounds, zoomChanged, dragging) {
        var result = Geo.View2D.Layer.prototype.moveTo.call(this, bounds, zoomChanged, dragging);
        if (!dragging) {
            var
                offsetLeft = parseInt(this.map.layerContainerDiv.style.left, 10),
                offsetTop  = parseInt(this.map.layerContainerDiv.style.top, 10)
            ;
            this.div.style.left = -offsetLeft + 'px';
            this.div.style.top  = -offsetTop  + 'px';
        }

        this.setOrigin();
        this.dxSum = 0;
        this.dySum = 0;
        this.osmb.setCamOffset(this.dxSum, this.dySum);
		var zoom = this.zoomOffset +  this.map.getZoom();
		if (zoomChanged) {
	        this.osmb.onZoomEnd({ zoom: zoom });
			if(this.maxLevel >= zoom && this.minLevel <= zoom) {
				//当this.FeatureExt不包含当前范围且级别未发生改变时，请求数据
				this._loadData();
			}
			
	    } else {
			var extent = this.map.getExtent();
			if(this.maxLevel >= zoom && this.minLevel <= zoom && this.featureExt && !this.featureExt.featureExt.containsBounds(extent)) {
				this._loadData();
			}
	        this.osmb.onMoveEnd();
	    }
        return result;
    },
	

	/**
	 * Method: moveByPx
	 */
    moveByPx: function(dx, dy) {
        this.dxSum += dx;
        this.dySum += dy;
        var result = Geo.View2D.Layer.prototype.moveByPx.call(this, dx, dy);
        this.osmb.setCamOffset(this.dxSum, this.dySum);
        this.osmb.render();
        return result;
    },

    // TODO: refactor these ugly bindings
	/**
	 * APIMethod: setStyle
	 * 设置房屋样式。
	 * 
	 * style - {Object}
	 * 	roofColor - {String} 屋顶颜色
	 * 	wallColor - {String} 围墙颜色（左右方向颜色）
	 * 示例：
	 * (code)
	 * osmb.setStyle({
	 * 		roofColor: "#ecf4ff", //屋顶颜色
	 * 		wallColor: "#ffec7e"  //围墙颜色
	 * });
	 * (end)
	 */
    setStyle: function(style) {
        this.osmb.setStyle(style);
        return this;
    },
	
	/**
	 * APIMethod: setDate
	 * 根据时间点设置房屋阴影。
	 * 
	 * Parameters:
	 * date - {Date} 某一天的时间点
	 * 示例：
	 * (code)
	 * 	osmb.setDate(new Date("2013-6-10 22:00:00"));
	 * (end)
	 */
    setDate: function(date) {
        this.osmb.setDate(date);
        return this;
    },
	
  	CLASS_NAME: 'Geo.View2D.Layer.Buildings'
	
});/**
 * Class: Geo.View2D.Layer.GeoThematicLayer
 * 专题图图层类。该类的实例用于渲染专题图数据。
 *
 * Inherits from:
 *  - <Geo.View2D.Layer.Vector>
 */
Geo.View2D.Layer.GeoThematicLayer = Geo.Class(Geo.View2D.Layer.Vector, {
    
    /**
      * Property: loaded
      * {Boolean} Flag for whether the GML data has been loaded yet.
      */
    loaded: false,

    /**
      * Property: format
      * {<OpenLayers.Format>} The format you want the data to be parsed with.
      */
    format: null,

    /**
     * Property: formatOptions
     * {Object} Hash of options which should be passed to the format when it is
     * created. Must be passed in the constructor.
     */
    formatOptions: null,

    /**
     * APIProperty: gmlUrl
     * {String} 专题图数据文件路径。
     */
    gmlUrl: null,

    /**
     * APIProperty: styleUrl
     * {String} 专题图数据样式文件路径。
     */
    styleUrl: null,

    /**
     * Constructor: Geo.View2D.Layer.GeoThematicLayer
     * 创建一个专题图图层。
     *
     * Parameters:
     * name - {String} 图层名称。
     * options - {Object} 参数选项。
     *   gmlUrl {String} (必选) 专题图数据文件路径。
     *   styleUrl {String} (必选) 专题图数据样式文件路径。
     *   该文件包含专题图数据的样式，例如在PolygonRendition属性下，包含以下样式：
     * (code)
     *   { "Type": "polygon",//类型
     *     "FillColor": "#657800",//填充颜色
     *     "FillOpacity": "1",//填充色透明度
     *     "StrokeColor": "#000000",//边框颜色
     *     "StrokeOpacity": "1",//边框颜色透明度
     *     "StrokeWidth": "1"//边框宽度
     *   }
     * (end)
     */
     initialize: function(name, options) {
        var newArguments = [];
        newArguments.push(name, options);
        Geo.View2D.Layer.Vector.prototype.initialize.apply(this, newArguments);
    },

    /**
     * APIMethod: setVisibility
     * 设置是否显示该图层。
     *  
     * Parameters:
     * visible - {Boolean} 是否显示。
     */
    setVisibility: function(visibility) {
        Geo.View2D.Layer.Vector.prototype.setVisibility.apply(this, arguments);
        if(this.visibility && !this.loaded){
            // Load the GML
            this.loadGML();
        }
    },

    /**
     * Method: moveTo
     * If layer is visible and GML has not been loaded, load GML, then load GML
     * and call Geo.View2D.Layer.Vector.moveTo() to redraw at the new location.
     * 
     * Parameters:
     * bounds - {Object} 
     * zoomChanged - {Object} 
     * minor - {Object} 
     */
    moveTo:function(bounds, zoomChanged, minor) {
        Geo.View2D.Layer.Vector.prototype.moveTo.apply(this, arguments);
        // Wait until initialisation is complete before loading GML
        // otherwise we can get a race condition where the root HTML DOM is
        // loaded after the GML is paited.
        // See http://trac.openlayers.org/ticket/404
        if(this.visibility && !this.loaded){
            this.loadGML();
        }
    },

    /**
     * Method: loadGML
     */
    loadGML: function() {
        if (!this.loaded) {
            this.events.triggerEvent("loadstart");
            OpenLayers.Request.GET({
				//async: false,
                url: this.gmlUrl,
                success: this.requestSuccess,
                failure: this.requestFailure,
                scope: this
            });
            this.loaded = true;
        }    
    },    
    
    /**
     * Method: setUrl
     * 改变GML文件路径，重新加载。
     *
     * Parameters:
     * url - {String} 文件路径。
     */
    setUrl:function(url) {
        this.gmlUrl = url;
        this.destroyFeatures();
        this.loaded = false;
        this.loadGML();
    },
    
    /**
     * Method: requestSuccess
     * 请求GML文件成功回调函数。
     *
     * Parameters:
     * request - {String} 
     */
    requestSuccess:function(request) {
        var doc = request.responseXML;
        
        if (!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        
        var options = {};
        
        OpenLayers.Util.extend(options, this.formatOptions);
        if (this.map && !this.projection.equals(this.map.getProjectionObject())) {
            options.externalProjection = this.projection;
            options.internalProjection = this.map.getProjectionObject();
        }    
        
        var gml = this.format ? new this.format(options) : new OpenLayers.Format.GML(options);
		var features = gml.read(doc);
		
		if(this.styleUrl){
			//获取样式
	        OpenLayers.Request.GET({
	            async: false,
	            url: this.styleUrl,
	            success: function(result){
	                var jsonParser = new OpenLayers.Format.JSON();
	                this.thematicStyle = jsonParser.read(result.responseText);
	            },
	            failure: function(request){
	                alert("加载专题图样式文件 " + this.styleUrl + " 出现错误。");
				},
	            scope: this
	        });
		}
		//设置样式
		this.setThematicFeaturesStyle(features, this.thematicStyle);
		
        this.addFeatures(features);
		this.addThematicLegend();
        this.events.triggerEvent("loadend");
    },
    
    /**
     * Method: requestFailure
     * 请求GML文件失败回调函数。
     *
     * Parameters:
     * request - {String} 
     */
    requestFailure: function(request) {
        OpenLayers.Console.userError(OpenLayers.i18n("errorLoadingGML", {'url':this.gmlUrl}));
        this.events.triggerEvent("loadend");
    },
	
    /**
     * Method: setThematicFeaturesStyle
     * 设置专题图要素的样式。
     *
     * Parameters:
     * features - {<Geo.Feature.Vector>} 专题图要素。
     * thematicStyle - {Object} 样式对象。
     */
	setThematicFeaturesStyle: function(features, thematicStyle) {
		if(!thematicStyle){
			return;
		}
		var propertyName = thematicStyle.Renditions.PropertyRendition.PropertyName;
		var rangeValueRules = thematicStyle.Renditions.PropertyRendition.RangeValueRule;
		
        for (var i = 0; i < features.length; i++) {
			var style = {};
			var propertyRange = features[i].attributes[propertyName];
			for (var j = 0; j < rangeValueRules.length; j++) {
				var bottomValue = Number(rangeValueRules[j].BottomValue);
				var topValue = Number(rangeValueRules[j].TopValue);
				//判断属性值的取值区间，并获取样式。
                if (((rangeValueRules[j].IncludeBottom && bottomValue == propertyRange) || bottomValue < propertyRange) && 
				((rangeValueRules[j].IncludeTop && topValue == propertyRange) || propertyRange < topValue)) {
					style = {
						fillColor: rangeValueRules[j].PolygonRendition.FillColor,
						fillOpacity: Number(rangeValueRules[j].PolygonRendition.FillOpacity),
						strokeColor: rangeValueRules[j].PolygonRendition.StrokeColor,
						strokeOpacity: Number(rangeValueRules[j].PolygonRendition.StrokeOpacity),
						strokeWidth: Number(rangeValueRules[j].PolygonRendition.StrokeWidth)
					}
					break;
                }
			}
        	features[i].style = style;
        }
    },
	
    /**
     * Method: addThematicLegend
     * 添加专题图图例。
     */
	addThematicLegend: function() {
        if (!this.thematicStyle || !this.map) {
            return;
        }
		var div = document.createElement("DIV");
		this.thematicLegendDIV = div;
		div.id = "pieLegendContainer";
		div.style.position = "absolute";
		div.style.zIndex = "1000";
		div.style.right = "5px";
		div.style.bottom = "5px";
		div.style.border = "#15589a 1px solid";
		div.innerHTML = '<div id="legendTitle"><span>图例</span></div><div id="legendContent"></div>';
		this.map.viewPortDiv.appendChild(div);
		document.getElementById("legendContent").innerHTML = '';
		var rangeValueRules = this.thematicStyle.Renditions.PropertyRendition.RangeValueRule;
		for (var i = 0; i < rangeValueRules.length; i++) {
	        document.getElementById("legendContent").innerHTML += '<div class="legend-item">' +
	        '<span class="legend-color" style="background-color: ' + rangeValueRules[i].PolygonRendition.FillColor + ';"></span>' +
            '<span class="legend-itemName">' + rangeValueRules[i].BottomValue + ' - ' + rangeValueRules[i].TopValue + '</span></div>';
		}
	},
	
    /**
     * Method: removeThematicLegend
     * 删除专题图图例。
     */
	removeThematicLegend: function() {
		if (!this.map) {
            return;
        }
		if(this.map.viewPortDiv){
			this.map.viewPortDiv.removeChild(this.thematicLegendDIV);
		}
		this.thematicLegendDIV.innerHTML = "";
		this.thematicLegendDIV = null;
	},
	
    CLASS_NAME: "Geo.View2D.Layer.GeoThematicLayer"
});
﻿/**
 * Class: Geo.View2D.Layer.HeatMapLayer
 * 热图图层类，继承自Geo.View2D.Layer类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 *
 * Inherits from:
 *  - <Geo.View2D.Layer>
 */
Geo.View2D.Layer.HeatMapLayer = Geo.Class(Geo.View2D.Layer, {
	
	/**
	 * Property: heatmap
	 * {Object} 热图对象。
	 */
    heatmap: null,
	
	/**
	 * Property: tmpData
	 * {Object} 保存的数据。
	 */
    tmpData: null,
	
	/**
	 * APIProperty: heatmapOptions
	 * {Object} 热图参数对象。
     * 	 visible {Boolean} 最大数量。
     *   radius {Number} 半径数值。
     *   legend {Object} 图例选项。需要图例则设置，不需要图例不用设置。
     *   gradient {Object} 渐变的颜色。
     *   
	 */
	heatmapOptions: null,
	
	/**
     * Constructor: Geo.View2D.Layer.HeatMapLayer
     * 创建热图图层对象实例。
     *
     * Parameters:
     * name - {String} 图层名称。
     * options - {Object} 对象构造参数。
     */
    initialize: function(name, options){
        Geo.View2D.Layer.prototype.initialize.apply(this, [name, options]);
	},
	
    /** 
     * Method: setMap
     * 设置地图对象。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map){
        Geo.View2D.Layer.prototype.setMap.apply(this, arguments);
		
        var heatdiv = document.createElement("div");
		heatdiv.style.cssText = "position:absolute;width:" + this.map.size.w + "px;height:" + this.map.size.h + "px;";
        // this will be the heatmaps element
        this.div.appendChild(heatdiv);
        // add to our heatmap.js config
        this.heatmapOptions.element = heatdiv;
        this.heatmapOptions.map = map;
        // create the heatmap with passed heatmap-options
        this.heatmap = h337.create(this.heatmapOptions);
		
        // on zoomend and moveend we have to move the canvas element and redraw the datapoints with new positions
        this.map.events.on({
            "zoomend": this.updateLayer,
            "moveend": this.updateLayer,
            scope: this
        });
		//this.map.events.register("zoomend", this, this.updateLayer);
    },

    /** 
     * Method: updateLayer
     */
    updateLayer: function(){
		if (this.tmpData && this.tmpData.max) {
			var pixelOffset = this.getPixelOffset();
			var el = this.heatmap.get('element');
			// if the pixeloffset e.g. for x was positive move the canvas element to the left by setting left:-offset.y px 
			// otherwise move it the right by setting it a positive value. same for top
			el.style.top = ((pixelOffset.y > 0) ? ('-' + pixelOffset.y) : (Math.abs(pixelOffset.y))) + 'px';
			el.style.left = ((pixelOffset.x > 0) ? ('-' + pixelOffset.x) : (Math.abs(pixelOffset.x))) + 'px';
			
			this.setDataSet(this.tmpData);
		}
    },
	
    /** 
     * Method: getPixelOffset
     */
    getPixelOffset: function(){
        var o = this.map.layerContainerOrigin, o_lonlat = new OpenLayers.LonLat(o.lon, o.lat), o_pixel = this.getViewPortPxFromLonLat(o_lonlat), c = this.map.center, c_lonlat = new OpenLayers.LonLat(c.lon, c.lat), c_pixel = this.getViewPortPxFromLonLat(c_lonlat);
        
        return {
            x: o_pixel.x - c_pixel.x,
            y: o_pixel.y - c_pixel.y
        };
        
    },
	
    /** 
     * APIMethod: setDataSet
     * 设置数据集。
     * 
     * Parameters:
     * obj - {Object} 
     * 	 max {Number} (必选) 最大数量。
     *   data {Object} (必选) 数据。例如：[{lat: 33.5363, lon:-117.044, count: 1},{lat: 33.5608, lon:-117.24, count: 1}]
     */
    setDataSet: function(obj){
        var set = {}, dataset = obj.data, dlen = dataset.length, entry, lonlat, pixel;
        
        set.max = obj.max;
        set.data = [];
        // get the pixels for all the lonlat entries
        while (dlen--) {
            entry = dataset[dlen];
			lonlat = entry.lonlat.clone().transform(this.projection, this.map.getProjectionObject());
			pixel = this.roundPixels(this.getViewPortPxFromLonLat(lonlat));
            
            if (pixel) {
                set.data.push({
                    x: pixel.x,
                    y: pixel.y,
                    count: entry.count
                });
            }
        }
        this.tmpData = obj;
        this.heatmap.store.setDataSet(set);
    },
	
    /**
     * Method: roundPixels
     */
    roundPixels: function(p){
        if (p.x < 0 || p.y < 0) {
            return false;
        }
        
        p.x = (p.x >> 0);
        p.y = (p.y >> 0);
        
        return p;
    },
	
    /**
     * Method: addDataPoint
     */
    addDataPoint: function(lonlat){
        var pixel = this.roundPixels(this.getViewPortPxFromLonLat(lonlat));
        var entry = {
            lonlat: lonlat
        };
		var args;
        
        if (arguments.length == 2) {
            entry.count = arguments[1];
        }
        
        this.tmpData.data.push(entry);
        
        if (pixel) {
            args = [pixel.x, pixel.y];
            
            if (arguments.length == 2) {
                args.push(arguments[1]);
            }
            this.heatmap.store.addDataPoint.apply(this.heatmap.store, args);
        }
        
    },
	
    /**
     * APIMethod: toggle
     * 显示或隐藏热图。
     */
    toggle: function(){
        this.heatmap.toggleDisplay();
    },
	
    /**
     * APIMethod: toggleLegend
     * 显示或隐藏热图图例。
     */
    toggleLegend: function(){
        if (this.heatmap.get("legend")) {
            var display = this.heatmap.get("legend").getElement().style.display;
            if (display == "" || display == "block") {
                this.heatmap.get("legend").getElement().style.display = "none";
            }
            else {
                this.heatmap.get("legend").getElement().style.display = "block";
            }
        }
    },
	
    /**
     * APIMethod: destroy
     * 销毁该对象。
     */
    destroy: function(){
		//清除热图数据。
		this.heatmap.cleanup();
		if(this.map && this.heatmap.get("legend")){
			this.map.viewPortDiv.removeChild(this.heatmap.get("legend").getElement());
		}
		
		//取消事件监听。
		this.map.events.un({
            "zoomend": this.updateLayer,
            "moveend": this.updateLayer,
            scope: this
        });
        Geo.View2D.Layer.prototype.destroy.apply(this, arguments);
    },
	
    CLASS_NAME: "Geo.View2D.Layer.HeatMapLayer"
});
/**
 * Class: Geo.View2D.Layer.ThematicTile
 * 基于专题图服务的专题图图层。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Grid>
 */
Geo.View2D.Layer.ThematicTile = OpenLayers.Class(OpenLayers.Layer.Grid, {
	
	/**
     * Constant: DEFAULT_PARAMS
     * {Object} 默认键值对的Hashtable 
     */
    DEFAULT_PARAMS: {
		version: "1.0.0",
		format: "jpeg"
	},
	
	/**
     * APIProperty: version
     * {String} 服务版本。
     */
	version:"1.0.0",

	/**
     * APIProperty: layerID
     * {String} 图层ID。
     */
	layerID: null,
	
	/**
     * APIProperty: chartID
     * {String} 专题符号标识。
     */
	chartID: null,
	
	/**
     * APIProperty: maxExtent
     * {Geo.Bounds} 图层的最大范围。
     */
	maxExtent: null,
	
	/**
     * APIProperty: format
     * {String} 图片样式。
     */
	format: "png",
	
	/**
     * APIProperty: colorSchemeID
     * {String} 色卡标识。
     */
	colorSchemeID: null,
	
	/**
	 * APIProperty: hasLegend
	 * {Boolean} 是否显示图例，默认值为true。
	 */
	hasLegend: true,
	
	/**
	 * APIProperty: legendSize
	 * {Geo.Size} 图例的宽高。
	 */
	legendSize: new Geo.Size(250,250),
	
	/**
	 * APIProperty: legendPosition     
	 * {String} 图例显示方位，默认为右下角。左上角：tl、左下角：bl、右上角：tr、右下角：br。
	 */
	legendPosition:"br",
	
	/**
	 * APIProperty: hasEdge
	 * {Boolean} 是否绘制专题图符号的边线，默认值为true。
	 */
	hasEdge: true,
	
	/**
	 * APIProperty: hasLabel
	 * {Boolean} 是否绘制专题图符号的标注，默认值为true。
	 */
	hasLabel: true,
	
	/**
	 * Property: vectorLayer
	 * {String} 示例图层。
	 */
	vectorLayer: null,
	
	/**
	 * APIProperty: thematicTipsListeners
	 * {Object}鼠标移入移出专题图数据时的事件监听。可自定义featureout、featureover事件监听的函数实现。实现专题图数据的自定义鼠标交互功能。
	 */
	thematicTipsListeners: null,
	
	/**
	 * APIProperty: featureoverCallback
	 * 鼠标经过要素时的回调,如果用户需要自定义专题图提示功能，则需要覆盖本方法
	 */
	featureoverCallback: null,
	
	/**
	 * APIProperty: featureoutCallback
	 * 鼠标移除要素时的回调,如果用户需要自定义专题图提示功能，则需要覆盖本方法
	 */
	featureoutCallback: null,
	
	//TODO:控制瓦片的请求级别，通过图层的最大范围来控制显示级别。
	/**
	 * Constructor: Geo.View2D.Layer.ThematicTile
     * 创建一个专题图图层。
     *
     * Parameters:
     * name - {String} 图层名称。
     * url - {String} 专题图服务地址。
     * params - {Object} 本项目前暂不使用。
     * options - {Object} 对象构造参数。
     * > layerID -  {String} 图层ID。
	 * > hasLegend - {Boolean} 是否显示图例。
	 * > hasEdge - {Boolean} 是否绘制专题图符号的边线。
	 * > hasLabel - {Boolean} 是否绘制专题图符号的标注。
	 * > chartID - {String} 专题符号标识。 
	 * > thematicTipsListeners - {Object} 实现专题图提示的相关事件
	 * 
	 * Examples:
	 * (code)
	 * 	//添加专题图图层
	 *		var thmatic = new Geo.View2D.Layer.ThematicTile("t",Cfg.map2DThematicUrl_JS,{},{
 	 *			layerID: Cfg.map2DThematicLayerID_JS,
	 *			hasLegend: Cfg.map2DThematicHasLegend_JS,
	 *			chartID:Cfg.map2DThematicchartID_JS,
	 *			//鼠标移入移出专题图数据时的事件监听
	 *			thematicTipsListeners:{
	 *				//鼠标移出事件
	 *				featureout:function(e) {
	 *					e.feature.style.fillOpacity = 0;
	 *					e.feature.style.strokeOpacity = 0;
	 *					thmatic.vectorLayer.drawFeature(e.feature);
	 *					var popups = map.popups;
	 *					for(var i = 0;i < popups.length;i++) {
	 *						map.removePopup(popups[i]);
	 *					}
	 *				},
	 *				//鼠标移入事件
	 *				featureover:function(e) {
	 *	               	var popups = map.popups;
	 *					for(var i = 0;i < popups.length;i++) {
	 *						map.removePopup(popups[i]);
	 *					}
	 *					var text = e.feature.attributes.text;
	 *					var center = e.feature.geometry.getCentroid();	
	 *					e.feature.style.fillOpacity = 0.7;
	 *					e.feature.style.strokeOpacity = 0.7;
	 *					thmatic.vectorLayer.drawFeature(e.feature);
	 *					var popup = new OpenLayers.Popup.FramedCloud("", 
     *		 	                new Geo.LonLat(center.x,center.y),null,text,null, false);
	 *					map.addPopup(popup);
	 *	            }
	 *			},
	 *			maxExtent: Geo.Bounds.fromString(Cfg.map2DThematic_maxExtent_JS)
	 *		});
	 * (end)
	 */
	initialize: function(name, url, params, options) {
        var newArguments = [];
        //uppercase params
        params = OpenLayers.Util.upperCaseObject(params);
        if (parseFloat(params.VERSION) >= 1.3 && !params.EXCEPTIONS) {
            params.EXCEPTIONS = "INIMAGE";
        } 
        newArguments.push(name, url, params, options);
		this.singleTile = true;
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, newArguments);
        OpenLayers.Util.applyDefaults(
                       this.params, 
                       OpenLayers.Util.upperCaseObject(this.DEFAULT_PARAMS)
                       );

        //layer is transparent        
        if (!this.noMagic && this.params.TRANSPARENT && 
            this.params.TRANSPARENT.toString().toLowerCase() == "true") {
            
            // unless explicitly set in options, make layer an overlay
            if ( (options == null) || (!options.isBaseLayer) ) {
                this.isBaseLayer = false;
            } 
            
            // jpegs can never be transparent, so intelligently switch the 
            //  format, depending on the browser's capabilities
            if (this.params.FORMAT == "image/jpeg") {
                this.params.FORMAT = OpenLayers.Util.alphaHack() ? "gif"
                                                                 : "png";
            }
        }
		var featureoverCallback = this.featureoverCallback || 
		OpenLayers.Function.bind(function(e) {
					
															 
					var center = e.feature.geometry.getCentroid();										 
		//			var px2 = this.map.getLayerPxFromLonLat({
		//            lon: bounds.right,
		//            lat: bounds.bottom
		//        });
					
					if(this.timerId1 !== null) {
	            window.clearTimeout(this.timerId1);
	            this.timerId1 = null;
	        }
			
				//延迟4秒关闭
				this.timerId1 = window.setTimeout(
		            OpenLayers.Function.bind(function() {
		               	var popups = map.popups;
						for(var i = 0;i < popups.length;i++) {
							map.removePopup(popups[i]);
						}
						var text = e.feature.attributes.text;
						var center = e.feature.geometry.getCentroid();	
						e.feature.style.fillOpacity = 0.7;
						e.feature.style.strokeOpacity = 0.7;
						this.vectorLayer.drawFeature(e.feature);
						var popup = new OpenLayers.Popup.FramedCloud("", 
			                new Geo.LonLat(center.x,center.y),
			                null,
			                text,
			            null, false);
						map.addPopup(popup);
						this.couter++;
		            }, this),
		            200
		        )
				}, 
                this);
		
	var featureoutCallback = this.featureoutCallback ||
		OpenLayers.Function.bind(function(e) {
			e.feature.style.fillOpacity = 0;
			e.feature.style.strokeOpacity = 0;
			this.vectorLayer.drawFeature(e.feature);
			var popups = map.popups;
					for(var i = 0;i < popups.length;i++) {
						map.removePopup(popups[i]);
					}
			}, this);
			var eventListeners = this.thematicTipsListeners || {
				featureover: featureoverCallback,
				featureout: featureoutCallback
			};
			this.vectorLayer = new Geo.View2D.Layer.Vector("hotArea", {
				maxExtent : this.maxExtent,
				eventListeners: eventListeners
			});
			this.jsonp = new OpenLayers.Protocol.Script();
			//图层开始加载的时候清除数据
			this.events.on({
		        "moveend": OpenLayers.Function.bind(this.updateHotArea, 
	                this)
		    });
    },
	
	/**
	 * Method: setOpacity
	 * 设置图例专题图例透明度
	 * 
	 * opacity {Number} 透明度
	 */
	setOpacity: function(opacity){
		OpenLayers.Layer.Grid.prototype.setOpacity.apply(this, [opacity]);
		//TODO：图例的透明度,没有经过测试
		if ( this.imageLegend && this.imageLegend.parentNode) {
			OpenLayers.Util.modifyDOMElement(this.imageLegend, null, null, null, 
                                                 null, null, null, opacity);
		}
	},
	
	/**
	 * Method: display
	 * 设置图例可见性。
	 * 
	 * display {Boolean} 是否可见。
	 */
	display: function(display){
		OpenLayers.Layer.Grid.prototype.display.apply(this, [display]);
		//TODO:增加对图例可见性的设置,没有经过测试
		if (this.imageLegend && this.imageLegend.parentNode) {
			 if (display != (this.div.style.display != "none")) {
				this.imageLegend.style.display = display;
	        }
		}
	},
	
	/**
	 * Method: getLegend
	 * 得到图例。
	 * 
	 * options {Object} 可选项。
	 */
	getLegend: function(options) {
		//http://192.168.42.76:7021/ThematicMapService/tms/legend/0/020101.png?ColorSchemaID=3
		var location = this.url.indexOf("/",this.url.length - 1);
		if(location != -1) {
			this.url = this.url.substr(0,this.url.length - 1);
		}
		var path =  "${url}/legend/${layerID}/${chartID}.${format}";//?colorSchemaID = ${colorSchemaID}
		path = Geo.String.format(path, {
			'url': this.url, 
			'layerID': options.layerID, 
			'chartID': options.chartID,
			'format': options.format || "png"
		});
		if(typeof options.colorSchemeID === "string") {
			path += ("?colorSchemeID=" + options.colorSchemeID);
		}
		return path;
	},
	
	/**
	 * Method: showLegend
	 * 显示图例。
	 * 
	 * TODO:属性中需要增加图例的显示方位，显示大小。
	 */
	showLegend: function() {
		var path = this.getLegend({
			layerID:this.layerID,
			chartID:this.chartID,
			ColorSchemeID: this.ColorSchemeID
		});
		//(id, px, sz, imgURL, position, border,opacity, delayDisplay)
		if(!this.imageLegend) {
			this.imageLegend = Geo.Util.createImage(this.id,new Geo.Pixel(0,0),this.legendSize,path);
			this.imageLegend.style.zIndex = this.map.Z_INDEX_BASE['Popup'];
			this.setLegendLocation(this.imageLegend);
			this.map.viewPortDiv.appendChild(this.imageLegend);
		}
	},
	
	/**
	 * Method: setLegendLocation
	 * 设置图例位置
	 * TODO:属性中需要增加图例的显示方位，显示大小。
	 * imageLegend  {DOM}
	 */
	setLegendLocation: function(imageLegend) {
		var size = this.map.getSize();
		switch(this.legendPosition) {
			case "br": 
				var x = size.w - this.legendSize.w;
				var y = size.h - this.legendSize.h;
				imageLegend.style.left = x+"px";
				imageLegend.style.top = y+"px";
			break;
			case "bl":
				var y = size.h - this.legendSize.h;
				imageLegend.style.left = 0+"px";
				imageLegend.style.top = y+"px";
			break;
			case "tl":
				imageLegend.style.left = 0+"px";
				imageLegend.style.top = 0+"px";
			break;	
			case "tr":
				var x = size.w - this.legendSize.w;
				imageLegend.style.left = x+"px";
				imageLegend.style.top = 0+"px";
			break;
		}
	},
	
	/**
	 * Method: updateHotArea
	 * 更新热区。
	 * obj  {Geo.Events}
	 */
	updateHotArea: function(obj) {
		if(obj.zoomChanged) {
			this.vectorLayer.removeAllFeatures();
		}else {
			this.vectorLayer.redraw();
		}
		
		
	},

    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Returns:
     * {<OpenLayers.Layer.WMS>} An exact clone of this layer
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new Geo.View2D.Layer.ThematicTile(this.name,
                                           this.url,
                                           this.params,
                                           this.getOptions());
        }

        //get all additions from superclasses
        obj = OpenLayers.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },    
	
    
    /**
     * Method: getURL
     * Return a GetMap query string for this layer
     *
     * Parameters:
     * bounds - {<OpenLayers.Bounds>} A bounds representing the bbox for the
     *                                request.
     *
     * Returns:
     * {String} A string with the layer's url and parameters and also the
     *          passed-in bounds and appropriate tile size specified as 
     *          parameters.
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);
        var imageSize = this.getImageSize();
//		this.getTileFeature(bounds,imageSize);
        var newParams = {};
		//http://192.168.42.76:7021/ThematicMapService/tms/map/0/020101/
		//87.6061172485352/20.0317935943604/126.643341064453/45.7414932250977/1024/1024.png?
		//ColorSchemaID=3&hasLegend=true&hasEdge=true&hasLabel=true
      	//var requestString = this.getFullRequestString(newParams);
		var url = "${url}/map/${layerID}/${chartID}/${left}/${bottom}/${right}/${top}/${width}/${height}.${format}?"+
		"hasLegend=${hasLegend}&hasEdge=${hasEdge}&hasLabel=${hasLabel}";
		url = OpenLayers.String.format(url, {
			'url': this.url,
			'layerID': this.layerID,
			'chartID': this.chartID,
			'left': bounds.left,
			'bottom': bounds.bottom,
			'right':bounds.right,
			'top': bounds.top,
			'width': imageSize.w,
			'height': imageSize.h,
			'format': this.format,
			'hasLegend':this.hasLegend,
			'hasEdge': this.hasEdge,
			'hasLabel': this.hasLabel,
			'colorSchemeID': this.colorSchemeID
		});
		if(typeof this.colorSchemeID === "string") {
			url += ("&colorSchemeID=" + this.colorSchemeID);
		}
		//&ColorSchemaID=${ColorSchemaID}
        return url;
    },
	
	/**
	 * Method: initSingleTile
	 * 请求单个瓦片。
	 * bounds -  {Geo.Bounds} 获取范围。
	 */
	initSingleTile: function(bounds){
		OpenLayers.Layer.Grid.prototype.initSingleTile.apply(this, 
                                                             arguments);
		var center = bounds.getCenterLonLat();
        var tileWidth = bounds.getWidth() * this.ratio;
        var tileHeight = bounds.getHeight() * this.ratio;
                                       
        var tileBounds = 
            new OpenLayers.Bounds(center.lon - (tileWidth/2),
                                  center.lat - (tileHeight/2),
                                  center.lon + (tileWidth/2),
                                  center.lat + (tileHeight/2));
  
        var px = this.map.getLayerPxFromLonLat({
            lon: tileBounds.left,
            lat: tileBounds.top
        });
		var px2 = this.map.getLayerPxFromLonLat({
            lon: tileBounds.right,
            lat: tileBounds.bottom
        });
		var pixelsize = new Geo.Size((px2.x - px.x),(px2.y - px.y));
		if(this.timerId !== null) {
            window.clearTimeout(this.timerId);
            this.timerId = null;
        }
		
		//延迟4秒关闭
		this.timerId = window.setTimeout(
            OpenLayers.Function.bind(function() {
               this.getTileFeature(tileBounds,pixelsize);
            }, this),
            80
        )													 
		
	},
	
	/**
	 * Method: getTileFeature
	 * 得到与瓦片相对应的要素。
	 * bounds -  {Geo.Bounds} 获取范围。
	 * mapSize -  {Geo.Size} 地图范围。
	 */
	getTileFeature: function(bounds,mapSize) {
		var url = "${url}/hotarea/${layerID}/${chartID}/${left}/${bottom}/${right}/${top}/${width}/${height}?f=json";
		url = OpenLayers.String.format(url, {
			'url': this.url,
			'layerID': this.layerID,
			'chartID': this.chartID,
			'left': bounds.left,
			'bottom': bounds.bottom,
			'right':bounds.right,
			'top': bounds.top,
			'width': mapSize.w,
			'height': mapSize.h
		});
		this.jsonp.createRequest(url,null, OpenLayers.Function.bind(function(result) {
			var failFn = failFn || this.failFn;
			if(result.error) {
				failFn(result.error);
				return;
			}
			var hotAreas = result.HotAreas;
			var features = [];
			if(hotAreas) {
				var polygonstyle = Geo.Util.extend({},OpenLayers.Feature.Vector.style['default']);
				polygonstyle.fillOpacity = 0;
				polygonstyle.strokeOpacity = 0;
				for(var i = 0,len = hotAreas.length; i < len; i++) {
					polygonstyle.text = hotAreas[i].text;
					var f = new Geo.Feature.Vector(this._getGeometry(hotAreas[i].geometry,bounds,hotAreas[i].text),polygonstyle,polygonstyle);
					features.push(f);
				}
			}
			if(features.length > 0) {
				
				this.vectorLayer.removeAllFeatures();
				this.vectorLayer.addFeatures(features);
			}
			if(this.hasLegend) {
				this.showLegend();
			}
			//successFn();
		},this));
	},
	
	/**
	 * Method: _getGeometry
	 * 得到openlayers几何对象
	 * 
	 * Parameters:
	 * geometry - {Geo.Geometry} 几何对象。
	 * bounds - {Geo.Bounds} 地图范围。
	 * text - {String} 文字信息。
	 */
	_getGeometry: function(geometry,bounds,text) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
				//TODO:需要增加多点类型
			}else {
				var geometry = this._geometryType[pro].apply(this, [geometry[pro],bounds,text]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: convertPixelsToLonLats
	 * 像素转经纬度
	 * 
	 * Parameters:
	 * pixels - {Geo.Pixels} 像素。
	 * bounds - {Geo.Bounds} 地图范围。
	 */
	convertPixelsToLonLats: function(pixels,bounds) {
		var px = this.map.getLayerPxFromLonLat({
            lon: bounds.left,
            lat: bounds.top
        });
//		var res = this.map.getResolution();
//		var width = (px.x + pixels[0]) * res;
//		var height = (px.y + pixels[1]) * res;
		var px2 = this.map.getLayerPxFromLonLat({
            lon: bounds.right,
            lat: bounds.bottom
        });
		var pixelsize = new Geo.Pixel((px2.x - px.x),(px2.y - px.y));
		
	//	var size = this.map.getSize();
		var widLon = (pixels[0]/pixelsize.x)*(bounds.right -bounds.left);
		var widLat = (pixels[1]/pixelsize.y)*(bounds.bottom -bounds.top);
		
	//	var res = this.map.getResolution();
//		var lon = pixels[0]*res;
//		var lat = pixels[1]*res;
		return [bounds.left + widLon,bounds.top + widLat];
	},
	
	/**
	 * Method: 将几何信息的json表示转换成openlayers几何对象。
	 */		
	_geometryType: {
		"points": function(geometry,bounds,text) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var lonlat = this.convertPixelsToLonLats(geometry[i],bounds);
					var point = new OpenLayers.Geometry.Point(lonlat[0], lonlat[1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry,bounds,text) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						var lonlat = this.convertPixelsToLonLats(geometry[i][p],bounds);
						ps.push(new OpenLayers.Geometry.Point(lonlat[0],lonlat[1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry,bounds,text) {
			var lines = [];

			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						var lonlat = this.convertPixelsToLonLats(geometry[i][p],bounds);
						ps.push(new OpenLayers.Geometry.Point(lonlat[0],lonlat[1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var polygonstyle = Geo.Util.extend({},OpenLayers.Feature.Vector.style['default']);
				var Polygon = new OpenLayers.Geometry.Polygon(lines, null, polygonstyle);
			}
			
			
			return Polygon;
		}
	},
	
    /**
     * Method: mergeNewParams
     * Catch changeParams and uppercase the new params to be merged in
     *     before calling changeParams on the super class.
     * 
     *     Once params have been changed, the tiles will be reloaded with
     *     the new parameters.
     * 
     * Parameters:
     * newParams - {Object} Hashtable of new params to use
     */
    mergeNewParams:function(newParams) {
        var upperParams = OpenLayers.Util.upperCaseObject(newParams);
        var newArguments = [upperParams];
        return OpenLayers.Layer.Grid.prototype.mergeNewParams.apply(this, 
                                                             newArguments);
    },
	
	/**
     * Method: setMap
     *
     * Parameters:
     * map - {<OpenLayers.Map>} The map.
     */
    setMap: function(map) {
		OpenLayers.Layer.Grid.prototype.setMap.call(this, map);
		map.events.register('mousemove', this, OpenLayers.Function.bind(function(evt) {
			this._mouselonLatPosition = map.getLonLatFromPixel(evt.xy);
//			var _mouselonLatPosition = this._mouselonLatPosition;
//			var features = this.vectorLayer.features;
//			var count = 0;
//			for(var i = 0,len = features.length; i < len; i++ ) {
//				var isIntersect = features[i].geometry.intersects(new Geo.Geometry.Point(_mouselonLatPosition.Lon,_mouselonLatPosition.Lat));
//				if(!isIntersect) {
//					count++;
//				}
//				
//			}
//			if(count === features.length) {
//				if(this.timerId1 !== null) {
//            window.clearTimeout(this.timerId1);
//            this.timerId1 = null;
//			return;
//        }
//		
//		//延迟4秒关闭
//		this.timerId1 = window.setTimeout(
//		            OpenLayers.Function.bind(function() {
//		               	var popups = map.popups;
//						for(var i = 0;i < popups.length;i++) {
//							map.removePopup(popups[i]);
//						}
//		            }, this),
//		            2000
//		        )
//			}
		}, this));
		map.addLayer(this.vectorLayer);
    },
	
	/**
     * Method: removeMap
     * Called when the layer is removed from the map.
     *
     * Parameters:
     * map - {<OpenLayers.Map>} The map.
     */
    removeMap: function(map) {
		//清除要素（热区）
		this.vectorLayer.destroyFeatures(this.vectorLayer.features);
		//移除本图层
        OpenLayers.Layer.Grid.prototype.removeMap.call(this, map);
		for(var m = 0,len = map.layers.length; m < len;m++) {
			if(map.layers[m].id === this.vectorLayer.id) {
				//清除矢量图层
				map.removeLayer(this.vectorLayer);
				break;
			}
		}
		if (this.imageLegend && this.imageLegend.parentNode) {
			//移除图例
            this.imageLegend.parentNode.removeChild(this.imageLegend);
			this.imageLegend = null;
        }
		this.map.events.un({
	        "zoomend": this.updateHotArea
	    });
		this.jsonp.destroy();
    },

    /** 
     * Method: getFullRequestString
     * Combine the layer's url with its params and these newParams. 
     *   
     *     Add the SRS parameter from projection -- this is probably
     *     more eloquently done via a setProjection() method, but this 
     *     works for now and always.
     *
     * Parameters:
     * newParams - {Object}
     * altUrl - {String} Use this as the url instead of the layer's url
     * 
     * Returns:
     * {String} 
     */
    getFullRequestString:function(newParams, altUrl) {
        var mapProjection = this.map.getProjectionObject();
        var projectionCode = this.projection && this.projection.equals(mapProjection) ?
            this.projection.getCode() :
            mapProjection.getCode();
        var value = (projectionCode == "none") ? null : projectionCode;
        if (parseFloat(this.params.VERSION) >= 1.3) {
            this.params.CRS = value;
        } else {
            this.params.SRS = value;
        }
        
        if (typeof this.params.TRANSPARENT == "boolean") {
            newParams.TRANSPARENT = this.params.TRANSPARENT ? "TRUE" : "FALSE";
        }

        return OpenLayers.Layer.Grid.prototype.getFullRequestString.apply(
                                                    this, arguments);
    },

    CLASS_NAME: "Geo.View2D.Layer.ThematicTile"
});﻿﻿﻿﻿﻿﻿﻿﻿﻿/**
 * Class: Geo.View2D.Layer.GeoText
 * 文字图层，继承自Geo.View2D.Layer.Vector类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Vector>
 */
Geo.View2D.Layer.GeoText = Geo.Class(Geo.View2D.Layer.Vector,	{
	
	/**
     * Property: renderers
     * {Array(String)} 目前只支持canvas绘制
     */
    renderers: ['Canvas'],
	
	/**
	 * APIProperty: url
	 * {String} 文字服务地址。
	 */
	url: null,
	
	/**
	 * APIProperty: eachRowNumer
	 * {Number} 点要素的文字标注每行显示的文字个数。
	 */
	eachRowNumer: 4,
	
	/**
	 * APIProperty: isCustomStyle
	 * {Boolean} 是否使用自定义样式。默认为false,即使用服务提供的样式。
	 */
	isCustomStyle: false,
	
	/**
	 * APIProperty: layersStyle
	 * {Object} 值的类型为json对象，格式为：{key:value}，其中key的取值为文字服务Root接口中的dateTableName节点的值，
	 * value的取值为Geo.Feature.Vector类的Geo.Feature.Vector.style属性的键值。
	 * > 取值举例：
	 *  > {
	 *		> 		"中学4490":{
	 *		> 			pointRadius:6,
	 *		> 			fillOpacity:0.5,
	 *		> 			fillColor:"blue",
	 *		> 			strokeColor:"red",
	 *	    >             fontSize: "12px"
	 *		> 		}
	 *		> 	}
	 * 图层样式说明：
	 *   文字标注的样式支持情况：
	 *   >  文字名称：支持。此名称用户不可设置，由服务提供。
	 *   >  文字颜色：支持。请参考js SDK类参考中Geo.Feature.Vector类的Geo.Feature.Vector.style属性的键值:fontColor。
	 *   >  文字标注背景颜色：GeoGlobe 5.1不支持。
	 *   >  字体样式：支持。请参考js SDK类参考中Geo.Feature.Vector类的Geo.Feature.Vector.style属性的键值:fontStyle。
	 *   >  注意：字体样式目前只支持"正常"和"右斜"两种样式。目前不支持："左斜","左耸","右耸"。
	 *   >  字体样式倾斜角度：GeoGlobe 5.1不支持。
	 *   >  文字偏移：GeoGlobe 5.1不支持。
	 *   >  字体样式倾斜角度：GeoGlobe 5.1不支持。
	 *   >  文字是否有下划线：GeoGlobe 5.1不支持。
	 *   >  文字是否有删除下：GeoGlobe 5.1不支持。
	 *   >  文字是否为粗体：支持。请参考js SDK类参考中Geo.Feature.Vector类的Geo.Feature.Vector.style属性的键值:fontWeight。
	 *   >  背景是否透明：GeoGlobe 5.1不支持。
	 *   >  文字是否有光晕：GeoGlobe 5.1不支持。
	 * 	 >  文字是否有阴影：GeoGlobe 5.1不支持。
	 * 	 >  文字阴影颜色：GeoGlobe 5.1不支持。
	 *   >  文字阴影偏移方向：GeoGlobe 5.1不支持。
	 *   >  文字阴影偏移方向：GeoGlobe 5.1不支持。
	 *   >  字体宽高：支持。请参考js SDK类参考中Geo.Feature.Vector类的Geo.Feature.Vector.style属性的键值:fontSize。
	 *   >  文字垂直对齐方式：GeoGlobe 5.1不支持。
	 * 	 >  文字水平对齐方式：GeoGlobe 5.1不支持。
	 */
	layersStyle: null,
	
	/**
	 * APIProperty: isHideGlandFeatures
	 * {Boolean} 是否消隐(是否隐藏被压住的要素)
	 */
	isHideGlandFeatures: false,
	
	/**
	 * Property: isShowLine
	 * {Boolean} 是否消隐(是否隐藏被压住的要素)
	 */
	isShowLine: false,
	
	/**
	 * Property: lineLabelDefaultStyle
	 * {Boolean} 沿线文字的默认样式。当服务没有提供沿线文字的样式时，本属性才会生效。
	 */
	lineLabelDefaultStyle: {
		fontColor: "#000000",
		fontFamily: "宋体",
		fontOpacity: 1,
		fontSize: "16px"
	},
	
	/**
	 * Property: textFeatures
	 * {Array(Geo.Feature.Vector)} 沿线标注
	 */
	textFeatures: [],
	
	/**
     * Property: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	pyramid : null,
	
	/**
     * Property: isRotation
     * {Boolean} 是否旋转。
     */
	isRotation: false,
	
	/**
     * Property: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	positionIndex: 1,
	
	//保存已经绘制的要素，防止重复绘制
	/**
     * Property: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	drawFeatures: {},
	
	/**
	 * Property: isAvoidOuterMaxExtent
	 * {Boolean} 超出了图层最大范围的要素是否消隐，默认为true。
	 */
	isAvoidOuterMaxExtent: true,
	
	/**
	 * Property: currentFeatures
	 * {Array(Geo.Feature.Vector)} （消隐后）需要绘制的要素
	 */
	currentFeatures: null,
	
	/**
	 * Property: textCounter
	 * {Integer} 
	 */
	textCounter: 0,
	
	/**
	 * APIProperty: service
	 * {String} 服务类型。取值为TEXT。
	 */
	service:"TEXT",
	
	/**
	 *  Property: alongLineoffset
	 *  {Integer} 沿线文字的偏移
	 */
	alongLineoffset: null,
	
	/**
	 * APIProperty: labelCharSpace
	 * {Integer}单个字之间的距离（单位为像素）
	 */
	labelCharSpace: 9,
	
	/**
	 * Property: labelSpaceRadio
	 * {Integer}标签间的间隔系数（间隔距离与标签宽度的比）
	 */
	labelSpaceRadio:1,
	
	/**
	 * APIProperty: version
	 * {String} 文字服务版本。
	 */
	version:"1.0.0",
	
	/**
	 * APIProperty: layersID
	 * {Array(String)}图层id,取值方式：all/show/hide:1,2。
	 *	all表示请求文字服务所有的图层。
	 *	show取值举例：show:1,2，表示请求id为1,2的图层。
	 *	hide取值举例：hide:1,2，表示服务会请求图层id为1,2以外的图层。
	 */
	layersID: null,
	
	/**
	 * Property:directions
	 * {Array(String)} 标签方位
	 */
	directions:["rt","ct","cb","lt","rb","lb","rm","lm"],
	
	/**
	 * Property: avoidArea
	 * {Array(Geo.Bounds)}避让列表
	 */
	avoidArea: null,
	
    /**
     * Constructor: Geo.View2D.Layer.GeoText
     * 文字图层构造方法。
     *
     * Parameters:
     * name - {String} 图层名称。
     * options - {Object} 对象构造参数。类的公有属性可作为构造方法里options对象的选项。
     * 
     * Example:
     * (code)
     * 	var textLayer = new Geo.View2D.Layer.GeoText("text", {
	 *			url: "http://192.168.42.54:9010/test/Text",
	 *          //使用自定义样式时需设置本属性为true
	 *			isCustomStyle:true,
	 *			layersID: ("show:" + Cfg.geoTextService_layers),
	 *			service:"TEXT",
	 *			version: "1.0.0",
	 *          //在layersStyle属性中设置自定义样式
	 *			layersStyle: {
	                //"中学4490"为文字服务root接口中dataTableName节点的值。
	 *				"中学4490":{
	 *					pointRadius:6,
	 *					fillColor:"blue",
	 *					strokeColor:"red",
	 *	                fontSize: "12px"
	 *				}
	 *			},
	 *			//创建文字服务策略类
	 *			strategies: [new Geo.Strategy.GeoTextXYZ()]
	 *		});
     * (end)
     */	
	initialize: function(name,options) {
		options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		Geo.View2D.Layer.Vector.prototype.initialize.apply(this, arguments);
		
		if(!this.layersID && !this.url) {
			throw new Error("图层id或文字服务地址不能为空！");
		}
		//构造文字服务类
		var GeoText = new Geo.Service.GeoText("GeoText",this.url);
		//读取文字服务能力描述信息
		GeoText.getCapabilities(
		OpenLayers.Function.bind(function(result) {
			if(typeof this.layersID === "string" && this.layersID.length > 0) {
				var layer = this.layersID.split(":");
				if(layer.length > 1) {
					var layersArr = layer[1].split(",");
				}else if(layer.length === 1){
					var layersArr = layer[0].split(",");
				}
				
				var layersId = [];
				for(var i = 0; i < layersArr.length; i++) {
					layersId.push(parseInt(layersArr[i]));
				}
			}
			//根据图层id获取文字样式
			var layersStyle = GeoText.getTextStylesByLayerIds(result,layersId);
			var ops = {};
			ops.url = this.url;
			ops.isCustomStyle = this.isCustomStyle;
			//如果用户自定义了样式，并且设置自定义样式isCustomStyle=true,那么
			if(typeof options.layersStyle === "object" && options.isCustomStyle) {
				ops.layersStyle = options.layersStyle;
			}else {
				ops.layersStyle = layersStyle;
			}
			//设置自定义换行
			if(options.isCustomStyle) {
				ops.eachRowNumer = options.eachRowNumer || this.eachRowNumer;
			}
			
			//结果解析器
			this.formatFeatures = new Geo.Util.Format.GeoTextFeatures(ops);
		}, this));

//		var ops = {};
//		ops.url = this.url;
//		ops.isCustomStyle = this.isCustomStyle;
//		if(options && options.layersStyle) {
//			ops.layersStyle = options.layersStyle;
//		}
//		//结果解析器
//		this.formatFeatures = new Geo.Util.Format.GeoTextFeatures(ops);
		
		this.geoPreAvoidContainer = new Geo.Util.GeoPreAvoidContainer();
		this.events.on({
	        "moveend": OpenLayers.Function.bind(function() {
				if(this.timer !== null) {
		            window.clearInterval(this.timer);
		            this.timer = null;
		        }
			}, this)
	    });
	},
	
	/**
	 * Method: read
	 * 读取文字服务，Features接口。
	 * 
	 * Parameters:
     * options - {Object} 
     * 	lxyArray - {String} 必选 层级与行列号。取值举例:4,9-11,0-2
     *  
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
	 */
	read: function(options,sucessFn,failFn) {
        options = OpenLayers.Util.extend({}, options);
		 var response = new OpenLayers.Protocol.Response({requestType: "read"});
		 var failFn = failFn || function(){};
        OpenLayers.Util.applyDefaults(options, this.options || {});
		//TODO:接受请求参数。
		var url =this.url + "/"+ "Features" + "/" + this.layersID +"/" +  options.lxyArray + 
		"?f=json&" + "version=" + this.version + "&service=" + this.service;
    	//做get	请求操作
		response.priv = OpenLayers.Request.GET({
            url: url,
            scope: this,
			callback: this.createCallback(this.handleRead, response, options),
            failure: failFn
        });
		return response;
    },
	
	/**
     * Method: createCallback
     * Returns a function that applies the given public method with resp and
     *     options arguments.
     *
     * Parameters:
     * method - {Function} The method to be applied by the callback.
     * response - {<OpenLayers.Protocol.Response>} The protocol response object.
     * options - {Object} Options sent to the protocol method
     */
    createCallback: function(method, response, options) {
        return OpenLayers.Function.bind(function() {
            method.apply(this, [response, options]);
        }, this);
    },
	
    /**
     * Method: handleRead
     * 读取成功回调返回的内容。
     *
     * Parameters:
     * response - {<OpenLayers.Protocol.Response>} 返回结果对象。
     * options - {Object} 可选项。
     */
    handleRead: function(response, options) {
        options = OpenLayers.Util.extend({}, options);
        OpenLayers.Util.applyDefaults(options, this.options);

        if(options.callback) {
            var request = response.priv;
            if(request.status >= 200 && request.status < 300) {
                // success
                var result = this.parseResponse(request, options.readOptions);
                if (result && !result.error) {
                	response.features = result;
                    response.code = OpenLayers.Protocol.Response.SUCCESS;
                } else {
                    // failure (service exception)
                    response.code = OpenLayers.Protocol.Response.FAILURE;
                    response.error = result;
                }
            } else {
                // failure
                response.code = OpenLayers.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, response);
        }
    },
	
    /**
     * Method: parseResponse
     * 解析服务返回结果。
     *
     * Parameters:
     * request - {XMLHttpRequest} XMLHttpRequest对象
     * options - {Object} 可选项
     *
     * Returns:
     * {Array({<OpenLayers.Feature.Vector>})}返回要素数组
     * 
     */
    parseResponse: function(request, options) {
		var result = this.formatFeatures.read(request.responseText);
		if(result.error) {
			return result;
		}
		var featurestileGroups = result["tile"];
        return featurestileGroups;
    },
	
	/**
	 * Method: getValidLabelPlaceCode
	 * 根据要素获取标签的有效范围。
	 * 
	 * Parameters:
     * feature - {Geo.Feature.Vector} 要素对象。
     * 
     * Returns:
     * {String} 文字标签的方位。
	 */
	getValidLabelPlaceCode: function(feature,tileBounds) {
		var placeList = this.directions;
		var placeCode;
		for (var i = placeList.length - 1; i > -1; i--) {
			var labelBounds = this.getLabelInfo(feature,null,placeList[i]).bounds;
			//拿标签所在的所有方位的范围与避让区做比较，看有没有可用的区域
			if(this.isValidLabelBounds(labelBounds,tileBounds)){
			    placeCode = placeList[i];
			    break;
			}
		}
		//如果不存在有效范围，那么不显示
		if(!placeCode){
			placeCode = "none";
			feature.style.display="none";
		}
		return placeCode;
	},
	
	/**
	 * Method: isValidLabelBounds
	 * 判断文字标签的范围是否是有效范围。
	 * 
	 * Parameters:
     * bounds - {Geo.Bounds} 文字标签的范围。
     * 
     * Returns:
     * {Boolean} true表示范围有效，false表示范围无效。
	 * 
	 */
    isValidLabelBounds: function(bounds,tileBounds) {
        var isValid = true;
        var isContain = true;
		var avoidArea = this.avoidArea;
		var maxBounds = tileBounds;//new Geo.Bounds(-180,-90,180,90);
		if(bounds instanceof OpenLayers.Bounds) {
            isContain = maxBounds.containsBounds(bounds);
            if(!isContain && this.isAvoidOuterMaxExtent){
                isValid = false;
                return isValid;
            }
        }
        for (var i=avoidArea.length-1; i > -1; i--) {
            var isIntersect = this.isIntersects(avoidArea[i],bounds);
            if(isIntersect){
                isValid = false;
                break;
            }
        }
        return isValid;
    },
	
	/**
	 * Method: isIntersects
	 * 判断两个对象是否相交，不论是bounds还是geometry
	 * 
	 * Parameters:
     * obj1 - {Geo.Bounds} 要素的范围。
     * obj2 - {Geo.Bounds} 要素的范围。
     * 
     * Returns:
     * {Boolean} true表示两个范围有相交部分，false则不相交。 
	 */
	isIntersects: function(obj1,obj2) {
		var isIntersects;
		
		if((obj1.CLASS_NAME == obj2.CLASS_NAME)
		    && (obj1.CLASS_NAME === "OpenLayers.Bounds")) {
			//第二个参数必须得是false	
		    isIntersects =  obj1.intersectsBounds( obj2, false);
		}
		
		if(obj1.CLASS_NAME !== obj2.CLASS_NAME){
		    var shape1 = (obj1.CLASS_NAME == "OpenLayers.Bounds") ? obj1.toGeometry() : obj1;
		    var shape2 = (obj2.CLASS_NAME == "OpenLayers.Bounds") ? obj2.toGeometry() : obj2;
		    isIntersects =  shape1.intersects( shape2);
		}
        return isIntersects;
    },
	
	/**
	 * Method: convertPixelToLonlatSize
	 * 像素大小转度大小。
	 * 
	 * Parameters:
     * pixelSize - {Geo.Pixel} 像素大小。
     * 
     * Returns:
     * {Geo.Size} 经纬度大小。
	 */
    convertPixelToLonlatSize: function(pixelSize){
        var res = this.map.getResolution();
        return new Geo.Size(pixelSize.w*res, pixelSize.h*res);
    },
	
	/**
	 * Method: getLabelPixelSize
	 * 根据样式得到标签的像素大小。
	 * 
	 * Parameters:
     * style - {Object} 文字标注的样式。
     * 
     * Returns:
     * {Geo.Size} 文字标注的大小。 
	 */
    getLabelPixelSize: function(style){
        var text = style.label;
        if(!text){
            return null;
        }
		//新增方法开始-----
		var labelgroup = text.split("\n");
		var rows = labelgroup.length;
		//新增方法结束-----
		
		

        var context = this.renderer.canvas;
        context.save();

        var fontStyle = [style.fontStyle ? style.fontStyle : "normal",
                 "normal", // "font-variant" not supported
                 style.fontWeight ? style.fontWeight : "normal",
                 style.fontSize ? style.fontSize : "1em",
                 style.fontFamily ? style.fontFamily : "sans-serif"].join(" ");
        context.font = fontStyle;
        //measureText无法直接得到height值
        var lineHeight =// context.measureText('Mg').height ||
                          context.measureText('MM').width;//获取宽度不要用小写，要用大写
        //row是新增的,text换成labelgroup[0]
        var textSize = new Geo.Size(context.measureText(labelgroup[0]).width,
                                      lineHeight * rows);
        context.restore();
        return textSize;
    },
	
	/**
	 * Method: getLabelInfo
	 * 根据要素地理坐标与标签方位，获取标签的地理位置与范围。
	 * 
	 * Parameters:
     * feature - {Geo.Feature.Vecotor} 要素对象。
     * style - {Object} 要素的样式。
     * placeCode  - {String} 标签的方位。
     * 
     * Returns:
     * {Object} 文字标注的范围与位置。 
	 */
    getLabelInfo: function(feature,style,placeCode) {
        style = style || feature.style;
		//TODO
        var labelPixelSize = this.getLabelPixelSize(style);
		//TODO
        var labelLonlatSize = this.convertPixelToLonlatSize(labelPixelSize);
        var featuerLocation = new Geo.LonLat(feature.geometry.x,feature.geometry.y);
		var featurePixelSize = null;
        if(style.graphicWidth) {
			featurePixelSize = new Geo.Size(style.graphicWidth, style.graphicHeight);
		}else {
			featurePixelSize = new Geo.Size(style.pointRadius*2,style.pointRadius*2);
		}
        var featureLonlatSize = this.convertPixelToLonlatSize(featurePixelSize);

        var labelLonlat,labelBounds;

        switch(placeCode){
            case "lt":
                labelLonlat = new Geo.LonLat(featuerLocation.lon - featureLonlatSize.w/2 - labelLonlatSize.w,
                                              featuerLocation.lat + featureLonlatSize.h/2 + labelLonlatSize.h);
                break;
            case "ct":
                labelLonlat = new Geo.LonLat(featuerLocation.lon - labelLonlatSize.w/2,
                                              featuerLocation.lat + featureLonlatSize.h/2 + labelLonlatSize.h);
                break;
            case "rt":
                labelLonlat = new Geo.LonLat(featuerLocation.lon + featureLonlatSize.w/2,
                                              featuerLocation.lat + featureLonlatSize.h/2 + labelLonlatSize.h);
                break;
            case "lm":
                labelLonlat = new Geo.LonLat(featuerLocation.lon - featureLonlatSize.w/2 - labelLonlatSize.w,//+,
                                          featuerLocation.lat + labelLonlatSize.h/2);
                break;
            case "rm":
                labelLonlat = new Geo.LonLat(featuerLocation.lon + featureLonlatSize.w/2,
                                              featuerLocation.lat + labelLonlatSize.h/2);
                break;
            case "lb":
                labelLonlat = new Geo.LonLat(featuerLocation.lon - featureLonlatSize.w/2 - labelLonlatSize.w,//+,
                                      featuerLocation.lat - featureLonlatSize.h/2);
                break;
            case "cb":
                labelLonlat = new Geo.LonLat(featuerLocation.lon - labelLonlatSize.w/2,
                                              featuerLocation.lat - featureLonlatSize.h/2);
                break;
            case "rb":
                labelLonlat = new Geo.LonLat(featuerLocation.lon + featureLonlatSize.w/2,
                                              featuerLocation.lat - featureLonlatSize.h/2);
                break;
        }

        labelBounds = new Geo.Bounds(labelLonlat.lon, labelLonlat.lat-labelLonlatSize.h,
                                labelLonlat.lon+labelLonlatSize.w, labelLonlat.lat);
        return {
            location:labelLonlat,
            bounds: labelBounds
        };
    },
	
	/**
	 * Method: getFeatureArea
	 * 得到要素的地理范围，不包含标签。
	 * 
	 * Parameters:
     * feature - {Geo.Feature.Vecotor} 要素对象。
     * 
     * Returns:
     * {Geo.Bounds || Geo.Geometry} 要素对象或要素的范围。 
	 */
	getFeatureArea: function(feature) {
		var geometry = feature.geometry;
        switch(geometry.CLASS_NAME) {
            case "OpenLayers.Geometry.Point":
                var res = this.map.getResolution(),
                    style = feature.style,
                    lonlatSize;
				var iconSize = null;
				if(style.graphicWidth) {
					iconSize = new Geo.Size(style.graphicWidth,
		                                      style.graphicHeight);
				}else {
					iconSize = new Geo.Size(style.pointRadius*2,style.pointRadius*2);
				}	
                if(style.externalGraphic){//计算带图标的要素的范围
                    lonlatSize = new Geo.Size(res * iconSize.w, res*iconSize.h);
                    return new Geo.Bounds(geometry.x - lonlatSize.w/2,geometry.y - lonlatSize.h/2,
                                                  geometry.x + lonlatSize.w/2,geometry.y + lonlatSize.h/2);
                } else {//不带点要素的图标的大小。
                    lonlatSize = new Geo.Size(res * iconSize.w, res*iconSize.h);
                    return new Geo.Bounds(geometry.x - lonlatSize.w/2,geometry.y - lonlatSize.h/2,
                                                  geometry.x + lonlatSize.w/2,geometry.y + lonlatSize.h/2);
                }
                break;
            case "OpenLayers.Geometry.LineString":
			case "OpenLayers.Geometry.LinearRing":
			case "OpenLayers.Geometry.MultiLineString":
            case "OpenLayers.Geometry.Polygon":
                return geometry;
                break;
        }
	},
	
	/**
	 * Method: setMap
	 * 将图层与地图关联。
	 * 
	 * Parameters:
	 * map - {Geo.View2D.Map} 地图对象。
	 */
	setMap: function(map) {  
        Geo.View2D.Layer.Vector.prototype.setMap.apply(this, arguments);

    },
	
	/**
	 * Method: update
	 * 更新图层。
	 * 
	 * Parameters:
	 * featurestileGroup - {Array(Geo.Util.Format.GeoTextFeatures.FeaturesTile)} 要素数组。
	 */
	update: function(featurestileGroup) {
		this.textCounter--;
		if(!featurestileGroup ||featurestileGroup.length == 0) {
			return;
		}
		//要素标签避让
		this.avoidLabelArea(featurestileGroup);
	},
	
	/**
	 * Method: removeFeatures
	 * 移除要素。
	 */
	removeFeatures: function() {
		this.avoidArea = [];
		this.avoidArea.length = 0;
		for(var line in this.drawFeatures) {
			delete this.drawFeatures[line];
		}
		this.removeAllFeatures();
		if (this.delayedClearText !== null) {
		    window.clearTimeout(this.delayedClearText);
		    this.delayedClearText = null;
		}
	},
	/**
	 * Method: getTextWidthAndHeight
	 * 获取文本的宽度和高度。
	 */
	getTextWidthAndHeight:function(style)
	{
		var text = style.label;
        if(!text){
            return null;
        }
        var context = this.renderer.canvas;
        context.save();
        var fontStyle = [style.fontStyle ? style.fontStyle : "normal",
                 "normal", // "font-variant" not supported
                 style.fontWeight ? style.fontWeight : "normal",
                 style.fontSize ? style.fontSize : "1em",
                 style.fontFamily ? style.fontFamily : "sans-serif"].join(" ");
        context.font = fontStyle;
        //measureText无法直接得到height值
        var lineHeight = context.measureText('MM').width;//获取宽度不要用小写，要用大写
        var textSize = new Geo.Size(context.measureText(text).width,lineHeight);
        context.restore();
        return textSize;
	},
	
	/**
	 * Method: avoidLabelArea
	 * 要素标签避让。
	 */
	avoidLabelArea: function(featurestileGroup) {
		var drawFeatures = [];
		var labelFeatures = [];
		
		for(var i = featurestileGroup.length - 1; i >= 0;i--) {
			var tileBounds = this.pyramid.getTileBoundsForGridIndex(featurestileGroup[i].row, featurestileGroup[i].col, featurestileGroup[i].level);
			featurestileGroup[i].tileBounds = tileBounds;
			this.avoidArea = [];
			this.avoidArea.length = 0;
			//将要素加入避让区
			var features = this.avoidFeatureArea(featurestileGroup[i]);
	        //如果有沿线标注，则画上去
			if (featurestileGroup[i].labelFeatures && featurestileGroup[i].labelFeatures.length > 0) {
					var labelFeauresTemp = this.addLabelFeatures(featurestileGroup[i]);
					labelFeatures = labelFeatures.concat(labelFeauresTemp);
			
			};

			//执行避让操作
			var drawFeature = this.avoidFeatures(features, featurestileGroup[i].tileBounds);
			drawFeatures = drawFeatures.concat(drawFeature);
		}
		if(labelFeatures.length > 0) {
			for(var m = 0,n = labelFeatures.length;m < n;m++) {
				for(var x = 0,y=drawFeatures.length; x < y;x++) {
					var ins = labelFeatures[m].geometry.intersects(drawFeatures[x]);
					if(ins) {
						drawFeatures[x].style.display="none";
						continue;
					}
				}
			}
		}
		
		//沿线标注
		OpenLayers.Layer.Vector.prototype.addFeatures.apply(this, [labelFeatures]);
		OpenLayers.Layer.Vector.prototype.addFeatures.apply(this, [drawFeatures]);
	},
	
	/**
	 * Method: destroyLineLabelGroup
	 * 沿线标注画到地图上后，就销毁请求的数据，这个不影响已经添加到地图上的数据。
	 */
	destroyLineLabelGroup: function(featurestile) {
		for(var i = 0, j = featurestile.labelFeatures.length; i < j; i++) {
			featurestile.labelFeatures[i].destroy();
		}
	},
	
	/**
	 * Method: destroyLineLabelGroup
	 * 按瓦片范围请求的数据添加到地图后，就清楚瓦片范围用于运算的数据。
	 */
	clearfeaturestile: function(featurestileGroup) {
		for(var i = featurestileGroup.length - 1; i >= 0;i--) {
			featurestileGroup[i].destroy();
		}
		
	},
	
	/**
	 * Method: addLabelFeatures
	 * 添加沿线标注要素。
	 */
	addLabelFeatures: function(featurestile) {
		for(var i = 0, j = featurestile.labelFeatures.length; i < j; i++) {
			var ilabelBounds = featurestile.labelFeatures[i].getLabelBounds(map);
			for(var m = 0, n = featurestile.labelFeatures.length; m < n; m++) {
				if(i === m) {
					continue;
				}
				var mlabelBounds = featurestile.labelFeatures[m].getLabelBounds(map);
				var isInterset = ilabelBounds.intersectsBounds(mlabelBounds);
				if(isInterset) {
					featurestile.labelFeatures[m].isVisibleLabel = false;
				}
			}
		}
		var labelFeatures = [];
		for(var m = 0, n = featurestile.labelFeatures.length; m < n; m++) {
			if(featurestile.labelFeatures[m].isVisibleLabel) {
		//		var labelBounds = featurestile.labelFeatures[m].getLabelBounds(map);
				
			//	var geometry = labelBounds.toGeometry();
		//		this.avoidArea.push(geometry);
//				var ll = new Geo.Feature.Vector(geometry);
//				OpenLayers.Layer.Vector.prototype.addFeatures.apply(this, [ll]);
				var features = featurestile.labelFeatures[m].features;
				labelFeatures = labelFeatures.concat(features);
			}
		}
		featurestile.labelFeatures = [];
		return labelFeatures;
	},
	
	/**
	 * Method: avoidFeatures
	 * 避让掉不该绘制的要素。
	 * 
	 * Parameters:
	 * features - {Array(Geo.Feature.Vector)} 要素。
	 * tileBounds - {Geo.Bounds} 瓦片范围。
	 * 
	 * Returns:
     * {Array} 返回能绘制的要素。 
	 */
	avoidFeatures: function(features,tileBounds) {
		var drawFeature = [];
		for(var i = features.length - 1; i > -1;i--) {
			if (features[i].geometry.CLASS_NAME === "OpenLayers.Geometry.Point") {
				if(features[i].style.display === "none" || features[i].style.label && OpenLayers.String.trim(features[i].style.label) === ""
				|| features[i].style.alongLineLabel && OpenLayers.String.trim(features[i].style.alongLineLabel) === "") {
					continue;
				}
				//面标注
				if(features[i].style.type !== "polygon") {
					//点标注
					this.avoidPointLabel(features[i],tileBounds);
					drawFeature.push(features[i]);
				}else{
					drawFeature.push(features[i]);
				}
				
			}else if (features[i].geometry.CLASS_NAME === "OpenLayers.Geometry.LineString" || features[i].geometry.CLASS_NAME === "OpenLayers.Geometry.MultiLineString") {
			//	this.setLineVisibility(features[i]);
	        }else {
				drawFeature.push(features[i]);
			}
		}
		//清除本次循环的对象
		return drawFeature;
	},
	
	/**
	 * Method: avoidPointLabel
	 * 点标签加入避让区。
	 * 
	 * Parameters:
	 * point - {Geo.Feature.Vector} 点要素。
	 */
	avoidPointLabel: function(point,tileBounds) {
		var feature = point;
        var placeCode = this.getValidLabelPlaceCode(feature,tileBounds);
		if(placeCode === "none") {
			feature.style.label="";
			feature.style.display="none";
			feature.style.fontSize = "";
		}else {
			this.convertToLabelPlaceStyle(feature.style,placeCode);
	        var labelBounds = this.getLabelInfo(feature,null,placeCode).bounds;
//			var geometry1 = labelBounds.toGeometry();
//		var geo = new Geo.Feature.Vector(geometry1);		
//		OpenLayers.Layer.Vector.prototype.addFeatures.apply(this, [geo]);
			//将点的标签范围加入避让区
			this.avoidArea.push(labelBounds);
		}
	},
	
	/**
	 * Method: convertToLabelPlaceStyle
	 * 
	 * Parameters:
	 * style - {Object} 要素样式。
	 * placeCode - {String} 要素方位。
	 */
	convertToLabelPlaceStyle: function(style, placeCode) {


        /* 位置代码：
            left,center,right
            top,middle,bottom
            ----------------------
            lt ct rt
            lm    rm
            lb cb rb
         */

        //placeCode = "lm";

        if(style.graphicWidth) {
			 var iconSize = new Geo.Size(style.graphicWidth,
                                      style.graphicHeight);
		}else {
			 var iconSize = new Geo.Size(style.pointRadius*2,style.pointRadius*2);
		}
        var spacing = 0;//2;

        switch(placeCode){
            case "lt":
                style.labelAlign = "rb";
                style.labelXOffset = -(spacing + iconSize.w/2);
                style.labelYOffset = spacing + iconSize.h/2;
                break;
            case "ct":
                style.labelAlign = "cb";
                style.labelXOffset = 0;
                style.labelYOffset = spacing + iconSize.h/2;
                break;
            case "rt":
                style.labelAlign = "lb";
                style.labelXOffset = spacing + iconSize.w/2;
                style.labelYOffset = spacing + iconSize.h/2;
                break;
            case "lm":
                style.labelAlign = "rm";
                style.labelXOffset = spacing - iconSize.w/2;
                style.labelYOffset = 0;
                break;
            case "rm":
                style.labelAlign = "lm"
                style.labelXOffset = spacing + iconSize.w/2;
                style.labelYOffset = 0;
                break;
            case "lb":
                style.labelAlign = "rt"
                style.labelXOffset = -(spacing + iconSize.w/2);
                style.labelYOffset = -(spacing + iconSize.w/2);
                break;
            case "cb":
                style.labelAlign = "ct";
                style.labelXOffset = 0;
                style.labelYOffset = -(spacing + iconSize.h/2);
                break;
            case "rb":
                style.labelAlign = "lt"
                style.labelXOffset = (spacing + iconSize.w/2);
                style.labelYOffset = -(spacing + iconSize.w/2);
                break;
        }
        return style;
    },
	
	/**
	 * Method: addLabelCharBoundsToInvalidBounds
	 * 将文字标注要素所占的范围加入避让区。
	 * 
	 * Parameters:
	 * labelCharFeatures - {Array(Geo.Feature.Vector)} 文字标注要素。
	 */
	addLabelCharBoundsToInvalidBounds: function(labelCharFeatures,featureLocation) {
        for (var i = 0; i < labelCharFeatures.length; i++) {
            var labelCharFeature = labelCharFeatures[i];
            var charBounds = this.getLaeblBounds(labelCharFeature);
			//线的字符范围加入避让区
            this.avoidArea.push(charBounds);
        }
    },
	
	/**
	 * Method: boundsToFeature
	 * 将Bounds范围转换为几何对象。
	 * 
	 * Parameters:
	 * bounds - {Geo.Bounds} 范围。
	 * 
	 * Returns:
     * {Geo.Feature.Vector} 要素对象。 
	 */
	boundsToFeature: function(bounds){
        var polygon = bounds.toGeometry();
        return new Geo.Feature.Vector(polygon);
    },
	
	/**
	 * Method: getLaeblBounds
	 * 文字标注要素。
	 * 
	 * Parameters:
	 * labelFeature - {Geo.Feature.Vector} 文字标注要素。
	 * 
	 * Returns:
     * {Geo.Bounds} 单个文字标注的范围。 
	 */
	getLabelBounds: function(labelFeature){
        var position = new Geo.LonLat(labelFeature.geometry.x, labelFeature.geometry.y);
        var charCount = labelFeature.style.label.length;
        var res = map.getResolution();
        var size = new Geo.Size((labelFeature.style.fontSize + this.labelCharSpace/2.0)*charCount*res,labelFeature.style.fontSize*res);
        var charBounds = new Geo.Bounds(position.lon-size.w/2, position.lat-size.h/2,
                                          position.lon+size.w/2, position.lat+size.h/2);
        return charBounds;
    },
	
	/**
	 * Method: getLabelLonLatSize
	 * 根据样式和标注名称得到标注的行高。
	 * 
	 * Parameters:
	 * label - {String} 文字标注串。
	 * style - {Object} 要素样式。
	 * 
	 * Returns:
     * {Geo.Size} 文字标注的宽高。 
	 */
	getLabelLonLatSize:function (label,style){
        //todo:未考虑多行标签、行高与英文情况
        var fontSize = parseInt(style.fontSize);
        var res = this.map.getResolution();
        var width = (fontSize + this.labelCharSpace/2.0) * label.length * res;
		//像素乘以分辨率为经纬度值
        var height = fontSize * res
        return new Geo.Size(width, height);
    },
	
	/**
	 * Method: getLabelFeaturesForLineString
	 * 根据文字标注串得到文字标注要素。
	 * 
	 * Parameters:
	 * label - {String} 文字标注串。
	 * style - {Object} 要素样式。
	 * geometry- {Geo.Geometry} 几何对象。
	 * 
	 * Returns:
     * {Array} 得到文字标注要素。
	 */
	getLabelFeaturesForLineString: function(label,style,geometry,featurestile) {
        //标签偏移位置
        geometry.move(-map.getResolution()*12,0);
        var labelLonLatWidth = this.getLabelLonLatSize(label,style).w;
		//TODO：标签间距,此参数需要对外
        var labelSpace = labelLonLatWidth * 6;//间隔系数为0.8
		//线的总长度
        var totalLength = geometry.getLength();
		//计算出去标签长度与标签间距长度后剩下的宽度
        var remainLength = totalLength % (labelLonLatWidth + labelSpace);
		//根据标签文本宽度、字间距、标签间隔计算标签在折线上的重复次数；   labelLonLatWidth文本标签的宽度；labelSpace标签间的间隔长度
        var labelCount = Math.floor(totalLength / (labelLonLatWidth + labelSpace))
		+ Math.floor(remainLength/labelLonLatWidth);
		//计算一条线段中，绘制第一个文本标签的第一个字的位置。
        var initStartPosition = (totalLength - (labelCount - 1) * labelSpace - labelLonLatWidth * labelCount) / 2;
		while(initStartPosition < 0) {
			labelCount = labelCount - 1;
			initStartPosition = (totalLength - (labelCount - 1) * labelSpace - labelLonLatWidth * labelCount) / 2;
		}
		//总宽度除以总字数，等于每个字的宽度todo:未考虑沿线标签字间距
        var labelCharWidth = labelLonLatWidth / label.length;
        var labelCharPositionsOnLine = [];
        var labelCharText = [];
		//先只管文字的位置，不管角度
        for (var i = 0; i < labelCount; i++) {
			//一个一个字循环
            for (var j = 0; j < label.length; j++) {
				//计算标签的起点距离。
                var labelStartPosition = initStartPosition + i *(labelLonLatWidth + labelSpace);
				//保存线上的每个字的位置
                labelCharPositionsOnLine.push(labelStartPosition + j * labelCharWidth);
				//保存线上的每个字
                labelCharText.push(label[j]);
            }
        }

        //计算每段路径长度
        var points = geometry.getVertices();
        var pathsInfo = [];
        var totalLengthCounter = 0;
		//循环线上的每个点，保存每两个点的夹角等信息。
        for (var i = 0; i < points.length - 1; i++) {
            var startPoint = points[i];
            var endPoint = points[i+1];
            var angle = this.getTwoPointsAngle(startPoint,endPoint);
            var length = startPoint.distanceTo(endPoint);
            totalLengthCounter = totalLengthCounter + length;
            pathsInfo.push({
                start: startPoint,
                end: endPoint,
                angle: angle,
                length: length,
                totalLength: totalLengthCounter
            });
        }

        var labelCharFeatures = [];
        var currentPathIndex = 0;
		
        for (var i = 0; i < labelCharPositionsOnLine.length; i++) {
			var charPosition = labelCharPositionsOnLine[i];
			var currentLength = 0;

			//TODO：还有情况没有判断
            var parthInfo = pathsInfo[currentPathIndex];
            while(parthInfo.totalLength < charPosition){
                currentPathIndex++;
                parthInfo = pathsInfo[currentPathIndex];
            }
            var lastTotalLength;
            if(currentPathIndex > 0){
                lastTotalLength = pathsInfo[currentPathIndex-1].totalLength;
            } else {
                lastTotalLength = 0;
            }

	           var currentLength = charPosition - lastTotalLength;
            var labelCharPoint = this.getPointOnLine(parthInfo.start,parthInfo.end,currentLength);
			
            var charStyle = Geo.Util.extend({}, this.lineLabelDefaultStyle);
            charStyle.label = labelCharText[i];
			//TODO:是否旋转
			if(this.isRotation) {
				charStyle.labelRotation = -parthInfo.angle;
			}
			charStyle = Geo.Util.extend(charStyle, style);
            labelCharFeatures.push(new Geo.Feature.Vector(labelCharPoint,null,charStyle));
			
        }
		var labelGroup = this.getSortLabelCharFeatures(labelCharFeatures,label,featurestile);
        return labelGroup;
    },
	
	/**
	 * Method: getSortLabelCharFeatures
	 * 沿线标注排序
	 */
	getSortLabelCharFeatures: function(labelCharFeatures,label,featurestile) {
		var lineLabelGroup = [];
		function isInteger( str ) {
			var regu = /^[-]{0,1}[0-9]{1,}$/;
			return regu.test(str);
		}
		var linePointGroup = [];
		for(var i = 0; i < labelCharFeatures.length; i++) {
			
			if(isInteger(""+(i + 1)/label.length)) {
				linePointGroup.push(labelCharFeatures[i]);
				var pointgroup = new Geo.Util.Format.GeoTextFeatures.LineLabelGroup({
					features: linePointGroup,
					labelCharSpace: this.labelCharSpace,
					label: label
				});
				var map = this.map;
				var labelBounds = pointgroup.getLabelBounds(map);
				//瓦片是否包含给定的标签
				var isContain = featurestile.tileBounds.containsBounds(labelBounds, true);
				if(isContain) {
					if(!Geo.Util.isArray(featurestile.labelFeatures)) {
						featurestile.labelFeatures = [];
					}
					featurestile.labelFeatures.push(pointgroup);
				}
				linePointGroup = [];
				var addX = 0;
				var addY = 0;
				for(var y = 0; y < label.length - 1; y++) {
					addX += Math.abs(labelCharFeatures[i - y].geometry.x - labelCharFeatures[i - y - 1].geometry.x);
					addY += Math.abs(labelCharFeatures[i - y].geometry.y - labelCharFeatures[i - y - 1].geometry.y);
				}
//				var angle = this.getTwoPointsAngle(labelCharFeatures[i - (labelCharFeatures.length - 1)].geometry,labelCharFeatures[i].geometry);
				//从上到下，反着来
				if(addX <= addY  && labelCharFeatures[i - (label.length - 1)].geometry.x >= labelCharFeatures[i].geometry.x &&
				labelCharFeatures[i - (label.length - 1)].geometry.y <= labelCharFeatures[i].geometry.y) {
					var fanArray = [];
					for(var y = 0; y < label.length; y++) {
						//判断是偶数
						if(label.length % 2 === 0 && (y + 1) <= label.length / 2) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}else if(label.length % 2 !== 0 && (y + 1) < Math.ceil(label.length / 2.0)) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}
					}
				}else if(addX <= addY && labelCharFeatures[i - (label.length - 1)].geometry.x <= labelCharFeatures[i].geometry.x &&
				labelCharFeatures[i - (label.length - 1)].geometry.y <= labelCharFeatures[i].geometry.y) {
					for(var y = 0; y < label.length; y++) {
						//判断是偶数
						if(label.length % 2 === 0 && (y + 1) <= label.length / 2) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}else if(label.length % 2 !== 0 && (y + 1) < Math.ceil(label.length / 2.0)) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}
					}
				}else if(addX > addY && labelCharFeatures[i - (label.length - 1)].geometry.x > labelCharFeatures[i].geometry.x) {
					for(var y = 0; y < label.length; y++) {
						//判断是偶数
						if(label.length % 2 === 0 && (y + 1) <= label.length / 2) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}else if(label.length % 2 !== 0 && (y + 1) < Math.ceil(label.length / 2.0)) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}
					}
				}
			}else {
				linePointGroup.push(labelCharFeatures[i]);
			}
		}
		return lineLabelGroup;
	},
	
	/**
	 * Method: getPointOnLine
	 * 计算两点间直线的指定长度所处的点位。
	 * 
	 * Parameters:
	 * start - {Number} 起点。
	 * end - {Object} 终点。
	 * length- {Number} 两点间的距离。
	 * 
	 * Returns:
     * {Array} 得到文字标注要素。 
	 */
    getPointOnLine: function(start,end,length){
		var point;
        if(length <= 0) {
            point = start;
        } else {
			var totalLength = start.distanceTo(end);
			var addY = (end.y - start.y) * length / totalLength;
			var addX = (end.x - start.x) * length / totalLength;
            point = new Geo.Geometry.Point(start.x + addX,
                                             start.y + addY);
        }

        return point;
    },
	
	/**
	 * Method: getTwoPointsAngle
	 * 根据起点和终点得到线与地图水平线之间的夹角。
	 * 
	 * Parameters:
	 * start - {Number} 起点。
	 * end - {Object} 终点。
	 * 
	 * Returns:
     * {Array} 角度。 
	 */
	getTwoPointsAngle: function(start,end){
        var k = (end.y - start.y) / (end.x - start.x);
        return Math.atan(k) / 0.017453293;
    },
	
	/**
	 * Method: avoidFeatureArea
	 * 要素范围避让。
	 * 
	 * Parameters:
	 * features - {Array(Geo.Feature.Vector)} 将要素加入避让区。
	 */
	avoidFeatureArea: function(featurestile) {
		var features = featurestile.features;
		for(var i=features.length-1; i > -1; i--) {
			//如果类型为字符串，则表示是线或面，TODO：这里还没有判断面
			var area = this.getFeatureArea(features[i]);
			var linegeometry = features[i].geometry.clone();
			var label = features[i].style.alongLineLabel;
			if(features[i].geometry instanceof OpenLayers.Geometry.LineString) {
				var linePointGroup = this.getLabelFeaturesForLineString(label, features[i].style,linegeometry,featurestile);
			}else if(features[i].geometry instanceof OpenLayers.Geometry.MultiLineString) {
				//增加对多点的解析
				for(var a = 0,len = linegeometry.components.length;a < len; a++) {
					var linePointGroup = this.getLabelFeaturesForLineString(label, {
			            fontSize: 16
			        },linegeometry.components[a].clone(),featurestile);
				} 
			}
        	this.avoidArea.push(area);
		}
		return features;
	},
	
	/**
	 * Method: removeMap
	 * 将图层移除地图。
	 * 
	 * Parameters:
	 * map - {Geo.View2D.Map} 地图。
	 */
	removeMap: function(map) {
        Geo.View2D.Layer.Vector.prototype.removeMap.apply(this, arguments);
		map.events.un({
	        "zoomend": this.update
	    });
    },
	
	CLASS_NAME: "Geo.View2D.Layer.GeoText"
});
Geo.View2D.Layer.GeoText.TOP = "ct";
Geo.View2D.Layer.GeoText.BOTTOM = "cb";
Geo.View2D.Layer.GeoText.LEFT="lm";
Geo.View2D.Layer.GeoText.RIGHT="rm";
Geo.View2D.Layer.GeoText.TOP_LEFT="lt";
Geo.View2D.Layer.GeoText.BOTTOM_LEFT="lb";
Geo.View2D.Layer.GeoText.TOP_RIGHT="rt";
Geo.View2D.Layer.GeoText.BOTTOM_RIGHT="rb";/**
 * Class: Geo.View2D.Layer.HotareaWMTS
 * 热区wmts类，继承自Geo.View2D.Layer.WMTS类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 *
 * Inherits from:
 *  - <Geo.View2D.Layer.WMTS>
 */
Geo.View2D.Layer.HotareaWMTS = Geo.Class(Geo.View2D.Layer.WMTS, {
	
    /**
     * APIProperty: vectorLayer
     * {<Geo.View2D.Layer.Vector>} 热区图层包含的矢量图层。
     */
	vectorLayer: null,
	
    /**
     * APIProperty: selectCtrl
     * {<Geo.View2D.Control.SelectFeature>} 选择要素控件。
     */
	selectCtrl: null,
	
    /**
     * Constructor: Geo.View2D.Layer.HotareaWMTS
     * 创建HotareaWMTS图层对象实例。
     *
     * Parameters:
     * options - {Object} 参数选项。
     */
    initialize: function(options){
		Geo.View2D.Layer.WMTS.prototype.initialize.apply(this, arguments);
		this.urls = [];
    },
	
	/**
     * Method: setMap
     */
    setMap: function() {
        Geo.View2D.Layer.WMTS.prototype.setMap.apply(this, arguments);
		
		this.map.events.register("zoomend", this, this.removeFeatures);
		this.map.addLayers([this.vectorLayer]);
		
		//要素高亮控件
        this.highlightCtrl = new Geo.View2D.Control.SelectFeature(this.vectorLayer, {
            hover: true,
			highlightOnly: true,
            eventListeners: {
                beforefeaturehighlighted: function(evt){
				},
				featurehighlighted: function(evt){
					var feature = evt.feature;
					this.hotareaWMTS.highlight(feature);
					var pointFeature = this.hotareaWMTS.getCombinationFeature(feature).point;
					//无点击才触发，mouseover事件
					if (!pointFeature.isclicked) {
						this.hotareaWMTS.onMouseOverFeature(pointFeature);
					}
				},
				featureunhighlighted: function(evt){
					var feature = evt.feature;
					var pointFeature = this.hotareaWMTS.getCombinationFeature(feature).point;
					//无点击才触发，mouseout事件
					if(!pointFeature.isclicked){
						this.hotareaWMTS.unhighlight(feature);
						this.hotareaWMTS.onMouseOutFeature(pointFeature);
					}else{
						this.hotareaWMTS.highlight(feature);
					}
				}
            }
        });
		
		//选择要素控件
        this.selectCtrl = new Geo.View2D.Control.SelectFeature(this.vectorLayer, {
            hover: false,
			clickout: true,
			eventListeners: {
                beforefeaturehighlighted: function(evt){
				},
				featurehighlighted: function(evt){
					var feature = evt.feature;
					this.hotareaWMTS.highlight(feature);
				},
				featureunhighlighted: function(evt){
					//var feature = evt.feature; 
					//this.hotareaWMTS.unhighlight(feature);
				}
            },
			onSelect: function(feature){
				this.hotareaWMTS.highlight(feature);
				
				var pointFeature = this.hotareaWMTS.getCombinationFeature(feature).point;
				pointFeature.isclicked = true;
				this.hotareaWMTS.onSelectFeature(pointFeature);
			},
			onUnselect: function(feature){
				this.hotareaWMTS.unhighlight(feature);
				
				var pointFeature = this.hotareaWMTS.getCombinationFeature(feature).point;
				pointFeature.isclicked = false;
				this.hotareaWMTS.onUnselectFeature(pointFeature);
			}
        });
		this.map.addControl(this.highlightCtrl);
		this.map.addControl(this.selectCtrl);
		this.highlightCtrl.activate();
		this.selectCtrl.activate();
		
		this.highlightCtrl.hotareaWMTS = this;
		this.selectCtrl.hotareaWMTS = this;
    },
    
    /**
     * Method: highlight
     * 高亮要素。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 被高亮的要素对象。
     */
	highlight: function(feature){
		var combinationFeature = this.getCombinationFeature(feature);
		var pointFeature = combinationFeature.point;
		var polygonFeature = combinationFeature.polygon;
		var hoverPicUrl = pointFeature.attributes.overPicUrl;
		var displayname = polygonFeature.attributes.displayname;
		
		var img = new Image();
		img.src = hoverPicUrl;
		var gw = img.width;
		var gh = img.height;
		
        var typeStyle = {
            point: {
                externalGraphic: hoverPicUrl,
                graphicWidth: gw,
                graphicHeight: gh,
                graphicXOffset: parseInt(-gw/2),
                graphicYOffset: parseInt(-gh/2),
				cursor: "pointer"
            },
            polygon: {
				fillOpacity: 0,//透明
				strokeOpacity: 0,//透明
				cursor: "pointer"
//                fillColor: "#f0f7fe",
//                //fillOpacity: 0,//透明
//                strokeColor: "#76a1cb",//"#d9534f",//"#66FF66",
//                //strokeOpacity: 0,//透明
//                strokeWidth: 1,
//                labelXOffset: 0,
//                labelYOffset: 0,//OpenLayers.BROWSER_NAME == "safari" ? 0 : -4,//兼容IE和chrome，处理字体的错位问题
//                cursor: "inherit",
//                fontColor: "#19446e",
//                label: displayname
            }
        };
        
        this.vectorLayer.drawFeature(pointFeature, typeStyle["point"]);
        this.vectorLayer.drawFeature(polygonFeature, typeStyle["polygon"]);
	},
    
    /**
     * Method: highlight
     * 取消高亮要素。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 被取消高亮的要素对象。
     */
	unhighlight: function(feature){
		var combinationFeature = this.getCombinationFeature(feature);
		var pointFeature = combinationFeature.point;
		var polygonFeature = combinationFeature.polygon;
		var outPicUrl = pointFeature.attributes.outPicUrl;
        var displayname = polygonFeature.attributes.displayname;
		
		var img = new Image();
		img.src = outPicUrl;
		var gw = img.width;
		var gh = img.height;
        var typeStyle = {
            point: {
                externalGraphic: outPicUrl,
                graphicWidth: gw,
                graphicHeight: gh,
                graphicXOffset: parseInt(-gw/2),
                graphicYOffset: parseInt(-gh/2),
				cursor: "pointer"
            },
            polygon: {
                fillColor: "#f0f7fe",
                fillOpacity: 0,//透明
                strokeColor: "#76a1cb",//"#d9534f",//"#66FF66",
                strokeOpacity: 0,//透明
                strokeWidth: 1,
                cursor: "pointer"
                //labelXOffset: 0,
                //labelYOffset: OpenLayers.BROWSER_NAME == "safari" ? 0 : -4,//
                //fontColor: "#19446e",
                //label: displayname
            }
        };
        
        this.vectorLayer.drawFeature(pointFeature, typeStyle["point"]);
        this.vectorLayer.drawFeature(polygonFeature, typeStyle["polygon"]);
	},
	
    /**
     * APIMethod: onSelectFeature
     * 点击选取要素后触发的方法。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 点击后，被触发的要素。
     */
	onSelectFeature: function(feature) {
    },
	
    /**
     * APIMethod: onUnselectFeature
     * 取消选取要素后触发的方法。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 取消选择后，被触发的要素。
     */
	onUnselectFeature: function(feature) {
    },
	
    /**
     * APIMethod: onMouseOverFeature
     * 鼠标移上要素后触发的方法。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 鼠标移上要素后，被触发的要素。
     */
	onMouseOverFeature: function(feature) {
    },
	
    /**
     * APIMethod: onMouseOutFeature
     * 鼠标移出要素后触发的方法。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 鼠标移出要素后，被触发的要素。
     */
	onMouseOutFeature: function(feature) {
    },
	
    /**
     * APIMethod: removeFeatures
     * 清除热区图层上所有要素。
     */
	removeFeatures: function() {
		this.selectCtrl.unselectAll();
		this.vectorLayer.destroyFeatures();
		this.urls = [];
    },
	
	/**
     * Method: moveTo
     * This function is called whenever the map is moved. All the moving
     * of actual 'tiles' is done by the map, but moveTo's role is to accept
     * a bounds and make sure the data that that bounds requires is pre-loaded.
     *
     * Parameters:
     * bounds - {<Geo.Bounds>}
     * zoomChanged - {Boolean}
     * dragging - {Boolean}
     */
    moveTo:function(bounds, zoomChanged, dragging) {
		if (zoomChanged || !this.matrix) {
            this.updateMatrixProperties();
        }
		
        OpenLayers.Layer.HTTPRequest.prototype.moveTo.apply(this, arguments);
        
        bounds = bounds || this.map.getExtent();

        if (bounds != null) {
             
            // if grid is empty or zoom has changed, we *must* re-tile
            var forceReTile = !this.grid.length || zoomChanged;

            // total bounds of the tiles
            var tilesBounds = this.getTilesBounds();            
      
            if (this.singleTile) {
                
                // We want to redraw whenever even the slightest part of the 
                //  current bounds is not contained by our tile.
                //  (thus, we do not specify partial -- its default is false)
                if ( forceReTile || 
                     (!dragging && !tilesBounds.containsBounds(bounds))) {
                    this.initSingleTile(bounds);
                }
            } else {
             
                // if the bounds have changed such that they are not even 
                //  *partially* contained by our tiles (IE user has 
                //  programmatically panned to the other side of the earth) 
                //  then we want to reTile (thus, partial true).  
                //
                if (forceReTile || !tilesBounds.containsBounds(bounds, true)) {
                    this.initGriddedTiles(bounds);
                } else {
                    this.moveGriddedTiles();
                }
            }
        }
    },
	
    /**
     * Method: getCombinationFeature
     * 获取组合要素。包含点和面的一组要素。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 要素。
     *
     * Returns:
     * {Object} 返回包含点和面的一组要素。
     */
    getCombinationFeature: function(feature) {
        var pointFeature = null;
        var polygonFeature = null;
        var type = feature.attributes.type;
        var relatedid = feature.attributes.relatedid;
        if (type == "point") {
            pointFeature = feature;
			polygonFeature = this.vectorLayer.getFeatureById(relatedid);
        }
        else {
            pointFeature = this.vectorLayer.getFeatureById(relatedid);
			polygonFeature  = feature;
        }
        
        return {
            point: pointFeature,
            polygon: polygonFeature
        };
    },
	
    /**
     * Method: removeMap
     * Called when the layer is removed from the map.
     *
     * Parameters:
     * map - {<OpenLayers.Map>} The map.
     */
    removeMap: function(map) {
       OpenLayers.Layer.Grid.prototype.removeMap.apply(this, arguments);
    },
	
	/**
     * Method: addTile
     * Create a tile, initialize it, and add it to the layer div. 
     *
     * Parameters
     * bounds - {<Geo.Bounds>}
     * position - {<Geo.Pixel>}
     *
     * Returns:
     * {<Geo.Tile>} The added Geo.Tile
     */
    addTile: function(bounds, position) {
		if(this.format == "text/json"){
			return new Geo.View2D.Tile.TileFeature(this, position, bounds, null, 
                                         this.tileSize, this.tileOptions);
		}
    },
	
	/**
     * Method: destroy
     * Deconstruct the layer and clear the grid.
     */
    destroy: function() {
        OpenLayers.Layer.Grid.prototype.destroy.apply(this, arguments);
    },
	
	/**
     * Method: getPicURL
     * 
     * Parameters:
     * picid - {<Number>}
     * isanti - {<Blooean>}
     * 
     * Returns:
     * {String} A URL for the pic.
     */
    getPicURL: function(picid, isanti){
		
        // assemble all required parameters
        var params = {
            SERVICE: "WMTS",
            REQUEST: "GetIcon",
            VERSION: this.version,
            LAYER: this.layer,
            STYLE: this.style,
            TILEMATRIXSET: this.matrixSet,
            TILEMATRIX: this.matrix.identifier,
            PICID: picid, //0
            ISANTI: isanti // false
        };
        var url = OpenLayers.Layer.Grid.prototype.getFullRequestString.apply(this, [params]);
        
        return url;
    },
	
    CLASS_NAME: "Geo.View2D.Layer.HotareaWMTS"
});/**
 * Class: Geo.View2D.BaseLayerGroup
 * 二维视图的底图图层组对象，可以将多个图层对象组合在一起，进行统一的加载和卸载操作。该图层组中的图层将作为地图中的底图置于所有图层的最下方。
 */
Geo.View2D.BaseLayerGroup = Geo.Class({

    /**
     * APIProperty: id
     * ｛String｝唯一标识符。
     */
    id: null,
    
    /**
     * APIProperty: layers
     * {Array} 图层集合。
     */
    layers: null,
    
    /**
     * APIProperty: map
     * 所属的地图对象。
     */
    map: null,
    
    /**
     * Constructor: Geo.View2D.BaseLayerGroup
     * Geo.View2D.BaseLayerGroup构造函数。
     * 
     * Parameters:
     * options - {Object} 相关选项设置。
     * 	layers - {Array} 必选 图层数组。
     * 示例代码：
     * 
     * (code)
     * var vectorGroup = new Geo.View2D.BaseLayerGroup({
     *      layers: [new Geo.View2D.Layer.GlobeTile("全球1:100万矢量底图", "http://tile0.tianditu.com/services/A0512_EMap", {
     *          transitionEffect: "resize",
     *          topLevel: 2,
     *          bottomLevel: 10,
     *          maxExtent: new Geo.Bounds(-180, -90, 180, 90)
     *      }), new Geo.View2D.Layer.GlobeTile("全球1:100万矢量注记", "http://tile0.tianditu.com/services/AB0512_Anno", {
     *          topLevel: 2,
     *          bottomLevel: 12,
     *          maxExtent: new Geo.Bounds(-180, -90, 180, 90)
     *      })]
     *  });
     * (end)
     * 
     */
    initialize: function(options){
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        this.layers = [];
        OpenLayers.Util.extend(this, options);
    },
    
    /**
     * APIMethod: setMap
     * 将底图图层组关联到地图对象。
     *
     * Parameters:
     * map - {OpenLayers.Map} 地图对象。
     */
    setMap: function(map){
        if (map && !this.map) {
            this.map = map;
            for(var i=0; i<this.layers.length; i++){
                this.map.addLayer(this.layers[i],true);
            }
            
        }
    },
    
    /**
     * APIMethod: removeMap
     * 解除底图图层组与地图对象的关联。
     */
    removeMap: function(){
        if (this.map) {
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                //如果图层已经被移除地图了，则不再被移除
                if(layer.map){
                    this.map.removeLayer(this.layers[i]);
                }
            }
            this.map = null;
        }
    },
    
     
    /**
     * APIMethod: getMaxResolution
     * 获取底图图层组中最大分辨率。
     *
     * Returns:
     * {Float} 分辨率
     */   
    getMaxResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
            var layerOptions = layers[i].getOptions();
            var layerMaxRes = layerOptions.maxResolution;
            res = (res == null) ? layerMaxRes : Math.max(res, layerMaxRes);
        }
        return res;
    },
      
    /**
     * APIMethod: getMinResolution
     * 获取底图图层组中最小分辨率。
     *
     * Returns:
     * {Float} 分辨率
     */      
    getMinResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
            var layerOptions = layers[i].getOptions();
            var layerMinRes = layerOptions.minResolution;
            res = (res == null) ? layerMinRes : Math.min(res, layerMinRes);
        }
        return res;
    },
      
    /**
     * APIMethod: getMaxExtent
     * 获取底图图层组中最大范围。
     *
     * Returns:
     * {Float} 范围
     */     
    getMaxExtent: function(){
        var bounds = null;
        for (var i = 0; i < this.layers.length; i++) {
            if (bounds) {
                bounds.extend(this.layers[i].getDataExtent());
            }
            else {
                bounds = this.layers[i].getDataExtent();
            }
        }
        return bounds;
    },
    
    /**
     * APIMethod: destroy
     * 销毁对象。
     *
     */
    destroy: function(){
		this.removeMap();
        for (var i = 0; i < layers.length; i++) {
            layers[i].destroy();
        }
		this.layers = null;
    },
    
    CLASS_NAME: "Geo.View2D.BaseLayerGroup"

});

Geo.View2D.BaseLayerGroup.getTianDiTuGroup = function(type, options){
    
    //TODO: 让Geo.View2D.BaseLayerGroup.getTianDiTuGroup支持更多设置选项
    //须将服务信息与图层对象的实例化分离
    
    /*
     * 服务相关信息定义
     * 1.影像层有缩放效果，标记层没有
     * 2.可以设置是否使用镜像服务地址，提高瓦片读取效率
     * 3.实际服务地址根据服务名和主机地址拼出
     */
    var serviceInfo = {
        "img":[
            {
                title:"全球影像底图(2-10)",
                serviceName: "sbsm0210",
                transitionEffect: "resize",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                isMirror: true
            },{
                title:"全球影像注记(2-10)",
                serviceName: "A0610_ImgAnno",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                isMirror: true
            }
            
        ],
        "dlg":[]
    };
    
    var typeMapping = {
        "img":[
            new Geo.View2D.Layer.GlobeTile("全球影像底图(2-10)", "http://tile0.tianditu.com/services/sbsm0210", {
                transitionEffect: "resize",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/sbsm0210",
    				"http://tile1.tianditu.com/services/sbsm0210",
    				"http://tile2.tianditu.com/services/sbsm0210",
    				"http://tile3.tianditu.com/services/sbsm0210",
    				"http://tile4.tianditu.com/services/sbsm0210",
    				"http://tile5.tianditu.com/services/sbsm0210",
    				"http://tile6.tianditu.com/services/sbsm0210",
    				"http://tile7.tianditu.com/services/sbsm0210"
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全球影像注记(2-10)", "http://tile0.tianditu.com/services/A0104_ImgAnnoE", {
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/A0610_ImgAnno",
                    "http://tile1.tianditu.com/services/A0610_ImgAnno",
    				"http://tile2.tianditu.com/services/A0610_ImgAnno",
    				"http://tile3.tianditu.com/services/A0610_ImgAnno",
    				"http://tile4.tianditu.com/services/A0610_ImgAnno",
    				"http://tile5.tianditu.com/services/A0610_ImgAnno",
    				"http://tile6.tianditu.com/services/A0610_ImgAnno",
    				"http://tile7.tianditu.com/services/A0610_ImgAnno"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(14)", "http://tile0.tianditu.com/services/eastdawnall", {
                transitionEffect: "resize",
                topLevel: 14,
                bottomLevel: 14,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.701171875),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/eastdawnall",
                    "http://tile1.tianditu.com/services/eastdawnall",
    				"http://tile2.tianditu.com/services/eastdawnall",
    				"http://tile3.tianditu.com/services/eastdawnall",
    				"http://tile4.tianditu.com/services/eastdawnall",
    				"http://tile5.tianditu.com/services/eastdawnall",
    				"http://tile6.tianditu.com/services/eastdawnall",
    				"http://tile7.tianditu.com/services/eastdawnall"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全球影像(15-18)", "http://tile0.tianditu.com/services/sbsm1518", {
                transitionEffect: "resize",
                topLevel: 15,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/sbsm1518",
                    "http://tile1.tianditu.com/services/sbsm1518",
    				"http://tile2.tianditu.com/services/sbsm1518",
    				"http://tile3.tianditu.com/services/sbsm1518",
    				"http://tile4.tianditu.com/services/sbsm1518",
    				"http://tile5.tianditu.com/services/sbsm1518",
    				"http://tile6.tianditu.com/services/sbsm1518",
    				"http://tile7.tianditu.com/services/sbsm1518"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(13)", "http://tile0.tianditu.com/services/e13", {
                transitionEffect: "resize",
                topLevel: 13,
                bottomLevel: 13,
                maxExtent: new Geo.Bounds(73.30078125,17.9736328125,135.1318359375,53.6572265625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/e13",
                    "http://tile1.tianditu.com/services/e13",
    				"http://tile2.tianditu.com/services/e13",
    				"http://tile3.tianditu.com/services/e13",
    				"http://tile4.tianditu.com/services/e13",
    				"http://tile5.tianditu.com/services/e13",
    				"http://tile6.tianditu.com/services/e13",
    				"http://tile7.tianditu.com/services/e13"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(12)", "http://tile0.tianditu.com/services/e12", {
                transitionEffect: "resize",
                topLevel: 12,
                bottomLevel: 12,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.701171875),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/e12",
                    "http://tile1.tianditu.com/services/e12",
    				"http://tile2.tianditu.com/services/e12",
    				"http://tile3.tianditu.com/services/e12",
    				"http://tile4.tianditu.com/services/e12",
    				"http://tile5.tianditu.com/services/e12",
    				"http://tile6.tianditu.com/services/e12",
    				"http://tile7.tianditu.com/services/e12"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(11)", "http://tile0.tianditu.com/services/e11", {
                transitionEffect: "resize",
                topLevel: 11,
                bottomLevel: 11,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.7890625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/e11",
                    "http://tile1.tianditu.com/services/e11",
    				"http://tile2.tianditu.com/services/e11",
    				"http://tile3.tianditu.com/services/e11",
    				"http://tile4.tianditu.com/services/e11",
    				"http://tile5.tianditu.com/services/e11",
    				"http://tile6.tianditu.com/services/e11",
    				"http://tile7.tianditu.com/services/e11"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像注记(11-14)", "http://tile0.tianditu.com/services/B0530_eImgAnno", {
                topLevel: 11,
                bottomLevel: 14,
                maxExtent: new Geo.Bounds(73.4765625,2.8125,135.439453125,53.7890625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/B0530_eImgAnno",
                    "http://tile1.tianditu.com/services/B0530_eImgAnno",
    				"http://tile2.tianditu.com/services/B0530_eImgAnno",
    				"http://tile3.tianditu.com/services/B0530_eImgAnno",
    				"http://tile4.tianditu.com/services/B0530_eImgAnno",
    				"http://tile5.tianditu.com/services/B0530_eImgAnno",
    				"http://tile6.tianditu.com/services/B0530_eImgAnno",
    				"http://tile7.tianditu.com/services/B0530_eImgAnno"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像注记(15-18)", "http://tile0.tianditu.com/services/siweiAnno68", {
                topLevel: 15,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(73.4765625,2.8125,135.439453125,53.7890625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/siweiAnno68",
                    "http://tile1.tianditu.com/services/siweiAnno68",
    				"http://tile2.tianditu.com/services/siweiAnno68",
    				"http://tile3.tianditu.com/services/siweiAnno68",
    				"http://tile4.tianditu.com/services/siweiAnno68",
    				"http://tile5.tianditu.com/services/siweiAnno68",
    				"http://tile6.tianditu.com/services/siweiAnno68",
    				"http://tile7.tianditu.com/services/siweiAnno68"
    				
                ]
            })
        ],"dlg":[
            new Geo.View2D.Layer.GlobeTile("全国矢量(2-10)", "http://tile0.tianditu.com/services/A0512_EMap", {
                transitionEffect: "resize",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180,-90,180,90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/A0512_EMap",
                    "http://tile1.tianditu.com/services/A0512_EMap",
    				"http://tile2.tianditu.com/services/A0512_EMap",
    				"http://tile3.tianditu.com/services/A0512_EMap",
    				"http://tile4.tianditu.com/services/A0512_EMap",
    				"http://tile5.tianditu.com/services/A0512_EMap",
    				"http://tile6.tianditu.com/services/A0512_EMap",
    				"http://tile7.tianditu.com/services/A0512_EMap"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国矢量注记(2-10)", "http://tile0.tianditu.com/services/AB0512_Anno", {
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180,-90,180,90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/AB0512_Anno",
                    "http://tile1.tianditu.com/services/AB0512_Anno",
    				"http://tile2.tianditu.com/services/AB0512_Anno",
    				"http://tile3.tianditu.com/services/AB0512_Anno",
    				"http://tile4.tianditu.com/services/AB0512_Anno",
    				"http://tile5.tianditu.com/services/AB0512_Anno",
    				"http://tile6.tianditu.com/services/AB0512_Anno",
    				"http://tile7.tianditu.com/services/AB0512_Anno"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国矢量(11-12)", "http://tile0.tianditu.com/services/B0627_EMap1112", {
                transitionEffect: "resize",
                topLevel: 11,
                bottomLevel: 12,
                maxExtent: new Geo.Bounds(69.9609375,0.87890625,879.9609375,56.25),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/B0627_EMap1112",
                    "http://tile1.tianditu.com/services/B0627_EMap1112",
    				"http://tile2.tianditu.com/services/B0627_EMap1112",
    				"http://tile3.tianditu.com/services/B0627_EMap1112",
    				"http://tile4.tianditu.com/services/B0627_EMap1112",
    				"http://tile5.tianditu.com/services/B0627_EMap1112",
    				"http://tile6.tianditu.com/services/B0627_EMap1112",
    				"http://tile7.tianditu.com/services/B0627_EMap1112"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国矢量(13-18)", "http://tile0.tianditu.com/services/siwei0608", {
                transitionEffect: "resize",
                topLevel: 13,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(-180,-90,180,90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/siwei0608",
                    "http://tile1.tianditu.com/services/siwei0608",
    				"http://tile2.tianditu.com/services/siwei0608",
    				"http://tile3.tianditu.com/services/siwei0608",
    				"http://tile4.tianditu.com/services/siwei0608",
    				"http://tile5.tianditu.com/services/siwei0608",
    				"http://tile6.tianditu.com/services/siwei0608",
    				"http://tile7.tianditu.com/services/siwei0608"
    				
                ]
            })
        ]
    };
    
    var layers = typeMapping[type];
    if(layers){
        return new Geo.View2D.BaseLayerGroup({layers: layers});
    }
    return null;
}
//此类已被废弃，推荐使用Geo.View2D.BaseLayerGroup代替
Geo.View2D.LayerGroup = Geo.View2D.BaseLayerGroup;


/**
 * Class: Geo.View2D.FeatureManager
 * 二维视图要素管理器。提供了与矢量要素相关的一系列功能。支持对同一矢量图层上的要素进行分类管理，包含矢量图层样式设置、
 * 要素选择功能、要素浮云显示、要素集客户端分页等功能。
 */
Geo.View2D.FeatureManager = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识。
     */
    id: null,	
    
    /**
     * APIProperty: map
     * {<Geo.View2D.Map>} 所属的地图对象。
     */
    map: null,
	
	//结果类型映射
	_typeMapping: null,
	
	/**
     * APIProperty: featureSortField
     * {String} 标识要素分类的属性名，默认为"featureSort"。
     */
	featureSortField: "featureSort",

	/**
     * APIProperty: orderNumberField
     * {String} 标识要素序号的属性名，默认为"orderNumber"。
     */	
	orderNumberField: "orderNumber",

	/**
     * APIProperty: styleMap
     * {<Geo.StyleMap>} 矢量图层样式。
     */	
	styleMap: null,
    
	/**
     * APIProperty: vectorLayerOptions
     * {Object} 矢量图层对象构造参数。
     */		
	vectorLayerOptions: null,    

	/**
     * APIProperty: vectorLayer
     * {<Geo.View2D.Layer.Vector>} 矢量图层。
     */		
	vectorLayer: null,

	/**
     * APIProperty: selectControlOptions
     * {Object} 要素选择控件对象构造参数。
     */	
	selectControlOptions: null,

	/**
     * APIProperty: selectControl
     * {<Geo.View2D.Control.SelectFeature>} 矢量要素选择控件。
     */	
	selectControl: null,

	/**
     * APIProperty: maxFeaturesPerPage
     * {Integer} 默认的要素分页数量，默认值是15。
     */	
	maxFeaturesPerPage: 15,

    //提示框样式CSS类名。
	topicCSSClass: null,
	
    //提示框div
	topicDiv: null,

    /**
     * Constructor: Geo.View2D.FeatureManager
     * Geo.View2D.FeatureManager对象构造函数。
     * 
     * Parameters:
     * options - {Object} 相关选项设置。
     */
	initialize: function(options){
		this._typeMapping = {};
		this.styleMap = Geo.View2D.FeatureManager.defaultStyleMap;
		this.registerResultType("default");
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: setMap
     * 将要素管理器关联到相应的二维视图对象。在关联到二维视图对象时,会在二维视图对象中
     * 加入一个矢量图层和选择控件，矢量图层和选择控件的引用可以通过访问vectorLayer和
     * selectControl属性的获得。
     *
     * Parameters:
     * map - {<Geo.View2D.Map>} 地图对象。
     */
	setMap: function(map){
		if(map && !this.map){
			this.map = map;
			
			//添加结果图层
			this.vectorLayer = new OpenLayers.Layer.Vector("GeoGlobeFeatureManagerVector", {
				styleMap: this.styleMap,
				isOnTop: true,
				displayInLayerSwitcher: false,
				//要素的显示级别设置为开启状态，默认为false
				rendererOptions: {zIndexing: true}
			});
			this.map.addLayer(this.vectorLayer);
			this._initSelectControl();
			this._addTopicDiv();
		}
	},

	/**
     * APIMethod: registerFeatureSort
     * 注册要素类别。如果希望对多个分类的要素进行管理，则需要先注册要素类别加以区分，
     * 然后再调用addFeatures方法向分类中添加要素集。
     *
     * Parameters:
     * sort - {String} 要素分类。
     * options - {Object} 参数设置。
     */	
    registerFeatureSort: function(sort,options){
		var DEFAULT_PARAMS = {
			features:[],
			currentPage:0,
			maxFeaturesPerPage: this.maxFeaturesPerPage,
			onTurnToPage: this.onTurnToPage,
			onFeatureSelect: Geo.View2D.FeatureManager.showFramedCloud,
			onFeatureUnselect: Geo.View2D.FeatureManager.closeFramedCloud,
			onFeatureOver: Geo.View2D.FeatureManager.showTopic,
			onFeatureOut: Geo.View2D.FeatureManager.closeTopic
		};
		this._typeMapping[sort] = OpenLayers.Util.extend(DEFAULT_PARAMS,options);        
    }, 
     
    //此方法已被废弃，推荐使用registerResultSort
	registerResultType: function(type,options){
        this.registerFeatureSort(type,options);
	},
	
	/**
     * APIMethod: addFeatures
     * 向类别中添加要素，要素添加到类别后将在要素的外部属性中加上类型标识。
     *
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 添加的要素数组。
     * sort - {String} 要素类别。
     * isAppend - {Boolean} 是否追加要素。
     */		
	addFeatures: function(features,sort,isAppend){
		sort = sort || "default";
		if(!(Geo.Util.isArray(features))) {
			features = [features];
		}
		if(this._typeMapping[sort]){
			var features =  this._addTypeMarker(features,sort);
			
			//为要素添加自定义样式
			var style = this._typeMapping[sort].style;
			if(style){
				this._addStyleForFeatures(features,style);
			}
			
			if(!isAppend){
				this.clearResultFromMap(sort);
				this._typeMapping[sort].features = features;
			} else {
				this._typeMapping[sort].features = this._typeMapping[sort].features.concat(features);
			}
			this._typeMapping[sort].currentPage = 0;
		}
	},
	
	/**
	 * APIMethod: onTurnToPage
	 * 获取当前页的要素，本方法需要用户自己去覆盖。
	 * 
	 */
	onTurnToPage: function(feature){
		
	},
	
	/**
     * APIMethod: turnToPageN。
     * 翻到指定页数。
     *
     * Parameters:
     * page - {Integer} 当前第几页。
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */	
	turnToPageN: function(page, sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];

		var pageNum = this.getTotalPageNumber(sort);
		page = (page <= 0) ? 1 : page;
		page = (page > pageNum) ? pageNum : page; 
				
		var features = this._pagingFeatures({
			maxPerPage: mapping.maxFeaturesPerPage,
			pageNum:page,
			resultArr:mapping.features
		});
		
		this.addOrderForFeatures(features);
				
		if(page !== mapping.currentPage){
			this.clearResultFromMap(sort);
			this.drawFeaturesToMap(features);
			mapping.currentPage = page;
		}
		mapping.onTurnToPage(features);
		
		return features;
	},
	
	/**
     * APIMethod: turnToFirst
     * 翻到首页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToFirst: function(sort, isDrawToMap){
		sort = sort || "default";
		return this.turnToPageN(1,sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToNext
     * 翻到下页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToNext: function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage + 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToPre
     * 翻到前页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToPre: function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage - 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToLast
     * 翻到尾页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToLast: function(sort, isDrawToMap){
		sort = sort || "default";
		var last = this.getTotalPageNumber(sort);
		this.turnToPageN(last, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: getPageInfo
     * 获取分页相关情况。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */		
	getPageInfo: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getTotalPageNumber
     * 获取指定类别的要素分页页数。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */			
	getTotalPageNumber: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getFeatures
     * 获取指定结果类型的要素。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */		
	getFeatures: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		if(mapping && mapping.features) {
			return mapping.features;
		}else {
			return [];
		}
	},
	
	/**
     * APIMethod: drawFeaturesToMap
     * 将要素绘制到地图上，可以是指定类型或指定要素数组。
     *
     * Parameters:
     * content - {String|Array(<Geo.Feature.Vector>)} 要素类别。
     */		
	drawFeaturesToMap: function(content){
		var map, layer, features;
		map = this.map;
		layer = this.vectorLayer;
		
		if( typeof(content) == "string"){
			var sort = content || "default";
			if(this._typeMapping[sort] && map){
				features = this.getFeatures(sort);
			}

		};
		
		if( content instanceof  Array){
			features = content;
		};
		layer.addFeatures(features);
        
        var dataExtent = layer.getDataExtent();
        if(dataExtent){
            layer.map.zoomToExtent(dataExtent);
        }
	},
	
	/**
     * APIMethod: selectFeatureById
     * 通过ID来指定要素,通过选择控件来选择。
     *
     * Parameters:
     * featureid - {String} 要素类别。
     */	
	selectFeatureById: function(featureid){
		this.selectControl.unselectAll();
		var feature = this.vectorLayer.getFeatureById(featureid);
		//重绘的目的是为了解决点重叠的问题
		this.vectorLayer.drawFeature(feature);
		this.selectControl.select(feature);
		feature.selectControl = this.selectControl;
	},

	/**
     * APIMethod: clearFeatureFromMap
     * 清除指定类别要素,如无指定类别则默认清除"default"类别，如果指定值为"allType"则清除所有分类要素。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */		
	clearFeatureFromMap: function(sort){		
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features;
		var layer = this.vectorLayer;
		if(sort == "allType"){
			features = this.vectorLayer.features;
		} else {
			features = mapping ? mapping.features : [];
		}
		
		if(layer){
			this.selectControl.unselectAll();
			layer.removeFeatures(features);
		}
		
		
	},

    //此方法被废弃，推荐使用clearFeatureFromMap
	clearResultFromMap: function(sort){		
		this.clearFeatureFromMap(sort);
	},
    
	/**
     * APIMethod: clearFeatures
     * 清除指定类型结果要素,如无指定类型则默认清除"default"类型，如果指定值为"allType"则清除所有分类要素。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */	
    clearFeatures: function(sort){
        sort = sort || "default";
        var mapping = this._typeMapping[sort];
        if(mapping){
            this.clearResultFromMap(sort);
            mapping.features = [];
        }
    },

    //此方法被废弃，推荐使用clearFeatures
    clearResult: function(sort){
        this.clearFeatures(sort);
    },
	
	/**
     * APIMethod: addOrderForFeatures
     * 为要素数组中每个要素按顺序添加编号，编号是记录在“orderNumberField”属性指定的要素。
     * 外部属性中。
     *
     * Parameters:
     * features - {Array<Geo.Feature.Vector>} 要素数组。
     * 
     * Returns:
     * {Array<Geo.Feature.Vector>}
     */	
	addOrderForFeatures: function(features){
		//添加带序号的结果图标
	    for (var i = 0; i < features.length; i++) {
	        features[i].attributes[this.orderNumberField] = i;
	    }
		return features;
	},
	
	//为要素加上样式
	_addStyleForFeatures: function(features, style){
		for(var i=0; i<features.length; i++){
			var f = features[i];
			if(!f.style){
				f.style = style;
			}
		}
	},
	
	//为每个要素添加类型标识属性
	_addTypeMarker: function(features,type){
		for(var i=0; i<features.length; i++){
			var feature = features[i];
			feature.attributes[this.featureSortField] = type;
		}
		return features;
	},
	
	_addTopicDiv: function(){
		var mapid = this.map.id;
		var topicDiv = OpenLayers.Util.getElement(mapid + "featureManagerTopic");
		if(!topicDiv){
			topicDiv = document.createElement("div");
			if(!this.topicCSSClass){
				topicDiv.style.backgroundColor = "#fff";
				topicDiv.style.border = "1px solid #000";
				topicDiv.style.padding = "3px";
				topicDiv.style.position = "absolute";
				topicDiv.style.top = "30px";
				topicDiv.style.left = "30px";
				topicDiv.style.display = "none"
				topicDiv.innerHTML = "test";
				
			}
			this.map.div.appendChild(topicDiv);
			this.topicDiv = topicDiv;
		}
		
	},

	
	/**
	 * 对指定结果要素数组进行分页处理。
	 * options示例:
	 * {
	 * 		maxPerPage:15,
	 * 		pageNum:1,
	 * 		resultArr:[]
	 * }
	 */
	_pagingFeatures: function(options){
	    var start, end, 
			maxPerPage = options.maxPerPage, 
			pageNum = options.pageNum, 
			resultArr = options.resultArr;
	    start = (pageNum - 1) * maxPerPage;
	    end = pageNum * maxPerPage - 1;
	    
		var features = resultArr.slice(start, end + 1);
	    
	    
	    
	    return features;
	},
	
	//根据事件类型分派事件
	_dispatchEvent: function(scope,feature,eventType){
		var resultType = feature.attributes[scope.featureSortField];
		var mapping = scope._typeMapping[resultType];
		mapping[eventType](feature);
	},
	
	//激活选择控件,自动检查是否控件初始化
	_initSelectControl: function(){
		if(!this.map){
			return;
		}
		if(!this.selectControl){
			var DEFAULT_OPTIONS = {
				onSelect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureSelect");
				},this),
				onUnselect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureUnselect");
				},this),
				callbacks:{
					over: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOver");
					},this),
					out: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOut");
					},this)
				}
			};
            
            var options = OpenLayers.Util.applyDefaults(this.selectControlOptions,DEFAULT_OPTIONS);
			//添加选择控件
			this.selectControl = new Geo.View2D.Control.SelectFeature(this.vectorLayer,options)
			this.map.addControl(this.selectControl);
		}
	}
});

/**
 * APIProperty: Geo.View2D.FeatureManager.defaultStyleMap
 * {<Geo.StyleMap>} FeatureManager中vectorLayer图层的默认要素样式。
 */
Geo.View2D.FeatureManager.defaultStyleMap = new Geo.StyleMap({
    "default": new Geo.Style({
    	externalGraphic: OpenLayers.Util.getImagesLocation() + "marker.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    }) ,
    "select": new Geo.Style({
        externalGraphic: OpenLayers.Util.getImagesLocation() + "marker-blue.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    })
});

/**
 * APIMethod: Geo.View2D.FeatureManager.showFramedCloud
 * 为要素添加浮云，如果指定内容模板则浮云内空按模板规则生成。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素。
 * templateString - 字符串内容模板。
 * 
 */
Geo.View2D.FeatureManager.showFramedCloud = function(feature, templateString){
    var layer = feature.layer, map = layer ? layer.map : null;
	if(!layer || !map){
		return;
	}
	var str;
	if(templateString){
		str = templateString;
	} else {
		str = (function(){
	        var str = "";
	        for (var myitem in feature.attributes) {
	            str += myitem + ":" + feature.attributes[myitem] + "<br>";
	        }
	        return str;
	    })();
	}
    
	var lonlat = null;
	if("OpenLayers.Geometry.LineString" == feature.geometry.CLASS_NAME) {
		var location = Math.floor(feature.geometry.components.length / 2) ;
		var tempPoint = feature.geometry.components[location];
		lonlat = new Geo.LonLat(tempPoint.x,tempPoint.y);
	}else {
		lonlat = feature.geometry.getBounds().getCenterLonLat();
	}
    if (map) {
		//直接定位到中心点，没有平滑效果
        map.setCenter(lonlat);
    }
    
    var popup = new Geo.View2D.Popup.FramedCloud(
		"featureInfo", 
		lonlat, 
		null, 
		str, 
		null, 
		true, 
		Geo.View2D.FeatureManager.onPopupClose
	);
    feature.popup = popup;
	//浮云关联到要素，因为关闭浮云的时候需要取消要素的选择
	popup.feature = feature;
	if(this.selectControl) {
		feature.selectControl = this.selectControl;
	}
    map.addPopup(popup);
};

/**
 * APIMethod: Geo.View2D.FeatureManager.closeFramedCloud
 * 关闭并消毁指定要素上添加的浮云。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素。
 * 
 */
Geo.View2D.FeatureManager.closeFramedCloud = function(feature){
    var layer = feature.layer, map = layer ? layer.map : null;
    if (feature.popup && layer && map) {
        map.removePopup(feature.popup);
        feature.popup.destroy();
        feature.popup = null;
    }
};

/**
 * APIMethod: Geo.View2D.FeatureManager.onPopupClose
 * 浮云关闭时触发的方法。
 */
Geo.View2D.FeatureManager.onPopupClose = function(){
	//关闭浮云的时候取消选择,如果要素关联到控件，则执行取消操作，如果没有，直接清除浮云
	if(this.feature && this.feature.selectControl) {
		this.feature.selectControl.unselect(this.feature);
	}else {
		var map = this.map;
	    if (map) {
	        map.removePopup(this);
	    }
	}
}
	
Geo.View2D.FeatureManager.showTopic = function(feature){
	
};
	
Geo.View2D.FeatureManager.closeTopic = function(feature){
	
};
/**
 * Class: Geo.View2D.MarkerTag
 * 标注的自定义标签类。
 */
Geo.View2D.MarkerTag = Geo.Class({
    
    /** 
     * Property: size 
     * {<Geo.Size>} 自定义标签的尺寸大小。
     */
    size: null,

    /** 
     * Property: offset 
     * {<Geo.Pixel>} 像素对象，表示自定义标签的偏移量。
     */
    offset: null,    
    
    /** 
     * Property: calculateOffset 
     * {Function} 计算偏移量的函数（参数为this.size）。
     */
    calculateOffset: null,    
    
    /** 
     * Property: div
     * {DOMElement} 自定义标签的DIV容器。
     */
    div: null,

    /** 
     * Property: px 
     * {<Geo.Pixel>} 屏幕像素对象，表示在地图上的屏幕位置。
     */
    px: null,
    
    /** 
     * Constructor: Geo.View2D.MarkerTag
     * Geo.View2D.MarkerTag对象构造函数。
     *
     * html - {String} 自定义html字符串。
     * size - {<Geo.Size>} 标签尺寸大小。
     * offset - {<Geo.Pixel>} 标签的偏移量对象。
     * calculateOffset - {Function} 计算偏移量的函数（参数为this.size）。
     */
    initialize: function(html, size, offset, calculateOffset) {
		this.html = html;
		
		var containerElement = (this.map) ? this.map.layerContainerDiv : document.body;
        var realSize = OpenLayers.Util.getRenderedDimensions(html, null, {
            containerElement: containerElement
        });
        this.size = (size) ? size : realSize;
		
		
        this.offset = offset ? offset : new Geo.Pixel(-(this.size.w/2), -(this.size.h/2));
        this.calculateOffset = calculateOffset;

        var id = OpenLayers.Util.createUniqueID("OL_Div_");
		this.div = OpenLayers.Util.createDiv(id, null, null, null, "absolute", null, null, null);
    },
    
    /** 
     * Method: destroy
     * 销毁该对象。
     */
    destroy: function() {
        // erase any drawn elements
        this.erase();

        this.div.innerHTML = "";
        this.div = null;
    },

    /** 
     * Method: clone
     * 返回本对象的副本。
     * 
     * Returns:
     * {<Geo.View2D.MarkerTag>} 该类的实例。
     */
    clone: function(){
        return new Geo.View2D.MarkerTag(this.html, this.size, this.offset, this.calculateOffset);
    },
    
    /**
     * Method: setSize
     * 设置尺寸大小。
     * 
     * Parameters:
     * size - {<Geo.Size>} 尺寸大小对象。
     */
    setSize: function(size) {
        if (size != null) {
            this.size = size;
        }
        this.draw();
    },
    
    /**
     * Method: setContentHTML
     * 设置HTML内容。
     * 
     * Parameters:
     * html - {String} 内容为HTML字符串。
     */
    setContentHTML: function(html) {
        if (html != null) {
            this.html = html;
        }
        this.draw();
    },
	
    /** 
     * Method: draw
     * 绘制该自定义标签。
     * 
     * Parameters:
     * px - {<Geo.Pixel>} 屏幕像素对象。
     * 
     * Returns:
     * {DOMElement} 返回该自定义标签的DIV元素。
     */
    draw: function(px) {
		OpenLayers.Util.modifyDOMElement(this.div, null, null, this.size, "absolute");
		this.div.innerHTML = this.html;
        this.moveTo(px);
        return this.div;
    }, 

    /** 
     * Method: erase
     * 清除自定义标签的DIV元素。
     */
    erase: function() {
        if (this.div != null && this.div.parentNode != null) {
            OpenLayers.Element.remove(this.div);
        }
    }, 
    
    /** 
     * Method: setOpacity
     * 设置透明度。
     *
     * Parameters:
     * opacity - {float} 透明度值，范围：0~1，浮点类型。
     */
    setOpacity: function(opacity) {
		OpenLayers.Util.modifyDOMElement(this.div, null, null, null, null, null, null, opacity);

    },
    
    /**
     * Method: moveTo
     * 移动自定义标签。
     *
     * Parameters:
     * px - {<Geo.Pixel>} 屏幕像素对象。
     */
    moveTo: function (px) {
        //if no px passed in, use stored location
        if (px != null) {
            this.px = px;
        }

        if (this.div != null) {
            if (this.px == null) {
                this.display(false);
			} else {
                if (this.calculateOffset) {
                    this.offset = this.calculateOffset(this.size);
                }
                var offsetPx = this.px.offset(this.offset);
                OpenLayers.Util.modifyDOMElement(this.div, null, offsetPx);
            }
        }
    },
    
    /** 
     * Method: display
     * 显示或隐藏自定义标签。
     *
     * Parameters:
     * display - {Boolean} 是否显示的标识。
     */
    display: function(display) {
        this.div.style.display = (display) ? "" : "none"; 
    },
    

    /**
     * APIMethod: isDrawn
     * 是否已经绘制。
     * 
     * Returns:
     * {Boolean} 是否已经绘制，返回值为布尔类型。
     */
    isDrawn: function() {
        // nodeType 11 for ie, whose nodes *always* have a parentNode
        // (of type document fragment)
        var isDrawn = (this.div && this.div.parentNode && 
                       (this.div.parentNode.nodeType != 11));    

        return isDrawn;   
    },

    CLASS_NAME: "Geo.View2D.MarkerTag"
});
/**
 * Class: Geo.View2D.Control.DrawCircle
 * 几何圆绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawCircle = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件类型
     */    
	type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: sides
     * {Integer} 圆是由正多边形构成的，sides是构成圆的正多边形的边的数目，默认值为40。 
     */
	sides: 40,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
	
	/**
	 * Constructor: Geo.View2D.Control.DrawCircle
	 * Geo.View2D.Control.DrawCircle构造函数
	 */
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.RegularPolygon(
							this, 
							{ "done": this.done }, 
							{ "sides": this.sides , persist: this.persist });
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */
    done: function(geometry){
        
    },
    
	CLASS_NAME: "Geo.View2D.Control.DrawCircle"
});
/**
 * Class: Geo.View2D.Control.DrawPath
 * 几何线绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawPath = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件有一个类型。类型决定了控件生成实例时在控件栏上的存放位置。 
     */  
    type: Geo.View2D.Control.TYPE_TOOL,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
    
	/**
	 * Constructor: Geo.View2D.Control.DrawPath
	 * 构造函数。生成一个Geo.View2D.Control.DrawPath的实例。
	 */    
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.Path(this, {
            "done": this.done
        },{ 
            persist: this.persist 
        });
    },

	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */	
    done: function(geometry){
        
    },
	
	CLASS_NAME: "Geo.View2D.Control.DrawPath"
});
/**
 * Class: Geo.View2D.Control.DrawPoint
 * 几何点绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawPoint = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件有一个类型。类型决定了控件生成实例时在控件栏上的存放位置。 
     */
    type: Geo.View2D.Control.TYPE_TOOL,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
       
 	/**
	 * Constructor: Geo.View2D.Control.DrawPoint
	 * 构造函数。生成一个Geo.View2D.Control.DrawPoint的实例。
	 */     
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.Point(this, {
            "done": this.done
        },{ 
            persist: this.persist 
        });
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */		
    done: function(geometry){
        
    },
	
	CLASS_NAME: "Geo.View2D.Control.DrawPoint"
});
/**
 * Class: Geo.View2D.Control.DrawPolygon
 * 几何多边形绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawPolygon = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件有一个类型。类型决定了控件生成实例时在控件栏上的存放位置。 
     */
    type: Geo.View2D.Control.TYPE_TOOL,
 
    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
    
 	/**
	 * Constructor: Geo.View2D.Control.DrawPolygon
	 * 构造函数。生成一个Geo.View2D.Control.DrawPolygon的实例。
	 */   
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.Polygon(this, {
            "done": this.done
        });
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 
     */		
    done: function(geometry){
        
    },
    
	CLASS_NAME: "Geo.View2D.Control.DrawPolygon"
});
/**
 * Class: Geo.View2D.Control.DrawRectangle
 * 几何矩形绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawRectangle = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件类型。
     */
    type: Geo.View2D.Control.TYPE_TOOL,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
 	
	/**
	 * Constructor: Geo.View2D.Control.DrawRectangle
	 * Geo.View2D.Control.DrawRectangle构造函数。
	 */   
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.RegularPolygon(
			this,
			{ "done": this.done }, 
			{ irregular: true, persist: this.persist }
		);
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */		
    done: function(geometry){},
	
	CLASS_NAME: "Geo.View2D.Control.DrawRectangle"
});
/**
 * Class: Geo.View2D.Control.MagnifyingGlass
 * 鼠标滚轮滚动时的绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * 例如:
 * (code)
 * this.controls = [ new Geo.View2D.Control.Navigation(),
 *                            new Geo.View2D.Control.PanZoomBar(),
 *                            new Geo.View2D.Control.ArgParser(),
 *                            new Geo.View2D.Control.Attribution(),
 *							  new Geo.View2D.Control.MagnifyingGlass()//将其加入控件数组
 *                           ];
 * (end)
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.MagnifyingGlass = Geo.Class(Geo.View2D.Control, {
	/**
	 * APIProperty: autoActivate
	 * 是否自动激活。
	 */
    autoActivate: true,
	
	/**
	 * Constructor: Geo.View2D.Control.MagnifyingGlass
     * Geo.View2D.Control.MagnifyingGlass构造函数。
	 */
    initialize: function(){
        Geo.View2D.Control.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * Method: draw
	 */
    draw: function(){
        Geo.View2D.Control.prototype.draw.apply(this, arguments);
        this.handler = new Geo.View2D.Handler.MouseWheel(this, {
            "down": this.magnifyingglassZoomOut,
            "up": this.magnifyingglassZoomIn
        });
        this.initDiv();
        
    },
    
	/**
	 * Method：initDiv
	 */
    initDiv: function(){
        var a = OpenLayers.Util.createDiv("map_magnifyingglass" + this.id.split("_")[1]);
        a.style.borderRight = "medium none";
        a.style.borderTop = "medium none";
        a.style.borderLeft = "medium none";
        a.style.borderBottom = "medium none";
        a.style.width = "111px";
        a.style.height = "74px";
        a.style.display = "none";
        a.style.unselectable = "on";
        var c = OpenLayers.Util.createDiv();
        c.style.lineHeight = "1px";
        c.style.width = "4px";
        c.style.height = "4px";
        c.style.left = "0";
        var b = OpenLayers.Util.createDiv();
        b.style.lineHeight = "1px";
        b.style.width = "4px";
        b.style.height = "4px";
        b.style.right = "0";
        var d = OpenLayers.Util.createDiv();
        d.style.lineHeight = "1px";
        d.style.width = "4px";
        d.style.height = "4px";
        d.style.right = "0";
        d.style.top = "40px";
        var e = OpenLayers.Util.createDiv();
        e.style.lineHeight = "1px";
        e.style.width = "4px";
        e.style.height = "4px";
        e.style.left = "0";
        e.style.top = "40px";
        a.appendChild(c);
        a.appendChild(b);
        a.appendChild(d);
        a.appendChild(e);
        this.map.viewPortDiv.appendChild(a)
    },
    
    bw_out: null,
    bw_in: null,
    variable: 1,
	
	/**
	 * Method：getTimeout
	 * Parameters:
	 * a - {Object} 
	 * b - {Object} 
	 * c - {Object} 
	 */
    getTimeout: function(a, b, c){
        return window.setTimeout(function(){
            b.apply(a)
        }, c)
    },
	/**
	 * Method：magnifyingglassZoomOut
	 * Parameters:
	 * a - {Object}
	 */
    magnifyingglassZoomOut: function(a){
        if (this.variable == 1) {
            var b = OpenLayers.Util.getElement("map_magnifyingglass" + this.id.split("_")[1]);
            if (b) {
                b.style.width = 111;
                b.style.height = 74;
                this.evt = a;
                this.out()
            }
        }
    },
	
	/**
	 * Method：magnifyingglassZoomIn
	 * Parameters:
	 * a - {Object}
	 */
    magnifyingglassZoomIn: function(a){
        if (this.variable == 1) {
            var b = OpenLayers.Util.getElement("map_magnifyingglass" + this.id.split("_")[1]);
            if (b) {
                b.style.width = "27px";
                b.style.height = "24px";
                this.evt = a;
                this.in_()
            }
        }
    },
	
	/**
	 * Method：out
	 */
    out: function(){
        this.Rx1(true)
    },
	
	/**
	 * Method：in_
	 */
    in_: function(){
        this.Rx1(false)
    },
	
	/**
	 * Method：Rx1
	 * Parameters:
	 * a - {Object}
	 */
    Rx1: function(a){
        var b = OpenLayers.Util.getElement("map_magnifyingglass" + this.id.split("_")[1]);
        if (this.variable <= 4) {
            if (b) {
                var c = 1, d;
                if (a) {
                    d = parseInt(b.style.width);
                    obj_h = parseInt(b.style.height);
                    c *= 15;
                    if (d >= 30) {
                        if (d && c) 
                            b.style.width = Math.abs(d - (c + 6)) + "px";
                        if (obj_h >= 25) 
                            if (obj_h && c) 
                                b.style.height = Math.abs(obj_h - c) + "px";
                        b.style.left = this.evt.xy.x -
                        parseInt(b.style.width) /
                        2 +
                        "px";
                        b.style.top = this.evt.xy.y -
                        parseInt(b.style.height) /
                        2 +
                        "px";
                        b.childNodes[0].style.borderWidth = "0px 2px 2px 0px";
                        b.childNodes[0].style.borderStyle = "solid";
                        b.childNodes[0].style.borderColor = "red";
                        b.childNodes[1].style.borderWidth = "0px 0px 2px 2px";
                        b.childNodes[1].style.borderStyle = "solid";
                        b.childNodes[1].style.borderColor = "red";
                        b.childNodes[2].style.borderWidth = "2px 0px 0px 2px";
                        b.childNodes[2].style.borderStyle = "solid";
                        b.childNodes[2].style.borderColor = "red";
                        b.childNodes[3].style.borderWidth = "2px 2px 0px 0px";
                        b.childNodes[3].style.borderStyle = "solid";
                        b.childNodes[3].style.borderColor = "red";
                        b.childNodes[2].style.top = b.style.height;
                        b.childNodes[3].style.top = b.style.height;
                        b.style.display = "";
                        b.style.zIndex = 1010
                    }
                    this.variable++;
                    this.bw_out = this.getTimeout(this, a ? this.out : this.in_, 60)
                }
                else {
                    d = parseInt(b.style.width);
                    obj_h = parseInt(b.style.height);
                    c *= 15;
                    if (d <= 111) {
                        b.style.width = Math.abs(d + c) + "px";
                        if (obj_h <= 64) 
                            b.style.height = Math.abs(obj_h + c) + "px";
                        b.style.left = this.evt.xy.x -
                        parseInt(b.style.width) /
                        2 +
                        "px";
                        b.style.top = this.evt.xy.y -
                        parseInt(b.style.height) /
                        2 +
                        "px";
                        b.childNodes[0].style.borderWidth = "2px 0px 0px 2px";
                        b.childNodes[0].style.borderStyle = "solid";
                        b.childNodes[0].style.borderColor = "red";
                        b.childNodes[1].style.borderWidth = "2px 2px 0px 0px";
                        b.childNodes[1].style.borderStyle = "solid";
                        b.childNodes[1].style.borderColor = "red";
                        b.childNodes[2].style.borderWidth = "0px 2px 2px 0px";
                        b.childNodes[2].style.borderStyle = "solid";
                        b.childNodes[2].style.borderColor = "red";
                        b.childNodes[3].style.borderWidth = "0px 0px 2px 2px";
                        b.childNodes[3].style.borderStyle = "solid";
                        b.childNodes[3].style.borderColor = "red";
                        b.childNodes[2].style.top = b.style.height;
                        b.childNodes[3].style.top = b.style.height;
                        b.style.display = "";
                        b.style.zIndex = 1010
                    }
                    this.variable++;
                    this.bw_in = this.getTimeout(this, a ? this.out : this.in_, 100)
                }
            }
        }
        else {
            if (a) {
                window.clearTimeout(this.bw_out);
                this.bw_out = null
            }
            else {
                window.clearTimeout(this.bw_in);
                this.bw_in = null
            }
            this.variable = 1;
            b.style.display = "none";
            b.style.zIndex = 0;
            b.style.width = "111px";
            b.style.height = "74px"
        }
    },
	
	CLASS_NAME: "Geo.View2D.Control.MagnifyingGlass"
});
/**
 * Class: Geo.View2D.Control.PanZoomBarTitle
 * 带标题的导航控件类，继承自Geo.View2D.Control.PanZoom类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.PanZoom>
 */
Geo.View2D.Control.PanZoomBarTitle = Geo.Class(Geo.View2D.Control.PanZoom, {
	/** 
     * APIProperty: zoomStopWidth
     * 缩放停止的宽度，默认为：18。
     */
    zoomStopWidth: 18,   

    /** 
     * APIProperty: zoomStopHeight
     * 缩放停止的高度，默认为：11。
     */
    zoomStopHeight: 11,
	
	/** 
     * Property: slider
     */
    slider: null,
	
	/** 
     * Property: sliderEvents
     * {<Geo.Events>}
     */
    sliderEvents: null,
	
	/** 
     * Property: zoombarDiv
     * {DOMElement}
     */
    zoomBarDiv: null,
	
	/** 
     * Property: divEvents
     * {<Geo.Events>}
     */
    divEvents: null,
	
	/** 
     * APIProperty: zoomWorldIcon
     * {Boolean} 是否在导航栏上显示一个定位至全球范围的图标。默认为false。
     */
    zoomWorldIcon: false,
	
	/** 
     * Property: leftTip
     * {Array(DOMElement)} 
     */
    leftTip: [],
	
	/** 
     * Property: leftTooltips
     * {String} 
     */
    leftTooltips: null,
	
	/** 
     * APIProperty: imageLocation
     * > {String} 显示地图导航杆控件的页面与引用地图导航杆图片资源文件（panzoombar_blue）的相对路径。
     * > 例如：地图导航杆图片资源文件（panzoombar_blue）在当前页面的上三级目录，则路径设置为"../../../"。
     * 
     * Examples:
	 * (code)
	 * var panZoomBarTitle = new Geo.View2D.Control.PanZoomBarTitle({
	 *     imageLocation: "../../../"
	 * });
	 * (end)
     */
    imageLocation: "",

    /**
     * Constructor: Geo.View2D.Control.PanZoomBarTitle
     * 构造一个新的<Geo.View2D.Control.PanZoomBarTitle>对象实例。
     */ 
    initialize: function(options){
		this.imageLocation = Geo.getScriptLocation() + "images/";
        OpenLayers.Control.PanZoom.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        this._removeZoomBar();
        this.map.events.un({
            "changebaselayer": this.redraw,
            scope: this
        });
        OpenLayers.Control.PanZoom.prototype.destroy.apply(this, arguments);
    },
	
    /**
     * Method: setMap
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map){
        OpenLayers.Control.PanZoom.prototype.setMap.apply(this, arguments);
        this.map.events.register("changebaselayer", this, this.redraw);
    },
	
    /** 
     * Method: redraw
     * clear the div and start over.
     */
    redraw: function(){
        if (this.div != null) {
            this.removeButtons();
            this._removeZoomBar();
        }
        this.draw();
    },
	
    /**
    * Method: draw 
    *
    * Parameters:
    * px - {<Geo.Pixel>} 
    */
    draw: function(px){
        // initialize our internal div
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        px = this.position.clone();
        
        // place the controls
        this.buttons = [];
        this.leftTip = [];
        var sz = new OpenLayers.Size(24, 24);
        var centered = new OpenLayers.Pixel(px.x + sz.w / 2, px.y);
        var wposition = sz.w;
        
        if (this.zoomWorldIcon) {
            centered = new OpenLayers.Pixel(px.x + sz.w, px.y);
        }
        
        this._addButton("panup", "panzoombar_blue/north-mini.png", centered, sz, "向上平移");
        px.y = centered.y + sz.h;
        this._addButton("panleft", "panzoombar_blue/west-mini.png", px, sz, "向左平移");
        if (this.zoomWorldIcon) {
            this._addButton("zoomworld", "panzoombar_blue/zoom-world-mini.png", px.add(sz.w, 0), sz, "全部地图");
            
            wposition *= 2;
        }
        this._addButton("panright", "panzoombar_blue/east-mini.png", px.add(wposition, 0), sz, "向右平移");
        this._addButton("pandown", "panzoombar_blue/south-mini.png", centered.add(0, sz.h * 2), sz, "向下平移");
        this._addButton("zoomin", "panzoombar_blue/zoom-plus-mini.png", centered.add(0, sz.h * 3 + 5), sz, "放大一级");
        centered = this._addZoomBar(centered.add(3, sz.h * 4 + 5));
        this._addButton("zoomout", "panzoombar_blue/zoom-minus-mini.png", centered.add(-3, 0), sz, "缩小一级");
        //添加 zoomToolTip
        var tooltipSZ = new OpenLayers.Size(62, 12);
        this._addZoomToolTip("zoomtooltip", "panzoombar_blue/zoom_0.png", centered.add(20, 0), tooltipSZ);
        
        //x :图片的宽度
		/** 金字塔的分辨率如下
        RESOLUTIONS: [
        1.40625, 
        0.703125, 
        0.3515625, 
        0.17578125, 
        0.087890625, 
        0.0439453125,
        0.02197265625, 
        0.010986328125, 
        0.0054931640625, 
        0.00274658203125,
        0.001373291015625, 
        0.0006866455078125, 
        0.00034332275390625,
        0.000171661376953125, 
        0.0000858306884765625, 
        0.00004291534423828125,
        0.00002145767211914062, 
        0.00001072883605957031,
        0.00000536441802978515, 
        0.00000268220901489257,
        0.0000013411045074462891,
        0.00000067055225372314453]
        **/
        
        this.leftTooltips = {
			/*
            zltGlb: {
                url: "panzoombar_blue/zoom_Global.png",
                x: 33,
                res: 0.3515625
            },
            zltContinent: {
                url: "panzoombar_blue/zoom_Continent.png",
                x: 23,
                res: 0.087890625
            },
            */
            zltCountry: {
                url: "panzoombar_blue/zoom_Country.png",
                x: 23,
                res: 0.087890625
            },
            zltPro: {
                url: "panzoombar_blue/zoom_Province.png",
                x: 23,
                res: 0.010986328125
            },
            zltCity: {
                url: "panzoombar_blue/zoom_City.png",
                x: 23,
                res: 0.001373291015625
            },
            zltStr: {
                url: "panzoombar_blue/zoom_Street.png",
                x: 23,
                res: 0.00001072883605957031
            }
        };
        for (var myitem in this.leftTooltips) {
            var leftTooltipObj = this.leftTooltips[myitem];
            this._addZoomLeftTip(myitem, leftTooltipObj.url, centered.add(-leftTooltipObj.x, 0), new OpenLayers.Size(leftTooltipObj.x, 17), leftTooltipObj.res);
        }
        //centred, slider位置(x,y)
        return this.div;
    },
	
	/**
     * Method: _addButton
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addButton:function(id, img, xy, sz) {
        var btn = OpenLayers.Util.createAlphaImageDiv(
                                    this.id + "_" + id, 
                                    xy, sz, this.imageLocation + img, "absolute");
 		btn.style.cursor = "pointer";
        //we want to add the outer div
        this.div.appendChild(btn);

        OpenLayers.Event.observe(btn, "mousedown", 
            OpenLayers.Function.bindAsEventListener(this.onButtonClick, btn));
        OpenLayers.Event.observe(btn, "dblclick", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        OpenLayers.Event.observe(btn, "click", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        btn.action = id;
        btn.map = this.map;
    
        if(!this.slideRatio){
            var slideFactorPixels = this.slideFactor;
            var getSlideFactor = function() {
                return slideFactorPixels;
            };
        } else {
            var slideRatio = this.slideRatio;
            var getSlideFactor = function(dim) {
                return this.map.getSize()[dim] * slideRatio;
            };
        }

        btn.getSlideFactor = getSlideFactor;

        //we want to remember/reference the outer div
        this.buttons.push(btn);
        return btn;
    },
	
	/**
     * Method: _addZoomToolTip
     * 添加 zoomToolTip。
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addZoomToolTip: function(id, img, xy, sz){
        var tooltip = OpenLayers.Util.createAlphaImageDiv("OpenLayers_Control_PanZoom_" + id, xy, sz, this.imageLocation + img, "absolute");
        //初始化不显示
        OpenLayers.Control.PanZoomBarTitle.isVisible = false;
        this.tooltip = tooltip;
        this.tooltip.style.display = "none";
        this.div.appendChild(tooltip);
        return tooltip;
    },
	
	/**
     * Method: _addZoomToolTip
     * 添加 _addZoomLeftTip。
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * res - {Float} 地图分辨率（单位：度 /像素）。
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addZoomLeftTip: function(id, img, xy, sz, res){
        if (res <= this.map.baseLayer.maxResolution && res >= this.map.baseLayer.minResolution) {
            var tooltipLeft = OpenLayers.Util.createAlphaImageDiv("OpenLayers_Control_PanZoom_" + id, xy, sz, this.imageLocation + img, "absolute");
            this.tipEvents = new OpenLayers.Events(this, tooltipLeft, null, true, {
                includeXY: true
            });
            
            var mapMaxZoom = this.getCurrentZoomNumFromResolution(this.map.baseLayer.maxResolution, this.map.baseLayer.minResolution);
            var zoom = this.map.getZoomForResolution(res);
            var tipTop = (mapMaxZoom - zoom) * this.zoomStopHeight + this.startTop;
            this.tipEvents.on({
                "click": this.tipClick,
                "mouseover": this.slideMouseOver,
                "mouseout": this.mouseOut
            });
            
            this.leftTip.push(tooltipLeft);
            this.tooltipLeft = tooltipLeft;
            tooltipLeft.res = res;
            tooltipLeft.style.top = (tipTop - 3) + "px";
            tooltipLeft.style.display = "none";
            tooltipLeft.style.cursor = "hand";
            
            this.div.appendChild(tooltipLeft);
            return tooltipLeft;
        }
        else {
            return;
        }
    },
	
	/**
	 * Method: tipClick
	 * 
     * Parameters:
	 * evt - {Object} 
	 */
    tipClick: function(evt){
        var srcElement = evt.srcElement ? evt.srcElement : evt.target;
        var leftTipName = srcElement.id.split("_")[3];
        var res = this.leftTooltips[leftTipName]["res"];
        var zoom = this.map.getZoomForResolution(res);
        if (res == 0.3515625) {
            this.map.setCenter(new OpenLayers.LonLat(104.293175, 0), zoom);
        }
        else {
            this.map.zoomTo(zoom);
        }
        OpenLayers.Event.stop(evt);
    },
	
	/** 
	 * Method: _addZoomBar
     * 
     * Parameters:
     * location - {<Geo.Pixel>} where zoombar drawing is to start.
     */
    _addZoomBar: function(centered){
        
        
        var id = this.id + "_" + this.map.id;
        var zoomsToEnd = this.map.getNumZoomLevels() - 1 - this.map.getZoom();
        var slider = OpenLayers.Util.createAlphaImageDiv(id, centered.add(-1, zoomsToEnd * this.zoomStopHeight), new OpenLayers.Size(20, 9), this.imageLocation + "panzoombar_blue/slider.png", "absolute");
        this.slider = slider;
        
        this.sliderEvents = new OpenLayers.Events(this, slider, null, true, {
            includeXY: true
        });
        this.sliderEvents.on({
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseover": this.slideMouseOver,
            "mouseout": this.mouseOut
        });
        
        var sz = new OpenLayers.Size();
        sz.h = this.zoomStopHeight * this.map.getNumZoomLevels();//zoombar 的高度
        sz.w = this.zoomStopWidth;
        var div = null;
        
        if (OpenLayers.Util.alphaHack()) {
            var id = this.id + "_" + this.map.id;
            div = OpenLayers.Util.createAlphaImageDiv(id, centered, new OpenLayers.Size(sz.w, this.zoomStopHeight), this.imageLocation + "panzoombar_blue/zoombar.png", "absolute", null, "crop");
            div.style.height = sz.h + "px";
        }
        else {
            div = OpenLayers.Util.createDiv('OpenLayers_Control_PanZoomBar_Zoombar' + this.map.id, centered, sz, this.imageLocation + "panzoombar_blue/zoombar.png");
        }
        
        this.zoombarDiv = div;
        
        this.divEvents = new OpenLayers.Events(this, div, null, true, {
            includeXY: true
        });
        this.divEvents.on({
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseout": this.mouseOut
        });
        
        this.div.appendChild(div);
        
        this.startTop = parseInt(div.style.top);
        this.div.appendChild(slider);
        
        this.map.events.register("zoomend", this, this.moveZoomBar);
        
        centered = centered.add(0, this.zoomStopHeight * this.map.getNumZoomLevels());
        return centered;
    },
	
	/**
	 * Method: _removeZoomBar
	 */
    _removeZoomBar: function(){
        this.sliderEvents.un({
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseover": this.slideMouseOver,
            "mouseout": this.mouseOut
        });
        this.sliderEvents.destroy();
        this.divEvents.un({
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseout": this.mouseOut
        });
        this.divEvents.destroy();
        for (var i = 0; i < this.leftTip.length; i++) {
        
            this.div.removeChild(this.leftTip[i]);
        }
        this.tooltipLeft = null;
        
        this.div.removeChild(this.zoombarDiv);
        this.zoombarDiv = null;
        this.div.removeChild(this.slider);
        this.slider = null;
        this.map.events.unregister("zoomend", this, this.moveZoomBar);
    },
	
	/**
	 * Method: slideMouseOver
	 * 
     * Parameters:
	 * evt - {Object} 
	 */
    slideMouseOver: function(evt){
        OpenLayers.Control.PanZoomBarTitle.isVisible = true;
        this.tooltip.style.display = "";
        for (var i = 0; i < this.leftTip.length; i++) {
            this.leftTip[i].style.display = "";
        }
        var fixZoom = this.getCurrentZoomNum();
        var fixTop = ((this.map.getNumZoomLevels() - 1) - this.map.getZoom()) *
        this.zoomStopHeight +
        this.startTop +
        1;
        
        
        var toolTipTop = fixTop;
        this.tooltip.style.top = (toolTipTop - 3) + "px";
        
        var img = this.tooltip.childNodes[0];
        img.src = this.imageLocation + "panzoombar_blue/zoom_" + (parseInt(fixZoom) + 0) + ".png";
    },
	
	/**
	 * Method: passEventToSlider
	 * 鼠标移动响应。
	 * 
     * Parameters:
	 * evt - {Object} 
	 */
    passEventToSlider: function(evt){
		OpenLayers.Control.PanZoomBarTitle.isVisible = true;
		this.tooltip.style.display = "";
		for (var i = 0; i < this.leftTip.length; i++) {
		  this.leftTip[i].style.display = "";
		}
		var newTop = ((this.map.getNumZoomLevels() - 1) - this.map.getZoom()) *
		this.zoomStopHeight +
		this.startTop +
		1;
		
		var overZoom = this.getFixZoom(evt.xy.y) - 10;
		if (overZoom == -1) {
		  overZoom = 0;
		}
		
		//计算当前分辨率相对金字塔级别
		var topTileSize = this.map.pyramid.getTopTileSize();
		var pyramidMaxResolution = (topTileSize.w / this.map.pyramid.tileSize.w) /
		Math.pow(2, this.map.pyramid.topLevelIndex);
		var currentResolution = this.map.getResolutionForZoom(overZoom);
		var fixZoom = this.getCurrentZoomNumFromResolution(pyramidMaxResolution, currentResolution);
		
		var fixTop = ((this.map.getNumZoomLevels() - 1) - overZoom) *
		this.zoomStopHeight +
		this.startTop +
		1;
		
		
		var toolTipTop = fixTop;
		this.tooltip.style.top = (toolTipTop - 3) + "px";
		
		var img = this.tooltip.childNodes[0];
		img.src = this.imageLocation + "panzoombar_blue/zoom_" + (parseInt(fixZoom) + 0) + ".png";
		
		this.sliderEvents.handleBrowserEvent(evt);
    },
    
	/**
	 * Method: getDataExtent
	 * 计算当前分辨率相对于金字塔的级别数
	 */
    getCurrentZoomNum: function(){
        var topTileSize = this.map.pyramid.getTopTileSize();
        var pyramidMaxResolution = (topTileSize.w / this.map.pyramid.tileSize.w) /
        Math.pow(2, this.map.pyramid.topLevelIndex);
        
        var fixZoom = this.getCurrentZoomNumFromResolution(pyramidMaxResolution, this.map.getResolution());
        return fixZoom;
    },
	
    /**
     * Method: getCurrentZoomNumFromResolution
     * 从给定金字塔最大分辨率和地图当前分辨率计算当前级别数
     * 
     * Parameters:
	 * maxRes - {Float} 地图分辨率（单位：度 /像素）
	 * currentRes - {Float} 地图分辨率（单位：度 /像素）
     */
	getCurrentZoomNumFromResolution: function(maxRes,currentRes){
	
		//原计算方法直接取地图当前级别：parseInt(this.map.getZoom());
		//现在的方法计算当前分辨率相对于金字塔最大分辨率的级别
        var zoomRatio =  maxRes / currentRes;
        
        //如果当前分辨率比金字塔最大分辨率还大，说明出错
        if(zoomRatio < 1) return 0;
        
        var zoom = 0;
        while( (zoomRatio / 2) >= 1 ){
        	zoom++;
        	zoomRatio = zoomRatio/2;
        };
        return zoom ;
	},
	
    /**
     * Method: getFixZoom
     * 
     * 
     * Parameters:
	 * height - {Number} 
     */
    getFixZoom: function(height) {
    	var currentZoom = this.map.getZoom();
		var newTop = 
        	((this.map.getNumZoomLevels()-1) - currentZoom) * 
        	this.zoomStopHeight + this.startTop + 6;
        while(true) {
        	var tmp = height - newTop;
        	if(tmp>=0) {
        		if(tmp<this.zoomStopHeight/2) {
        			break;
        		}
        		currentZoom--;
        		newTop = newTop + this.zoomStopHeight;
        	} else {
        		if(tmp>=-this.zoomStopHeight/2) {
        			break;
        		}
        		currentZoom++;
        		newTop = newTop - this.zoomStopHeight;
        	}
        }
        return currentZoom;
    },
	
    /**
     * Method: mouseOut
     * 
     * Parameters:
	 * evt - {Object} 
     */
    mouseOut: function(evt) {
    	var tooltip = this.tooltip;
    	OpenLayers.Control.PanZoomBarTitle.isVisible = false;
    	var callfn = OpenLayers.Function.bind(function() {
			if(!OpenLayers.Control.PanZoomBarTitle.isVisible) {
				tooltip.style.display = "none";
				for(var i=0;i<this.leftTip.length;i++){
		    		this.leftTip[i].style.display = "none";
		    	}
			}
    	},this);
    	
    	window.setTimeout(callfn,1000);
    	OpenLayers.Event.stop(evt);
    },
	
    /**
     * Method: divClick
     * 
     * Parameters:
	 * evt - {Object} 
     */
    divClick: function (evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        var y = evt.xy.y;
        var top = OpenLayers.Util.pagePosition(evt.object)[1];
        var levels = (y - top)/this.zoomStopHeight;
        if(!this.map.fractionalZoom) {
            levels = Math.floor(levels);
        }
        var zoom = (this.map.getNumZoomLevels() - 1) - levels;
        zoom = Math.min(Math.max(zoom, 0), this.map.getNumZoomLevels() - 1);
        this.map.zoomTo(zoom);
        
        OpenLayers.Event.stop(evt);
    },
	
    /**
     * Method: zoomBarDown
     * 
     * Parameters:
	 * evt - {Object} 
     */
    zoomBarDown:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        this.map.events.on({
            "mousemove": this.passEventToSlider,
            "mouseup": this.passEventToSlider,
            scope: this
        });
        this.mouseDragStart = evt.xy.clone();
        this.zoomStart = evt.xy.clone();
        this.div.style.cursor = "move";
        this.zoombarDiv.offsets = null;
        OpenLayers.Event.stop(evt);
    },
	
    /**
     * Method: zoomBarDrag
     * 
     * Parameters:
	 * evt - {Object} 
     */
    zoomBarDrag:function(evt) {
        if (this.mouseDragStart != null) {
            var deltaY = this.mouseDragStart.y - evt.xy.y;
            var offsets = OpenLayers.Util.pagePosition(this.zoombarDiv);
            if ((evt.clientY - offsets[1]) > 0 &&
                (evt.clientY - offsets[1]) < parseInt(this.zoombarDiv.style.height) - 2) {
                var newTop = parseInt(this.slider.style.top) - deltaY;
                this.slider.style.top = newTop+"px";
                this.mouseDragStart = evt.xy.clone();
            }
            OpenLayers.Event.stop(evt);
        }
    },
	
    /**
     * Method: zoomBarUp
     * 
     * Parameters:
	 * evt - {Object} 
     */
    zoomBarUp:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        if (this.zoomStart) {
            this.div.style.cursor="";
            this.map.events.un({
                "mouseup": this.passEventToSlider,
                "mousemove": this.passEventToSlider,
                scope: this
            });
            var deltaY = this.zoomStart.y - evt.xy.y;
            var zoomLevel = this.map.zoom;
            if (this.map.fractionalZoom) {
                zoomLevel += deltaY/this.zoomStopHeight;
                zoomLevel = Math.min(Math.max(zoomLevel, 0),
                                     this.map.getNumZoomLevels() - 1);
            } else {
                zoomLevel += Math.round(deltaY/this.zoomStopHeight);
            }
            this.map.zoomTo(zoomLevel);
            this.moveZoomBar();
            this.mouseDragStart = null;
            OpenLayers.Event.stop(evt);
        }
    },
	
    /**
     * Method: moveZoomBar
     * 
     */
    moveZoomBar: function(){
        OpenLayers.Control.PanZoomBarTitle.isVisible = false;
        this.tooltip.style.display = "";
        //获取当前级别相对于金字塔级别
        var inPyramidZoom = this.getCurrentZoomNum();
        
        var newTop = ((this.map.getNumZoomLevels() - 1) - this.map.getZoom()) *
        this.zoomStopHeight +
        this.startTop +
        1;
        
        this.tooltip.style.top = (newTop - 3) + "px";
        var img = this.tooltip.childNodes[0];
        
        img.src = this.imageLocation + "panzoombar_blue/zoom_" + (parseInt(inPyramidZoom) + 0) + ".png";
        
        this.slider.style.top = newTop + "px";
        
        var tooltip = this.tooltip;
        var callfn = OpenLayers.Function.bind(function(){
            if (!OpenLayers.Control.PanZoomBarTitle.isVisible) {
                tooltip.style.display = "none";
                for (var i = 0; i < this.leftTip.length; i++) {
                    this.leftTip[i].style.display = "none";
                }
            }
        }, this);
        
        window.setTimeout(callfn, 1000);
    },
	
	/**
     * Method: doubleClick
     *
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {Boolean}
     */
    doubleClick: function (evt) {
        OpenLayers.Event.stop(evt);
        return false;
    },
	
	/**
     * Method: onButtonClick
     *
     * Parameters:
     * evt - {Event}
     */
    onButtonClick: function(evt) {
        switch (this.action) {
            case "panup": 
                this.map.pan(0, -this.getSlideFactor("h"));
                break;
            case "pandown": 
                this.map.pan(0, this.getSlideFactor("h"));
                break;
            case "panleft": 
                this.map.pan(-this.getSlideFactor("w"), 0);
                break;
            case "panright": 
                this.map.pan(this.getSlideFactor("w"), 0);
                break;
            case "zoomin": 
                this.map.zoomIn(); 
                break;
            case "zoomout": 
                this.map.zoomOut(); 
                break;
            case "zoomworld": 
                this.map.zoomToMaxExtent(); 
                break;
        }
    },
	
    CLASS_NAME: "Geo.View2D.Control.PanZoomBarTitle"
});/**
 * Class: Geo.View2D.Control.GeoOverviewMap
 * 鹰眼图类，继承自Geo.View2D.Control.OverviewMap类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.OverviewMap>
 */
Geo.View2D.Control.GeoOverviewMap = Geo.Class(Geo.View2D.Control.OverviewMap,{
	
	/**
	 * Constructor: Geo.View2D.Control.GeoOverviewMap
	 * Geo.View2D.Control.GeoOverviewMap对象构造函数。
	 * 
	 * Parameters:
     * options - {Object} 相关选项设置
     * 
     * (code)
     * 	// 鹰眼控件
     *      var overviewMap = new Geo.View2D.Control.GeoOverviewMap({
     *          maximized: true,//true表示鹰眼图是展开的
     *          layers: [tileLayer] //设置鹰眼图层
     *      });
     * (end)
	 */
	initialize : function(options) {
		options = options || {};
		if(options.layers && options.layers.length > 0) {
			//将参数中的图层设置成覆盖层，isBaseLayer都强制设置为false
			for(var i = 0,len = options.layers.length; i < len; i++) {
				if(options.layers[i] instanceof Geo.View2D.Layer.Vector) {
					//禁止添加矢量图层，如果是矢量图层，则进入下一次循环
					continue;
				}
				//添加的图层不能受外部操作的影响，需要克隆
				options.layers[i] = options.layers[i].clone();
				options.layers[i].isBaseLayer = false;
			}
			//添加基础图层
			/*
			 * 在创建鹰眼图的时候必须要有个基础图层。本来可以利用主地图的基础图层的，但是当用户使用自定义的图层后，主地图中的基础图层就被这个参数layers
			 * 给覆盖了
			 */
			var baseLayer = new Geo.View2D.Layer("GeoGlobeBaseLayer", {
	            displayInLayerSwitcher: false,
	            isBaseLayer: true
	        });
			options.layers.push(baseLayer);
		}
		
		Geo.View2D.Control.OverviewMap.prototype.initialize.apply(this, [options]);
	},
	
	/**
	 * Method: draw
	 * 该方法由API类自动调用。
	 */
    draw: function(){
       var div = Geo.View2D.Control.OverviewMap.prototype.draw.apply(this, arguments);
	   return div;
    },
    
	/**
	 * Method: createMap
	 * 该方法由API类自动调用。
	 */
    createMap: function(){
        Geo.View2D.Control.OverviewMap.prototype.createMap.apply(this,arguments);
		//如果图层长度为1则表示用户没有设置layers参数。
		if(this.layers.length == 1) {
			if(this.map && this.map.layerGroup) {
				this._loadLayers(this.map);
			}
			//监听图层组加载事件
			this.map.events.on({
	        "loadlayergroup":function(mainMap){
				this._unloadLayers(mainMap.map);
				this._loadLayers(mainMap.map);
			},
	        scope: this
	    	});
		}else if(this.layers.length > 1) {//如果图层长度大于1则表示用户自己添加图层参数
			//同步鹰眼图中的基础图层
			this._updateBaseLayer(this.map);
		}
		
		
    },
	
	//加载图层组
    _loadLayers : function(mainMap) {
		this.layers = [];
        var maplayers = mainMap.layerGroup.layers;
        for(var i=0; i<maplayers.length; i++){
			if(maplayers[i] instanceof Geo.View2D.Layer.Vector) {
				continue;
			}
			var layer = maplayers[i].clone();
			this.layers.push(layer);
        }
		this.ovmap.addLayers(this.layers);
		//同步鹰眼图中的基础图层
		this._updateBaseLayer(mainMap);

	},
	
	//更新基础图层
	_updateBaseLayer: function(mainMap) {
		var ovmap = this.ovmap;
		//同步鹰眼图中的基础图层
		if(mainMap.baseLayer) {
			var baseLayer = mainMap.baseLayer.clone();
			for(var i = 0,len = this.layers.length; i < len; i++) {
				if(this.layers[i].baseLayer) {
					OpenLayers.Util.removeItem(this.layers,this.layers[i]);
				}
			}
			this.layers.push(baseLayer);
			if (ovmap.baseLayer) {
           		ovmap.removeLayer(ovmap.baseLayer);
        	}
			ovmap.addLayer(baseLayer);
		}
	},
	
	//卸载图层组
    _unloadLayers: function(mainMap){
		var ovmap = this.ovmap;
		var layers = ovmap.layers;
		var layersTemp = [];
	    for(var i=0,len = layers.length; i < len; i++){
			if(!layers[i].isBaseLayer) {
				layersTemp.push(layers[i]);
			}
	    }
		for(var i=0,len = layersTemp.length; i < len; i++) {
			ovmap.removeLayer(layersTemp[i]);
		}
    },
	
	/**
	 * Method: destroy
	 * 该方法由API类自动调用。
	 */
	destroy : function() {
		this.map.events.un({
	        "loadlayergroup" : this.loadLayerGroup,
	        scope: this
    	});
		Geo.View2D.Control.OverviewMap.prototype.destroy.apply(this,arguments);
	}
});/**
 * Class: Geo.View2D.Control.GeoPanZoom
 * 迷你地图导航控件类，该类的实例是一个可定义的迷你地图导航控件类，默认画在地图的左上角。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.GeoPanZoom = Geo.Class(Geo.View2D.Control, {

    /** 
     * APIProperty: slideFactor
     * {Integer} 点击地图上任意方向上的箭头按钮后地图平移的像素数。
     * 如果你想通过地图尺寸的比率平移，请使用slideRatio代替。
     */
    slideFactor: 50,

    /** 
     * APIProperty: slideRatio
     * {Number} 地图宽与高的比值，是我们通过点击箭头按钮来平移地图的数量。默认为null。
     * 如果设置将会覆盖<slideFactor>。例如如果slideRatio为5,那么向上平移将会平移地图高度的一半。
     */
    slideRatio: null,

    /** 
     * Property: buttons
     * {Array(DOMElement)} Array of Button Divs 
     */
    buttons: null,

    /** 
     * Property: position
     * {<Geo.Pixel>} 
     */
    position: null,
	
    /** 
     * APIProperty: zoomWorldIcon
     * {Boolean} 是否显示缩放至世界范围的按钮图标。
     * 
     */
    zoomWorldIcon: false,
	
    /**
     * Constructor: Geo.View2D.Control.GeoPanZoom
     * 
     * Parameters:
     * options - {Object}
     */
    initialize: function(options) {
        this.position = new OpenLayers.Pixel(Geo.View2D.Control.GeoPanZoom.X,
                                             Geo.View2D.Control.GeoPanZoom.Y);
        OpenLayers.Control.prototype.initialize.apply(this, arguments);
    },

    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        this.removeButtons();
        this.buttons = null;
        this.position = null;
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
    },

    /**
     * Method: draw
     *
     * Parameters:
     * px - {<Geo.Pixel>} 
     * 
     * Returns:
     * {DOMElement} A reference to the container div for the PanZoom control.
     */
    draw: function(px) {
        // initialize our internal div
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        px = this.position;

        // place the controls
        this.buttons = [];

        var sz = new OpenLayers.Size(18,18);
        var centered = new OpenLayers.Pixel(px.x+sz.w/2, px.y);

        this._addButton("panup", "north-mini.png", centered, sz);
        px.y = centered.y+sz.h;
        this._addButton("panleft", "west-mini.png", px, sz);
        this._addButton("panright", "east-mini.png", px.add(sz.w, 0), sz);
        this._addButton("pandown", "south-mini.png", 
                        centered.add(0, sz.h*2), sz);
        this._addButton("zoomin", "zoom-plus-mini.png", 
                        centered.add(0, sz.h*3+5), sz);
						
		var num = 4;
		if(this.zoomWorldIcon){
            this._addButton("zoomworld", "zoom-world-mini.png", centered.add(0, sz.h * num++ + 5), sz);
		}
        this._addButton("zoomout", "zoom-minus-mini.png", centered.add(0, sz.h * num++ + 5), sz);
        return this.div;
    },
    
    /**
     * Method: _addButton
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addButton:function(id, img, xy, sz) {
        var imgLocation = OpenLayers.Util.getImagesLocation() + img;
        var btn = OpenLayers.Util.createAlphaImageDiv(
                                    this.id + "_" + id, 
                                    xy, sz, imgLocation, "absolute");
        btn.style.cursor = "pointer";
        //we want to add the outer div
        this.div.appendChild(btn);

        OpenLayers.Event.observe(btn, "mousedown", 
            OpenLayers.Function.bindAsEventListener(this.buttonDown, btn));
        OpenLayers.Event.observe(btn, "dblclick", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        OpenLayers.Event.observe(btn, "click", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        btn.action = id;
        btn.map = this.map;
    
        if(!this.slideRatio){
            var slideFactorPixels = this.slideFactor;
            var getSlideFactor = function() {
                return slideFactorPixels;
            };
        } else {
            var slideRatio = this.slideRatio;
            var getSlideFactor = function(dim) {
                return this.map.getSize()[dim] * slideRatio;
            };
        }

        btn.getSlideFactor = getSlideFactor;

        //we want to remember/reference the outer div
        this.buttons.push(btn);
        return btn;
    },
    
    /**
     * Method: _removeButton
     * 
     * Parameters:
     * btn - {Object}
     */
    _removeButton: function(btn) {
        OpenLayers.Event.stopObservingElement(btn);
        btn.map = null;
        btn.getSlideFactor = null;
        this.div.removeChild(btn);
        OpenLayers.Util.removeItem(this.buttons, btn);
    },
    
    /**
     * Method: removeButtons
     */
    removeButtons: function() {
        for(var i=this.buttons.length-1; i>=0; --i) {
            this._removeButton(this.buttons[i]);
        }
    },
    
    /**
     * Method: doubleClick
     *
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {Boolean}
     */
    doubleClick: function (evt) {
        OpenLayers.Event.stop(evt);
        return false;
    },
    
    /**
     * Method: buttonDown
     *
     * Parameters:
     * evt - {Event} 
     */
    buttonDown: function (evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }

        switch (this.action) {
            case "panup": 
                this.map.pan(0, -this.getSlideFactor("h"));
                break;
            case "pandown": 
                this.map.pan(0, this.getSlideFactor("h"));
                break;
            case "panleft": 
                this.map.pan(-this.getSlideFactor("w"), 0);
                break;
            case "panright": 
                this.map.pan(this.getSlideFactor("w"), 0);
                break;
            case "zoomin": 
                this.map.zoomIn(); 
                break;
            case "zoomout": 
                this.map.zoomOut(); 
                break;
            case "zoomworld": 
                this.map.zoomToMaxExtent(); 
                break;
        }

        OpenLayers.Event.stop(evt);
    },

    CLASS_NAME: "Geo.View2D.Control.GeoPanZoom"
});

/**
 * Constant: X
 * {Integer}
 */
Geo.View2D.Control.GeoPanZoom.X = 4;

/**
 * Constant: Y
 * {Integer}
 */
Geo.View2D.Control.GeoPanZoom.Y = 4;
/**
 * Class: Geo.View2D.Control.GeoSelectFeature
 * 选择要素控件，实现拉框，绘制多边形，点击或停留在指定的图层上选择矢量要素的功能。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
OpenLayers.Control.GeoSelectFeature = Geo.Class(Geo.View2D.Control, {

    /**
     * Constant: EVENT_TYPES
     * 事件类型。
     * 支持的事件类型:
     *  - *beforefeaturehighlighted* 
     *  要素在高亮以前触发。
     *  - *featurehighlighted* 
     *  要素高亮后触发。
     *  - *featureunhighlighted* 
     *  取消高亮时触发。
     */
    EVENT_TYPES: ["beforefeaturehighlighted", "featurehighlighted", "featureunhighlighted"],
    
    /**
     * Property: multipleKey
     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
     *     the <multiple> property to true.  Default is null.
     */
    multipleKey: null,
    
    /**
     * Property: toggleKey
     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
     *     the <toggle> property to true.  Default is null.
     */
    toggleKey: null,
    
    /**
     * APIProperty: multiple
     * {Boolean} 允许选择多个几何要素，默认为false。
     */
    multiple: false, 

    /**
     * APIProperty: clickout
     * {Boolean} 在任何要素以外点击的时候取消选择，默认为true。
     */
    clickout: true,

    /**
     * APIProperty: toggle
     * {Boolean} 点击取消选择一个选定的要素，默认值为false。
     */
    toggle: false,

    /**
     * APIProperty: hover
     * {Boolean} 在鼠标经过时选择，鼠标移除时取消选择。如果是true,将会忽视点击动作，仅监听鼠标经过动作。
     */
    hover: false,

    /**
     * APIProperty: highlightOnly
     * {Boolean} 如果设置为true,要素不会被选择仅仅会高亮。如果hover为false,本属性不会受影响。默认是false。
     */
    highlightOnly: false,
    
    /**
     * APIProperty: handlerSelection
     * {<Geo.View2D.Handler>} 控件动作监听类。允许通过拉框，鼠标绘制多边形或规则多边形来选择要素。
     */
    handlerSelection: null,
	
    /**
     * APIProperty: handlerOptions
     * {Object} 选取要素控件的动作监听对象需要设置的属性。
     */
    handlerSelOptions: null,
    
    /**
     * Property: onBeforeSelect 
     * {Function} Optional function to be called before a feature is selected.
     *     The function should expect to be called with a feature.
     */
    onBeforeSelect: function() {},
    
    /**
     * APIProperty: onSelect 
     * {Function} 当要素被选择后触发本函数。
     */
    onSelect: function() {},

    /**
     * APIProperty: onUnselect
     * {Function} 当要素被取消选择的时候触发本函数。
     */
    onUnselect: function() {},
    
    /**
     * Property: scope
     * {Object} The scope to use with the onBeforeSelect, onSelect, onUnselect
     *     callbacks. If null the scope will be this control.
     */
    scope: null,

    /**
     * APIProperty: geometryTypes
     * {Array(String)} 本数组用于存放需要被限制选择的几何对象名称。
     */
    geometryTypes: null,

    /**
     * Property: layer
     * {<Geo.View2D.Layer.Vector>} The vector layer with a common renderer
     * root for all layers this control is configured with (if an array of
     * layers was passed to the constructor), or the vector layer the control
     * was configured with (if a single layer was passed to the constructor).
     */
    layer: null,
    
    /**
     * Property: layers
     * {Array(<Geo.View2D.Layer.Vector>)} The layers this control will work on,
     * or null if the control was configured with a single layer
     */
    layers: null,
    
    /**
     * APIProperty: callbacks
     * {Object} 包含监听类型以及监听动作的对象。例如： {"onSelect": function(){}}
     */
    callbacks: null,
    
    /**
     * APIProperty: selectStyle 
     * {Object} 样式的json表示。
     */
    selectStyle: null,
    
    /**
     * Property: renderIntent
     * {String} key used to retrieve the select style from the layer's
     * style map.
     */
    renderIntent: "select",

    /**
     * Property: handlers
     * {Object} Object with references to multiple <Geo.View2D.Handler>
     *     instances.
     */
    handlers: null,

    /**
     * Constructor: Geo.View2D.Control.GeoSelectFeature
     * 构造一个新的<OpenLayers.Control.GeoSelectFeature>对象实例。
     *
     * Parameters:
     * layers - {<Geo.View2D.Layer.Vector>} 图层或图层数组。
     * options - {Object} 参数选项。
     */
    initialize: function(layers, options) {
        // concatenate events specific to this control with those from the base
        this.EVENT_TYPES =
            OpenLayers.Control.GeoSelectFeature.prototype.EVENT_TYPES.concat(
            OpenLayers.Control.prototype.EVENT_TYPES
        );
        OpenLayers.Control.prototype.initialize.apply(this, [options]);
        
        if(this.scope === null) {
            this.scope = this;
        }
        this.initLayer(layers);
        var callbacks = {
            click: this.clickFeature,
            clickout: this.clickoutFeature
        };
        if (this.hover) {
            callbacks.over = this.overFeature;
            callbacks.out = this.outFeature;
        }
             
        this.callbacks = OpenLayers.Util.extend(callbacks, this.callbacks);
        this.handlers = {
            feature: new OpenLayers.Handler.Feature(
                this, this.layer, this.callbacks,
                {geometryTypes: this.geometryTypes}
            )
        };

        if (this.handlerSelection) {
            this.handlerSelOptions = this.handlerSelOptions || {};
            
			// 拉框选取控件
            if (this.handlerSelection == OpenLayers.Handler.Box) {
                if (!this.handlerSelOptions.boxDivClassName) {
                    this.handlerSelOptions.boxDivClassName = "olHandlerBoxSelectFeature";
                }
				this.handlers.handlerSelection = new OpenLayers.Handler.Box(
	                this, {done: this.selectBox}, this.handlerSelOptions
	            ); 
            }
			
            // 多边形选取要素
            if (this.handlerSelection == OpenLayers.Handler.Polygon || this.handlerSelection == OpenLayers.Handler.RegularPolygon) {
                this.handlers.handlerSelection = new this.handlerSelection(this, {
                    done: this.selectPolygon
                }, this.handlerSelOptions);
            }
        }
    },

    /**
     * Method: initLayer
     * Assign the layer property. If layers is an array, we need to use
     *     a RootContainer.
     *
     * Parameters:
     * layers - {<Geo.View2D.Layer.Vector>}, or an array of vector layers.
     */
    initLayer: function(layers) {
        if(OpenLayers.Util.isArray(layers)) {
            this.layers = layers;
            this.layer = new OpenLayers.Layer.Vector.RootContainer(
                this.id + "_container", {
                    layers: layers
                }
            );
        } else {
            this.layer = layers;
        }
    },
    
    /**
     * Method: destroy
     */
    destroy: function() {
        if(this.active && this.layers) {
            this.map.removeLayer(this.layer);
        }
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
        if(this.layers) {
            this.layer.destroy();
        }
    },

    /**
     * Method: activate
     * Activates the control.
     * 
     * Returns:
     * {Boolean} The control was effectively activated.
     */
    activate: function () {
        if (!this.active) {
            if(this.layers) {
                this.map.addLayer(this.layer);
            }
            this.handlers.feature.activate();
            if(this.handlerSelection && this.handlers.handlerSelection) {
                this.handlers.handlerSelection.activate();
            }
        }
        return OpenLayers.Control.prototype.activate.apply(
            this, arguments
        );
    },

    /**
     * Method: deactivate
     * Deactivates the control.
     * 
     * Returns:
     * {Boolean} The control was effectively deactivated.
     */
    deactivate: function () {
        if (this.active) {
            this.handlers.feature.deactivate();
            if(this.handlers.handlerSelection) {
                this.handlers.handlerSelection.deactivate();
            }
            if(this.layers) {
                this.map.removeLayer(this.layer);
            }
        }
        return OpenLayers.Control.prototype.deactivate.apply(
            this, arguments
        );
    },

    /**
     * Method: unselectAll
     * Unselect all selected features.  To unselect all except for a single
     *     feature, set the options.except property to the feature.
     *
     * Parameters:
     * options - {Object} Optional configuration object.
     */
    unselectAll: function(options) {
        // we'll want an option to supress notification here
        var layers = this.layers || [this.layer];
        var layer, feature;
        for(var l=0; l<layers.length; ++l) {
            layer = layers[l];
            for(var i=layer.selectedFeatures.length-1; i>=0; --i) {
                feature = layer.selectedFeatures[i];
                if(!options || options.except != feature) {
                    this.unselect(feature);
                }
            }
        }
    },

    /**
     * Method: clickFeature
     * Called on click in a feature
     * Only responds if this.hover is false.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    clickFeature: function(feature) {
        if(!this.hover) {
            var selected = (OpenLayers.Util.indexOf(
                feature.layer.selectedFeatures, feature) > -1);
            if(selected) {
                if(this.toggleSelect()) {
                    this.unselect(feature);
                } else if(!this.multipleSelect()) {
                    this.unselectAll({except: feature});
                }
            } else {
                if(!this.multipleSelect()) {
                    this.unselectAll({except: feature});
                }
                this.select(feature);
            }
        }
    },

    /**
     * Method: multipleSelect
     * Allow for multiple selected features based on <multiple> property and
     *     <multipleKey> event modifier.
     *
     * Returns:
     * {Boolean} Allow for multiple selected features.
     */
    multipleSelect: function() {
        return this.multiple || (this.handlers.feature.evt &&
                                 this.handlers.feature.evt[this.multipleKey]);
    },
    
    /**
     * Method: toggleSelect
     * Event should toggle the selected state of a feature based on <toggle>
     *     property and <toggleKey> event modifier.
     *
     * Returns:
     * {Boolean} Toggle the selected state of a feature.
     */
    toggleSelect: function() {
        return this.toggle || (this.handlers.feature.evt &&
                               this.handlers.feature.evt[this.toggleKey]);
    },

    /**
     * Method: clickoutFeature
     * Called on click outside a previously clicked (selected) feature.
     * Only responds if this.hover is false.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    clickoutFeature: function(feature) {
        if(!this.hover && this.clickout) {
            this.unselectAll();
        }
    },

    /**
     * Method: overFeature
     * Called on over a feature.
     * Only responds if this.hover is true.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    overFeature: function(feature) {
        var layer = feature.layer;
        if(this.hover) {
            if(this.highlightOnly) {
                this.highlight(feature);
            } else if(OpenLayers.Util.indexOf(
                layer.selectedFeatures, feature) == -1) {
                this.select(feature);
            }
        }
    },

    /**
     * Method: outFeature
     * Called on out of a selected feature.
     * Only responds if this.hover is true.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    outFeature: function(feature) {
        if(this.hover) {
            if(this.highlightOnly) {
                // we do nothing if we're not the last highlighter of the
                // feature
                if(feature._lastHighlighter == this.id) {
                    // if another select control had highlighted the feature before
                    // we did it ourself then we use that control to highlight the
                    // feature as it was before we highlighted it, else we just
                    // unhighlight it
                    if(feature._prevHighlighter &&
                       feature._prevHighlighter != this.id) {
                        delete feature._lastHighlighter;
                        var control = this.map.getControl(
                            feature._prevHighlighter);
                        if(control) {
                            control.highlight(feature);
                        }
                    } else {
                        this.unhighlight(feature);
                    }
                }
            } else {
                this.unselect(feature);
            }
        }
    },

    /**
     * Method: highlight
     * Redraw feature with the select style.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    highlight: function(feature) {
        var layer = feature.layer;
        var cont = this.events.triggerEvent("beforefeaturehighlighted", {
            feature : feature
        });
        if(cont !== false) {
            feature._prevHighlighter = feature._lastHighlighter;
            feature._lastHighlighter = this.id;
            var style = this.selectStyle || this.renderIntent;
            layer.drawFeature(feature, style);
            this.events.triggerEvent("featurehighlighted", {feature : feature});
        }
    },

    /**
     * Method: unhighlight
     * Redraw feature with the "default" style
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    unhighlight: function(feature) {
        var layer = feature.layer;
        // three cases:
        // 1. there's no other highlighter, in that case _prev is undefined,
        //    and we just need to undef _last
        // 2. another control highlighted the feature after we did it, in
        //    that case _last references this other control, and we just
        //    need to undef _prev
        // 3. another control highlighted the feature before we did it, in
        //    that case _prev references this other control, and we need to
        //    set _last to _prev and undef _prev
        if(feature._prevHighlighter == undefined) {
            delete feature._lastHighlighter;
        } else if(feature._prevHighlighter == this.id) {
            delete feature._prevHighlighter;
        } else {
            feature._lastHighlighter = feature._prevHighlighter;
            delete feature._prevHighlighter;
        }
        layer.drawFeature(feature, feature.style || feature.layer.style ||
            "default");
        this.events.triggerEvent("featureunhighlighted", {feature : feature});
    },
    
    /**
     * Method: select
     * Add feature to the layer's selectedFeature array, render the feature as
     * selected, and call the onSelect function.
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    select: function(feature) {
        var cont = this.onBeforeSelect.call(this.scope, feature);
        var layer = feature.layer;
        if(cont !== false) {
            cont = layer.events.triggerEvent("beforefeatureselected", {
                feature: feature
            });
            if(cont !== false) {
                layer.selectedFeatures.push(feature);
                this.highlight(feature);
                // if the feature handler isn't involved in the feature
                // selection (because the box handler is used or the
                // feature is selected programatically) we fake the
                // feature handler to allow unselecting on click
                if(!this.handlers.feature.lastFeature) {
                    this.handlers.feature.lastFeature = layer.selectedFeatures[0];
                }
                layer.events.triggerEvent("featureselected", {feature: feature});
                this.onSelect.call(this.scope, feature);
            }
        }
    },

    /**
     * Method: unselect
     * Remove feature from the layer's selectedFeature array, render the feature as
     * normal, and call the onUnselect function.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>}
     */
    unselect: function(feature) {
        var layer = feature.layer;
        // Store feature style for restoration later
        this.unhighlight(feature);
        OpenLayers.Util.removeItem(layer.selectedFeatures, feature);
        layer.events.triggerEvent("featureunselected", {feature: feature});
        this.onUnselect.call(this.scope, feature);
    },
    
    /**
     * Method: selectBox
     * Callback from the handlers.box set up when <box> selection is true
     *     on.
     *
     * Parameters:
     * position - {<Geo.Bounds> || <Geo.Pixel> }  
     */
    selectBox: function(position) {
        if (position instanceof OpenLayers.Bounds) {
            var minXY = this.map.getLonLatFromPixel(
                new OpenLayers.Pixel(position.left, position.bottom)
            );
            var maxXY = this.map.getLonLatFromPixel(
                new OpenLayers.Pixel(position.right, position.top)
            );
            var bounds = new OpenLayers.Bounds(
                minXY.lon, minXY.lat, maxXY.lon, maxXY.lat
            );
            
            // if multiple is false, first deselect currently selected features
            if (!this.multipleSelect()) {
                this.unselectAll();
            }
            
            // because we're using a box, we consider we want multiple selection
            var prevMultiple = this.multiple;
            this.multiple = true;
            var layers = this.layers || [this.layer];
            var layer;
            for(var l=0; l<layers.length; ++l) {
                layer = layers[l];
                for(var i=0, len = layer.features.length; i<len; ++i) {
                    var feature = layer.features[i];
                    // check if the feature is displayed
                    if (!feature.getVisibility()) {
                        continue;
                    }

                    if (this.geometryTypes == null || OpenLayers.Util.indexOf(
                            this.geometryTypes, feature.geometry.CLASS_NAME) > -1) {
                        if (bounds.toGeometry().intersects(feature.geometry)) {
                            if (OpenLayers.Util.indexOf(layer.selectedFeatures, feature) == -1) {
                                this.select(feature);
                            }
                        }
                    }
                }
            }
            this.multiple = prevMultiple;
        }
    },

	/**
     * Method: selectPolygon
     * Callback from the handlers.handlerSelection set up when <polygon> selection has been setted.
     *
     * Parameters:
     * geometry - {<Geo.Geometry>}  
     */
    selectPolygon: function(geometry) {
		if (geometry instanceof OpenLayers.Geometry) {
			// if multiple is false, first deselect currently selected features
            if (!this.multipleSelect()) {
                this.unselectAll();
            }
            
            // because we're using a polygon, we consider we want multiple selection
            var prevMultiple = this.multiple;
            this.multiple = true;
			var layers = this.layers || [this.layer];
            var layer;
            for(var l=0; l<layers.length; ++l) {
                layer = layers[l];
                for(var i=0, len = layer.features.length; i<len; ++i) {
                    var feature = layer.features[i];
                    // check if the feature is displayed
                    if (!feature.getVisibility()) {
                        continue;
                    }

                    if (this.geometryTypes == null || OpenLayers.Util.indexOf(
                            this.geometryTypes, feature.geometry.CLASS_NAME) > -1) {
                        if (geometry.intersects(feature.geometry)) {
                            if (OpenLayers.Util.indexOf(layer.selectedFeatures, feature) == -1) {
                                this.select(feature);
                            }
                        }
                    }
                }
            }
			this.multiple = prevMultiple;
        }
	},
	
    /** 
     * Method: setMap
     * Set the map property for the control. 
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map) {
        this.handlers.feature.setMap(map);
        if (this.handlerSelection) {
            this.handlers.handlerSelection.setMap(map);
        }
        OpenLayers.Control.prototype.setMap.apply(this, arguments);
    },
    
    /**
     * APIMethod: setLayer
     * 将一个新的图层添加到本控件上，这样会覆盖所有已经存在的图层。
     * 
     * Parameters:
     * layers - {<Geo.View2D.Layer.Vector>}数组 或单个{<Geo.View2D.Layer.Vector>}对象。
     */
    setLayer: function(layers) {
        var isActive = this.active;
        this.unselectAll();
        this.deactivate();
        if(this.layers) {
            this.layer.destroy();
            this.layers = null;
        }
        this.initLayer(layers);
        this.handlers.feature.layer = this.layer;
        if (isActive) {
            this.activate();
        }
    },
    
    CLASS_NAME: "Geo.View2D.Control.GeoSelectFeature"
});
/**
 * Class: Geo.View2D.Control.ZoomBar
 * 简单的缩放工具条。
 * 制作图片时，放大缩小工具zoomin zoomout的宽度和缩放条zoombar宽度一致。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.PanZoom>
 */
Geo.View2D.Control.ZoomBar = Geo.Class(Geo.View2D.Control.PanZoom, {
    /** 
     * APIProperty: zoomStopWidth
     * 缩放条停止的宽度，默认为18。
     */
    //zoomStopWidth: 18,
	zoombarWidth: 18,

    /** 
     * APIProperty: zoomStopHeight
     * 缩放条刻度的高度，默认为14。
     */
    zoomStopHeight: 14,

    /** 
     * Property: slider
     * 定义滑动对象。
     */
    slider: null,

    /** 
     * Property: sliderEvents
     * {<OpenLayers.Events>}
     * 滑动事件。
     */
    sliderEvents: null,

    /** 
     * Property: zoombarDiv
     * {DOMElement} 缩放条DIV对象。
     */
    zoombarDiv: null,

    /** 
     * Property: divEvents
     * {<OpenLayers.Events>} div事件对象。
     */
    divEvents: null,

    /** 
     * APIProperty: zoomWorldIcon
     * {Boolean} 是否显示全图，默认为不显示false。
     */
    zoomWorldIcon: false,

    /**
     * APIProperty: panIcons
     * {Boolean} 设置属性为false不显示上下左右工具，设置为true显示，默认为false。
     */
    panIcons: false,

    /**
     * APIProperty: forceFixedZoomLevel
     * {Boolean} Force a fixed zoom level even though the map has 
     *     fractionalZoom
     */
    forceFixedZoomLevel: false,

    /**
     * Property: mouseDragStart
     * {<OpenLayers.Pixel>}
     */
    mouseDragStart: null,

    /**
     * Property: deltaY
     * {Number} The cumulative vertical pixel offset during a zoom bar drag.
     */
    deltaY: null,

    /**
     * Property: zoomStart
     * {<OpenLayers.Pixel>}
     */
    zoomStart: null,
    
    /**
     * Property: imgLocation
     * @type String 设置工具使用的图标位置,如："img/",默认为空，使用openlayers下面的图片。
     */
    imgLocation:"",
    
    /**
     * Property: zoomIcon
     * @type Boolean  设置这个属性true显示放大缩小工具,如果设置false不显示放大缩小工具，默认为false。
     */
    zoomIcon:false,
    
    /**
     * Property: defaultIcon
     * @type Boolean  设置这个属性true显示默认的缩放工具条,如果设置false显示自定义工具条，默认为true。
     */
    defaultIcon:true,
    
     /** 
     * APIProperty: zoomWidth
     * 放大缩小工具zoomin zoomout的宽度，默认为18。
     */
    zoomWidth: 18,
    
     /** 
     * APIProperty: zoomHeight
     * 放大缩小工具zoomin zoomout的高度，默认为18。
     */
    zoomHeight: 18,
    
    /** 
     * APIProperty: sliderWidth
     * 滑动条slider的宽度，默认为20。
     */
    sliderWidth:20,
    
    /** 
     * APIProperty: sliderHeight
     * 滑动条slider的高度，默认为9。
     */
    sliderHeight:9,
    
    /** 
     * APIProperty: zoombarWidth
     * 缩放条zoombar的宽度，默认为18。
     */
    zoombarWidth:18,
    
    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {

        this._removeZoomBar();

        this.map.events.un({
            "changebaselayer": this.redraw,
            scope: this
        });

        OpenLayers.Control.PanZoom.prototype.destroy.apply(this, arguments);

        delete this.mouseDragStart;
        delete this.zoomStart;
    },
    
    /**
     * Method: setMap
     * 关联地图。
     * 
     * Parameters:
     * map - {<OpenLayers.Map>} 
     */
    setMap: function(map) {
        OpenLayers.Control.PanZoom.prototype.setMap.apply(this, arguments);
        this.map.events.register("changebaselayer", this, this.redraw);
    },

    /** 
     * Method: redraw
     * clear the div and start over.
     */
    redraw: function() {
        if (this.div != null) {
            this.removeButtons();
            this._removeZoomBar();
        }  
        this.draw();
    },
    
    /**
    * Method: draw
    * 绘制方法。
    *
    * Parameters:
    * px - {<OpenLayers.Pixel>} 
    */
    draw: function(px) {
        // initialize our internal div
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        px = this.position.clone();

        // place the controls
        this.buttons = [];
        
        
        var sz = new OpenLayers.Size(this.zoomWidth,this.zoomHeight);
        
        /**
        if (this.panIcons) {
            var centered = new OpenLayers.Pixel(px.x+sz.w/2, px.y);
            var wposition = sz.w;

            if (this.zoomWorldIcon) {
                centered = new OpenLayers.Pixel(px.x+sz.w, px.y);
            }

            this._addButton("panup", "north-mini.png", centered, sz);
            px.y = centered.y+sz.h;
            this._addButton("panleft", "west-mini.png", px, sz);
            if (this.zoomWorldIcon) {
                this._addButton("zoomworld", "zoom-world-mini.png", px.add(sz.w, 0), sz);

                wposition *= 2;
            }
            this._addButton("panright", "east-mini.png", px.add(wposition, 0), sz);
            this._addButton("pandown", "south-mini.png", centered.add(0, sz.h*2), sz);
            this._addButton("zoomin", "zoom-plus-mini.png", centered.add(0, sz.h*3+5), sz);
            centered = this._addZoomBar(centered.add(0, sz.h*4 + 5));
            this._addButton("zoomout", "zoom-minus-mini.png", centered, sz);
        }
        else */
        if(this.zoomIcon){
        	/**
        	 var centered = new OpenLayers.Pixel(px.x + sz.w / 2, px.y);
        	  this._addButton("zoomin", "zoom-plus-mini.png", centered.add(0, sz.h * 3 + 5), sz, "放大一级");
		      centered = this._addZoomBar(centered.add(0, sz.h * 4 + 5));
		      this._addButton("zoomout", "zoom-minus-mini.png", centered.add(0, sz.h * 4 + 10), sz, "缩小一级");
        	*/
        	
        	/**
        	var centered = new OpenLayers.Pixel(px.x + sz.w / 2, px.y);
    	    this._addButton("zoomin", "zoom-plus-mini.png", centered.add(0, sz.h * 3 + 5), sz, "放大一级");
    	    centered = this._addZoomBar(centered.add(3, sz.h * 4 + 5));
   		    this._addButton("zoomout", "zoom-minus-mini.png", centered.add(-3, 0), sz, "缩小一级");
        	            */
        	
        	var centered = new OpenLayers.Pixel(px.x+sz.w/2, px.y);
            this._addButton("zoomin", "zoom-plus-mini.png", px, sz);
            
            centered = this._addZoomBar(px.add(0, sz.h));
            
            this._addButton("zoomout", "zoom-minus-mini.png", centered, sz);

//            if (this.zoomWorldIcon) {
//                centered = centered.add(0, sz.h+3);
//                this._addButton("zoomworld", "zoom-world-mini.png", centered, sz);
//            }
        } else {
            centered = this._addZoomBar(px.add(0, sz.h));
//            if (this.zoomWorldIcon) {
//                centered = centered.add(0, sz.h+3);
//                this._addButton("zoomworld", "zoom-world-mini.png", centered, sz);
//            }
        }
        return this.div;
    },
    
    /**
     * Method: _addButton
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<OpenLayers.Pixel>} 
     * sz - {<OpenLayers.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addButton:function(id, img, xy, sz) {
        var imgLocation = OpenLayers.Util.getImagesLocation() + img;
        if(this.defaultIcon){
        	var btn = OpenLayers.Util.createAlphaImageDiv(this.id + "_" + id, 
                                    xy, sz, imgLocation, "absolute");
        }else{
        	var className = id;
        	var btn = OpenLayers.Util.createAlphaImageDiv(this.id + "_" + id, 
                                    xy, sz, "", "absolute");
            btn.className = className;                        
        }
        btn.style.cursor = "pointer";
        //we want to add the outer div
        this.div.appendChild(btn);

        OpenLayers.Event.observe(btn, "mousedown", 
            OpenLayers.Function.bindAsEventListener(this.buttonDown, btn));
        OpenLayers.Event.observe(btn, "dblclick", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        OpenLayers.Event.observe(btn, "click", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        btn.action = id;
        btn.map = this.map;
    
        if(!this.slideRatio){
            var slideFactorPixels = this.slideFactor;
            var getSlideFactor = function() {
                return slideFactorPixels;
            };
        } else {
            var slideRatio = this.slideRatio;
            var getSlideFactor = function(dim) {
                return this.map.getSize()[dim] * slideRatio;
            };
        }

        btn.getSlideFactor = getSlideFactor;
		
        //we want to remember/reference the outer div
        this.buttons.push(btn);
        return btn;
    },
    /** 
    * Method: _addZoomBar
    * 
    * Parameters:
    * location - {<OpenLayers.Pixel>} where zoombar drawing is to start.
    */
    _addZoomBar:function(centered) {
    	var imgLocation = this.imgLocation;
        if(this.imgLocation == ""){
        	 imgLocation = OpenLayers.Util.getImagesLocation();
        }
        var id = this.id + "_" + this.map.id;
        var zoomsToEnd = this.map.getNumZoomLevels() - 1 - this.map.getZoom();
        if(this.defaultIcon){
        	var slider = OpenLayers.Util.createAlphaImageDiv(id,
                       centered.add(-1, zoomsToEnd * this.zoomStopHeight),
                       //centered.add(-1, zoomsToEnd * this.zoomStopHeight),
                       //centered.add(8, zoomsToEnd * this.zoomStopHeight),
                       new OpenLayers.Size(20,9),
                       //new OpenLayers.Size(18,18),
                       imgLocation+"slider.png",
                       "absolute");
        }else{
        	var slider = OpenLayers.Util.createAlphaImageDiv(id,
                       centered.add((this.zoomWidth - this.sliderWidth) / 2, zoomsToEnd * this.zoomStopHeight),
                       new OpenLayers.Size(this.sliderWidth,this.sliderHeight),
                       "",
                       "absolute");
            slider.className = "slider";
        }
        
        slider.style.cursor = "move";
        this.slider = slider;
        
        this.sliderEvents = new OpenLayers.Events(this, slider, null, true,
                                            {includeXY: true});
        this.sliderEvents.on({
            "touchstart": this.zoomBarDown,
            "touchmove": this.zoomBarDrag,
            "touchend": this.zoomBarUp,
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        
        var sz = new OpenLayers.Size();
        sz.h = this.zoomStopHeight * this.map.getNumZoomLevels();
        //sz.w = this.zoomStopWidth;
        sz.w = this.zoombarWidth;
        var div = null;
        
        if (OpenLayers.Util.alphaHack()) {
            var id = this.id + "_" + this.map.id;
            div = OpenLayers.Util.createAlphaImageDiv(id, centered,
                                      new OpenLayers.Size(sz.w, 
                                              this.zoomStopHeight),
                                      imgLocation + "zoombar.png", 
                                      "absolute", null, "crop");
            div.style.height = sz.h + "px";
        } else {
        	if(this.defaultIcon){
        		 div = OpenLayers.Util.createDiv(
                        'OpenLayers_Control_PanZoomBar_Zoombar' + this.map.id,
                        centered,
                        sz,
                        imgLocation+"zoombar.png");
        	}else{
            	div = OpenLayers.Util.createDiv(
                        'OpenLayers_Control_PanZoomBar_Zoombar' + this.map.id,
                        centered,
                        sz
                       );
        		div.className = "zoombar";
        	}
        }
        div.style.cursor = "pointer";
        
        
        this.zoombarDiv = div;
        
        
        this.divEvents = new OpenLayers.Events(this, div, null, true, 
                                                {includeXY: true});
        this.divEvents.on({
            "touchmove": this.passEventToSlider,
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        
        this.div.appendChild(div);

        this.startTop = parseInt(div.style.top);
        this.div.appendChild(slider);
        
        this.div.onmouseover = this._onmouseover;
        this.div.onmouseout = this._onmouseout;

        this.map.events.register("zoomend", this, this.moveZoomBar);

        centered = centered.add(0,
        //centered = centered.add((this.zoomWidth-this.zoomStopWidth)/2,
            this.zoomStopHeight * this.map.getNumZoomLevels());
        return centered; 
    },
    
    //移在上面触发
    _onmouseover:function(){
    		for (var i = 0; i < this.childNodes.length; i ++) {
				var div = this.childNodes[i];
				if(div.className == "zoomin"){
					div.className="zoomin_";
				}
				if(div.className == "zoomout"){
					div.className="zoomout_";
				}
				if(div.className == "zoombar"){
					div.className="zoombar_";
				}
				if(div.className == "slider"){
					div.className="slider_";
				}
			}
    },
    //移出触发
    _onmouseout:function(){
    		for (var i = 0; i < this.childNodes.length; i ++) {
				var div = this.childNodes[i];
				
				if(div.className == "zoomin_"){
					
					div.className="zoomin";
				}
				if(div.className == "zoomout_"){
					div.className="zoomout";
				}
				if(div.className == "zoombar_"){
					div.className="zoombar";
				}
				if(div.className == "slider_"){
					div.className="slider";
				}
			}
    },
    
    /**
     * Method: _removeZoomBar
     */
    _removeZoomBar: function() {
        this.sliderEvents.un({
            "touchmove": this.zoomBarDrag,
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        this.sliderEvents.destroy();

        this.divEvents.un({
            "touchmove": this.passEventToSlider,
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        this.divEvents.destroy();
        
        this.div.removeChild(this.zoombarDiv);
        this.zoombarDiv = null;
        this.div.removeChild(this.slider);
        this.slider = null;
        
        this.map.events.unregister("zoomend", this, this.moveZoomBar);
    },
    
    /**
     * Method: passEventToSlider
     * This function is used to pass events that happen on the div, or the map,
     * through to the slider, which then does its moving thing.
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    passEventToSlider:function(evt) {
        this.sliderEvents.handleBrowserEvent(evt);
    },
    
    /**
     * Method: divClick
     * Picks up on clicks directly on the zoombar div
     *           and sets the zoom level appropriately.
     */
    divClick: function (evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        var levels = evt.xy.y / this.zoomStopHeight;
        if(this.forceFixedZoomLevel || !this.map.fractionalZoom) {
            levels = Math.floor(levels);
        }    
        var zoom = (this.map.getNumZoomLevels() - 1) - levels; 
        zoom = Math.min(Math.max(zoom, 0), this.map.getNumZoomLevels() - 1);
        this.map.zoomTo(zoom);
        OpenLayers.Event.stop(evt);
    },
    
    /**
     * Method: zoomBarDown
     * event listener for clicks on the slider
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    zoomBarDown:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt) && !OpenLayers.Event.isSingleTouch(evt)) {
            return;
        }
        this.map.events.on({
            "touchmove": this.passEventToSlider,
            "mousemove": this.passEventToSlider,
            "mouseup": this.passEventToSlider,
            scope: this
        });
        this.mouseDragStart = evt.xy.clone();
        this.zoomStart = evt.xy.clone();
        this.div.style.cursor = "move";
        // reset the div offsets just in case the div moved
        this.zoombarDiv.offsets = null; 
        OpenLayers.Event.stop(evt);
    },
    
    /**
     * Method: zoomBarDrag
     * This is what happens when a click has occurred, and the client is
     * dragging.  Here we must ensure that the slider doesn't go beyond the
     * bottom/top of the zoombar div, as well as moving the slider to its new
     * visual location
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    zoomBarDrag:function(evt) {
        if (this.mouseDragStart != null) {
            var deltaY = this.mouseDragStart.y - evt.xy.y;
            var offsets = OpenLayers.Util.pagePosition(this.zoombarDiv);
            if ((evt.clientY - offsets[1]) > 0 && 
                (evt.clientY - offsets[1]) < parseInt(this.zoombarDiv.style.height) - 2) {
                var newTop = parseInt(this.slider.style.top) - deltaY;
                this.slider.style.top = newTop+"px";
                this.mouseDragStart = evt.xy.clone();
            }
            // set cumulative displacement
            this.deltaY = this.zoomStart.y - evt.xy.y;
            OpenLayers.Event.stop(evt);
        }
    },
    
    /**
     * Method: zoomBarUp
     * Perform cleanup when a mouseup event is received -- discover new zoom
     * level and switch to it.
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    zoomBarUp:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt) && evt.type !== "touchend") {
            return;
        }
        if (this.mouseDragStart) {
            this.div.style.cursor="";
            this.map.events.un({
                "touchmove": this.passEventToSlider,
                "mouseup": this.passEventToSlider,
                "mousemove": this.passEventToSlider,
                scope: this
            });
            var zoomLevel = this.map.zoom;
            if (!this.forceFixedZoomLevel && this.map.fractionalZoom) {
                zoomLevel += this.deltaY/this.zoomStopHeight;
                zoomLevel = Math.min(Math.max(zoomLevel, 0), 
                                     this.map.getNumZoomLevels() - 1);
            } else {
                zoomLevel += this.deltaY/this.zoomStopHeight;
                zoomLevel = Math.max(Math.round(zoomLevel), 0);      
            }
            this.map.zoomTo(zoomLevel);
            this.mouseDragStart = null;
            this.zoomStart = null;
            this.deltaY = 0;
            OpenLayers.Event.stop(evt);
        }
    },
    
   /**
    * Method: moveZoomBar
    * Change the location of the slider to match the current zoom level.
    */
    moveZoomBar:function() {
        var newTop = 
            ((this.map.getNumZoomLevels()-1) - this.map.getZoom()) * 
            this.zoomStopHeight + this.startTop + 1;
        this.slider.style.top = newTop + "px";
    },    
    
    CLASS_NAME: "Geo.View2D.Control.ZoomBar"
});
/**
 * Class: Geo.View2D.Control.GeoNavigationHistory
 * 操作历史导航控件类。用户使用鼠标操作地图或者在地图上绘制要素，
 * 此控件能记录地图的平移和缩放操作、矢量要素，并将这些信息存放到本地浏览器的localStorage对象中。
 * 当用户关闭浏览器再次打开时读取这些信息，并通过控件的“前进”、“后退”按钮进行浏览查看。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.GeoNavigationHistory = Geo.Class(Geo.View2D.Control, {

    /**
     * Property: type
     * {String} Note that this control is not intended to be added directly
     *     to a control panel.  Instead, add the sub-controls previous and
     *     next.  These sub-controls are button type controls that activate
     *     and deactivate themselves.  If this parent control is added to
     *     a panel, it will act as a toggle.
     */
    type: Geo.View2D.Control.TYPE_TOGGLE,

    /**
     * APIProperty: previous
     * {<Geo.View2D.Control>} "上一步"的控件按钮对象。
     */
    previous: null,
    
    /**
     * APIProperty: previousOptions
     * {Object} 设置"上一步"的控件对象的构造参数对象。
     */
    previousOptions: null,
    
    /**
     * APIProperty: next
     * {<Geo.View2D.Control>} "下一步"的控件按钮对象。
     */
    next: null,

    /**
     * APIProperty: nextOptions
     * {Object} 设置"下一步"的控件对象的构造参数对象。
     */
    nextOptions: null,

    /**
     * APIProperty: limit
     * {Integer} 历史操作的记录限制数量。
     */
    limit: 50,

    /**
     * APIProperty: autoActivate
     * {Boolean} 是否在控件添加至地图后自动激活。
     */
    autoActivate: true,

    /**
     * Property: clearOnDeactivate
     * {Boolean} Clear the history when the control is deactivated.  Default
     *     is false.
     */
    clearOnDeactivate: false,

    /**
     * Property: registry
     * {Object} An object with keys corresponding to event types.  Values
     *     are functions that return an object representing the current state.
     */
    registry: null,

    /**
     * Property: nextStack
     * {Array} Array of items in the history.
     */
    nextStack: null,

    /**
     * Property: previousStack
     * {Array} List of items in the history.  First item represents the current
     *     state.
     */
    previousStack: null,
    
    /**
     * Property: listeners
     * {Object} An object containing properties corresponding to event types.
     *     This object is used to configure the control and is modified on
     *     construction.
     */
    listeners: null,
    
    /**
     * Property: restoring
     * {Boolean} Currently restoring a history state.  This is set to true
     *     before calling restore and set to false after restore returns.
     */
    restoring: false,
    
    /**
     * Constructor: Geo.View2D.Control.GeoNavigationHistory
     * Geo.View2D.Control.GeoNavigationHistory对象构造函数。
     * 
     * Parameters:
     * options - {Object} 参数对象。
     * vectorLayer - {<Geo.View2D.Layer.Vector>} 矢量要素图层。
     */
    initialize: function(options, vectorLayer) {
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
		this.vectorLayer = vectorLayer;
        this.registry = OpenLayers.Util.extend({
            "moveend": this.getState,
			"featureadded": this.getState,
			"featureremoved": this.getState
        }, this.registry);
        
        var previousOptions = {
            trigger: OpenLayers.Function.bind(this.previousTrigger, this),
            displayClass: this.displayClass + " " + this.displayClass + "Previous"
        };
        OpenLayers.Util.extend(previousOptions, this.previousOptions);
        this.previous = new Geo.View2D.Control.Button(previousOptions);
        
        var nextOptions = {
            trigger: OpenLayers.Function.bind(this.nextTrigger, this),
            displayClass: this.displayClass + " " + this.displayClass + "Next"
        };
        OpenLayers.Util.extend(nextOptions, this.nextOptions);
        this.next = new Geo.View2D.Control.Button(nextOptions);

        this.clear();
		
        this.format = this.format ? this.format : new Geo.Format.GML();
        this.jsonParser = new OpenLayers.Format.JSON();
		
		//window.localStorage.clear();
		try {
			this.previousStack = this.readStack(window.localStorage.getItem("previousStack"));
			this.nextStack = this.readStack(window.localStorage.getItem("nextStack"));
		} catch (e) {
		}
		
		this.initFlag = true;
    },
    
    /**
     * Method: onPreviousChange
     * Called when the previous history stack changes.
     *
     * Parameters:
     * state - {Object} An object representing the state to be restored
     *     if previous is triggered again or null if no previous states remain.
     * length - {Integer} The number of remaining previous states that can
     *     be restored.
     */
    onPreviousChange: function(state, length) {
        if(state && !this.previous.active) {
            this.previous.activate();
        } else if(!state && this.previous.active) {
            this.previous.deactivate();
        }
    },
    
    /**
     * Method: onNextChange
     * Called when the next history stack changes.
     *
     * Parameters:
     * state - {Object} An object representing the state to be restored
     *     if next is triggered again or null if no next states remain.
     * length - {Integer} The number of remaining next states that can
     *     be restored.
     */
    onNextChange: function(state, length) {
        if(state && !this.next.active) {
            this.next.activate();
        } else if(!state && this.next.active) {
            this.next.deactivate();
        }
    },
    
    /**
     * APIMethod: destroy
     * 销毁这个控件。
     */
    destroy: function() {
        Geo.View2D.Control.prototype.destroy.apply(this);
        this.previous.destroy();
        this.next.destroy();
        this.deactivate();
        for(var prop in this) {
            this[prop] = null;
        }
    },
    
    /** 
     * Method: setMap
     * Set the map property for the control and <previous> and <next> child
     *     controls.
     *
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map) {
        this.map = map;
        this.next.setMap(map);
        this.previous.setMap(map);
    },

    /**
     * Method: draw
     * Called when the control is added to the map.
     */
    draw: function() {
        Geo.View2D.Control.prototype.draw.apply(this, arguments);
        this.next.draw();
        this.previous.draw();
    },
    
    /**
     * Method: previousTrigger
     * Restore the previous state.  If no items are in the previous history
     *     stack, this has no effect.
     *
     * Returns:
     * {Object} Item representing state that was restored.  Undefined if no
     *     items are in the previous history stack.
     */
    previousTrigger: function() {
        var current = this.previousStack.shift();
        var state = this.previousStack.shift();
        if(state != undefined) {
            this.nextStack.unshift(current);
            this.previousStack.unshift(state);
            this.restoring = true;
            this.restore(state);
            this.restoring = false;
            this.onNextChange(this.nextStack[0], this.nextStack.length);
            this.onPreviousChange(
                this.previousStack[1], this.previousStack.length - 1
            );
        } else {
            this.previousStack.unshift(current);
        }
		try {
			window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
			window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
		}catch(e){
		}
        return state;
    },
    
    /**
     * APIMethod: nextTrigger
     * 点击“前进”按钮触发的函数。
     *
     * Returns:
     * {Object} 返回“前进”后的状态对象。
     */
    nextTrigger: function() {
        var state = this.nextStack.shift();
        if(state != undefined) {
            this.previousStack.unshift(state);
            this.restoring = true;
            this.restore(state);
            this.restoring = false;
            this.onNextChange(this.nextStack[0], this.nextStack.length);
            this.onPreviousChange(
                this.previousStack[1], this.previousStack.length - 1
            );
        }
		try {
			window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
			window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
		}catch(e){
		}
        return state;
    },
    
    /**
     * APIMethod: clear
     * 清除内存中该控件记录的操作信息。
     */
    clear: function() {
        this.previousStack = [];
        this.previous.deactivate();
        this.nextStack = [];
        this.next.deactivate();
    },

    /**
     * Method: getState
     * Get the current state and return it.
     *
     * Returns:
     * {Object} An object representing the current state.
     */
    getState: function() {
		var features = OpenLayers.Util.extend([], this.vectorLayer.features);
        return {
            center: this.map.getCenter(),
            resolution: this.map.getResolution(),
            projection: this.map.getProjectionObject(),
            units: this.map.getProjectionObject().getUnits() || 
                this.map.units || this.map.baseLayer.units,
			features: features//OpenLayers.Util.extend({}, this.vectorLayer.features)
        };
    },

    /**
     * Method: restore
     * Update the state with the given object.
     *
     * Parameters:
     * state - {Object} An object representing the state to restore.
     */
    restore: function(state) {
        var center, zoom;
        if (this.map.getProjectionObject() == state.projection) { 
            zoom = this.map.getZoomForResolution(state.resolution);
            center = state.center;
        } else {
            center = state.center.clone();
            center.transform(state.projection, this.map.getProjectionObject());
            var sourceUnits = state.units;
            var targetUnits = this.map.getProjectionObject().getUnits() || 
                this.map.units || this.map.baseLayer.units;
            var resolutionFactor = sourceUnits && targetUnits ? 
                OpenLayers.INCHES_PER_UNIT[sourceUnits] / OpenLayers.INCHES_PER_UNIT[targetUnits] : 1;
            zoom = this.map.getZoomForResolution(resolutionFactor*state.resolution); 
        }
        this.map.setCenter(center, zoom);
		
		var features;
		features = state.features;
		this.vectorLayer.removeFeatures(this.vectorLayer.features);
		if(features && features.length){
			this.vectorLayer.addFeatures(features);
		}
		
    },
    
    /**
     * Method: writeStack
     */
    writeStack: function(stack) {
		var preStack = new Array();
        for (var i = 0; i < stack.length; i++) {
			var features = this.format.write(stack[i].features);
            var item = {
                center: stack[i].center,
                resolution: stack[i].resolution,
                projection: stack[i].projection,
                units: stack[i].units,
                features: features
            }
			preStack.push(item);
        }
		this.preStackJsonStr = this.jsonParser.write(preStack);
		return this.preStackJsonStr;
	},
    
    /**
     * Method: readStack
     */
    readStack: function(stackStr) {
		var preStack = new Array();
		if(!stackStr){
			return [];
		}
        var jsonObj = this.jsonParser.read(stackStr);
        for (var i = 0; i < jsonObj.length; i++) {
			 var item = {
                center: new OpenLayers.LonLat(jsonObj[i].center.lon, jsonObj[i].center.lat),
                resolution: jsonObj[i].resolution,
                projection: new OpenLayers.Projection(jsonObj[i].projection.projCode),
                units: jsonObj[i].units,
                features: this.format.read(jsonObj[i].features)
            }
			preStack.push(item);
        }
		return preStack;
	},
	
    /**
     * Method: setListeners
     * Sets functions to be registered in the listeners object.
     */
    setListeners: function() {
        this.listeners = {};
        for(var type in this.registry) {
            if (type == "featureadded" && this.vectorLayer) {
				//要素被添加后，触发该函数。保存这次操作。
				this.listeners["featureadded"] = OpenLayers.Function.bind(function(){
					if (!this.restoring) {
                        var state = this.registry["featureadded"].apply(this, arguments);
                        this.previousStack.unshift(state);
                        if (this.previousStack.length > 1) {
                            this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
                        }
                        if (this.previousStack.length > (this.limit + 1)) {
                            this.previousStack.pop();
                        }
                        if (this.nextStack.length > 0) {
                            this.nextStack = [];
                            this.onNextChange(null, 0);
                        }
						
						/* 保存至localStorage。HTML5的功能 */
						try{
							window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
							window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
						}catch(e){
							
						}
                    }
                    return true;
				}, this);
            } else if(type == "featureremoved" && this.vectorLayer){
				//要素被添加后，触发该函数。保存这次操作。
				this.listeners["featureremoved"] = OpenLayers.Function.bind(function(){
					if (!this.restoring) {
						if(!this.registry){
							return true;
						}
                        var state = this.registry["featureremoved"].apply(this, arguments);
                        this.previousStack.unshift(state);
                        if (this.previousStack.length > 1) {
                            this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
                        }
                        if (this.previousStack.length > (this.limit + 1)) {
                            this.previousStack.pop();
                        }
                        if (this.nextStack.length > 0) {
                            this.nextStack = [];
                            this.onNextChange(null, 0);
                        }
						
						/* 保存至localStorage。HTML5的功能 */
						try{
							window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
							window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
						}catch(e){
							
						}
                    }
                    return true;
				}, this);
			} else if(type == "moveend"){
				//地图被操作后，触发该函数。保存这次操作。
                this.listeners["moveend"] = OpenLayers.Function.bind(function(){
                    if (!this.restoring) {
						// 不支持HTML5
						if (!window.localStorage) {
							var state = this.registry["moveend"].apply(this, arguments);
	                        this.previousStack.unshift(state);
	                        if (this.previousStack.length > 1) {
	                            this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
	                        }
	                        if (this.previousStack.length > (this.limit + 1)) {
	                            this.previousStack.pop();
	                        }
	                        if (this.nextStack.length > 0) {
	                            this.nextStack = [];
	                            this.onNextChange(null, 0);
	                        }
						}
						
						// 支持HTML5
						if (window.localStorage) {
							//第一进入时，有要素则绘制在地图上。
							if (this.initFlag) {
								//this.previousTrigger();
								if (this.previousStack.length > 0) {
									var state = this.previousStack[0]
									if (state != undefined) {
										//this.nextStack.unshift(current);
										//this.previousStack.unshift(state);
										this.restoring = true;
										this.restore(state);
										this.restoring = false;
									}
								}
							}
							//不是第一次进入时
							if (!this.initFlag) {
								var state = this.registry["moveend"].apply(this, arguments);
								this.previousStack.unshift(state);
							}
							if (this.previousStack.length > 1) {
								this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
							}
							if (this.previousStack.length > (this.limit + 1)) {
								this.previousStack.pop();
							}
							
							//不是第一次进入时
							if (this.nextStack.length > 0 && !this.initFlag) {
								this.nextStack = [];
								this.onNextChange(null, 0);
							}
							else 
								if (this.initFlag) {//第一次进入时，是否可用前进。
									this.onNextChange(this.nextStack[0], this.nextStack.length);
									this.initFlag = false;
								}
								
							/* 保存至localStorage。HTML5的功能 */
							try{
								window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
								window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
							}catch(e){
								
							}
						}
                    }
                    return true;
                }, this);
			}
        }
    },

    /**
     * APIMethod: activate
     * 激活控件。
     *
     * Returns:
     * {Boolean} 是否激活成功。
     */
    activate: function() {
        var activated = false;
        if(this.map) {
            if(Geo.View2D.Control.prototype.activate.apply(this)) {
                if(this.listeners == null) {
                    this.setListeners();
                }
                for(var type in this.listeners) {
                    if (type == "featureadded" && this.vectorLayer) {
                        this.vectorLayer.events.register(type, this, this.listeners[type]);
                    } if (type == "featureremoved" && this.vectorLayer) {
						this.vectorLayer.events.register(type, this, this.listeners[type]);
                    } else {
                        this.map.events.register(type, this, this.listeners[type]);
                    }
                }
                activated = true;
                if(this.previousStack.length == 0) {
                    this.initStack();
                }
            }
        }
        return activated;
    },
    
    /**
     * Method: initStack
     * Called after the control is activated if the previous history stack is
     *     empty.
     */
    initStack: function() {
        if(this.map.getCenter()) {
            this.listeners.moveend();
        }
    },
    
    /**
     * APIMethod: deactivate
     * 关闭控件。
     *
     * Returns:
     * {Boolean} 是否关闭成功。
     */
    deactivate: function() {
        var deactivated = false;
        if(this.map) {
            if(Geo.View2D.Control.prototype.deactivate.apply(this)) {
                for(var type in this.listeners) {
                    this.map.events.unregister(
                        type, this, this.listeners[type]
                    );
                }
                if(this.clearOnDeactivate) {
                    this.clear();
                }
                deactivated = true;
            }
        }
        return deactivated;
    },
    
    /**
     * APIMethod: clearRecordStack
     * 清除localStorage对象中该控件记录的操作信息。
     */
    clearRecordStack: function() {
        window.localStorage.removeItem("previousStack");
        window.localStorage.removeItem("nextStack");
    },
	
    CLASS_NAME: "Geo.View2D.Control.GeoNavigationHistory"
});
/**
 * Class: Geo.View2D.Control.Measure.AreaMeasure
 * 面积量算类，继承自Geo.View2D.Control.Measure类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.Measure>
 */
Geo.View2D.Control.Measure.AreaMeasure = Geo.Class(OpenLayers.Control.Measure, {
	
	/**
     * APIProperty: result
     * {Array} 量算结果集合，用于存放量算结果和popup。
	 */
	result: null,
    
	/**
     * Property: currentPopups
     * {Array} 用于存放popup的数组。
	 */
    currentPopups: null,

    /**
     * APIProperty: persist
     * {Boolean} 如果设置为true，则在一次测量绘制完成后，保持这个临时的测量结果的几何要素。
     *  直到一个新的测量操作开始，几何要素被清除。
     *  如果设置为false，则在一次测量绘制完成后，清除几何要素。默认值为false。
     */
    persist: false,
	
	/**
     * Constructor: Geo.View2D.Control.Measure.AreaMeasure
     * 构造函数。生成一个Geo.View2D.Control.Measure.AreaMeasure的实例。
     */
    initialize: function(options){
    
        var areaMeatureHandler = OpenLayers.Class(OpenLayers.Handler.Polygon, {
        
            moveTitleDiv: null,
            
            deactivate: function(){
                if (!OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
                    return false;
                }
				
				//清除所有的量算结果。
                this.control.destoryAllResult();
				if(this.moveTitleDiv){
					this.moveTitleDiv.style.display = "none";
				}
				
                // call the cancel callback if mid-drawing
                if (this.lastUp) {
                    this.cancel();
                }
                
                 this.destroyFeature();
                 // If a layer's map property is set to null, it means that that layer
                 // isn't added to the map. Since we ourself added the layer to the map
                 // in activate(), we can assume that if this.layer.map is null it means
                 // that the layer has been destroyed (as a result of map.destroy() for
                 // example.
                 if (this.layer.map != null) {
                 	this.layer.destroy(false);
                 }
                 this.layer = null;
                 
                return true;
            },
            
			/**
             * 绘制结束后不立即清除本次量算线段。
             * @param {Object} cancel
             */
            finalize: function(cancel){
				OpenLayers.Handler.Path.prototype.finalize.apply(this, arguments);
				if(this.layer && (cancel || !this.persist)) {
		            this.control.destoryAllResult();
		        }
            },
			
            /**
			 * 鼠标移动时光标显示提示信息，当未开始点击时显示"单击确定起点"。
			 * 点击起点后显示"单击确定中间点，双击结束量算"。
			 * 提示信息距光标位置有一定偏移量。
			 * @param {Object} evt
			 */
            mousemove: function(evt){
                var result = OpenLayers.Handler.Path.prototype.mousemove.apply(this, arguments);
                if (!this.moveTitleDiv) {
                    this.moveTitleDiv = document.createElement("div");
                    this.map.viewPortDiv.appendChild(this.moveTitleDiv);
                }else {
                    this.moveTitleDiv.style.display = "";
                }
                
                var msg = "";
                if (this.lastUp) {
                    msg = "单击确定起点，双击结束量算";
                }
                else {
                    msg = "单击确定起点";
                }
                
                this.moveTitleDiv.innerHTML = msg;
                this.moveTitleDiv.style.position = "absolute";
                this.moveTitleDiv.style.zIndex = this.control.div.style.zIndex;
                this.moveTitleDiv.style.left = evt.xy.x + 15 + "px";
                this.moveTitleDiv.style.top = evt.xy.y + 15 + "px";
                
                return result;
            },
			up: function(){
				var result = OpenLayers.Handler.Path.prototype.up.apply(this, arguments);
				if(this.persist) {
					this.control.destoryResult(this.control.result.length - 1);
				}
				return result;
			}
        });
        var handler = areaMeatureHandler;
        
        this.result = [];
        this.currentPopups = [];
        OpenLayers.Control.Measure.prototype.initialize.apply(this, [handler, options]);
        
        this.events.on({
            "measure": this.handleMeasurementsEnd,
            "measurepartial": this.handleMeasurements
        });
    },
    
    /**
     * Method: measurePartial
     * 判断第一次点击时节点提示为"起点"。
     * 
     * point - {<Geo.Geometry.Point>} 几何点对象。
     * geometry - {<Geo.Geometry>} 几何对象。
     */
    measurePartial: function(point, geometry){
        OpenLayers.Control.Measure.prototype.measurePartial.apply(this, arguments);
    },
    
    /**
     * Method: addNodePopup
     * 添加节点提示框，并保存到currentPopups数组。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * out - {String} 输出的HTML内容。
     */
    addNodePopup: function(lonlat, out){
    
        var popup = new OpenLayers.Popup("chicken", lonlat, null, "<span class='rightBg'>" + out + "<span>", false);
        popup.autoSize = true;
        popup.setBackgroundColor("transparent");
        this.map.addPopup(popup);
        this.currentPopups.push(popup);
    },
    
    /**
     * Method: destoryResult
     * 清除指定索引号的量算结果。
     * 
     * Parameters:
     * resultIndex - {Number} 指定索引号。
     */
    destoryResult: function(resultIndex){
        var result = this.result[resultIndex];
		if(!result){
			return;
		}
        var feature = result.feature;
        var popups = result.popups;
        if (typeof(feature) == "string") {
            feature = this.handler.layer.getFeatureById(feature);
        }
        this.handler.layer.destroyFeatures([feature]);
        for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
        
    },
	
    /**
     * Method: destoryResult
     * 清除所有的量算结果。
     */
    destoryAllResult: function(){
		for (var i = 0; i < this.result.length; i++) {
            this.destoryResult(i);
        }
		this.result = [];
    },
	
    /**
     * APIMethod: handleMeasurements
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurements: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
    },
	
    /**
     * APIMethod: handleMeasurementsEnd
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurementsEnd: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
		if(!measure){
			return;
		}
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
        
        //getCentroid取质心点
        var point = geometry.getCentroid();
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
        var currentPolygon = this.handler.polygon;
        this.addNodePopup(ll, "总面积：" + out + "<a id = '" + geometry.id + "_a' class='result_close' href='#' style=''> X</a>");
        
        var resultIndex = this.result.length;
        document.getElementById(geometry.id + "_a").onclick = OpenLayers.Function.bind(function(){
            this.destoryResult(resultIndex);
        }, this);
        
        this.result.push({
            feature: currentPolygon,
            popups: this.currentPopups
        });
        this.currentPopups = [];
    }
    
});
/**
 * Class: Geo.View2D.Control.Measure.DistanceMeasure
 * 距离量算类，继承自Geo.View2D.Control.Measure类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.Measure>
 */
Geo.View2D.Control.Measure.DistanceMeasure = Geo.Class(Geo.View2D.Control.Measure, {
    
	/**
     * APIProperty: result
     * {Array} 量算结果集合，用于存放量算结果和popup。
	 */
	result: null,
    
	/**
     * Property: currentPopups
     * {Array} 用于存放popup的数组。
	 */
    currentPopups: null,

    /**
     * APIProperty: persist
     * {Boolean} 如果设置为true，则在一次测量绘制完成后，保持这个临时的测量结果的几何要素。
     *  直到一个新的测量操作开始，几何要素被清除。
     *  如果设置为false，则在一次测量绘制完成后，清除几何要素。默认值为false。
     */
    persist: false,
	
    /**
     * Constructor: Geo.View2D.Control.Measure.DistanceMeasure
     * 构造函数。生成一个Geo.View2D.Control.Measure.DistanceMeasure的实例。
     */
    initialize: function(options){
        var distanceMeatureHandler = OpenLayers.Class(OpenLayers.Handler.Path, {
        
            //量算过程所有中间点
            points: null,
            
            //移动时光标提示框
            moveTitleDiv: null,
            
            //关闭控件时需要手工来清除绘制的多个距离量算结果
            deactivate: function(){
                if (!OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
                    return false;
                }
				
				//清除所有的量算结果。
                this.control.destoryAllResult();
				this.control.removerNodePopups();
				if(this.moveTitleDiv){
					this.moveTitleDiv.style.display = "none";
				}
                // call the cancel callback if mid-drawing
                if (this.lastUp) {
                    this.cancel();
                }
                
                 this.destroyFeature();
                 // If a layer's map property is set to null, it means that that layer
                 // isn't added to the map. Since we ourself added the layer to the map
                 // in activate(), we can assume that if this.layer.map is null it means
                 // that the layer has been destroyed (as a result of map.destroy() for
                 // example.
                 if (this.layer.map != null) {
                     this.layer.destroy(false);
                 }
                 this.layer = null;
                 
                return true;
            },
            
            /**
             * 绘制结束后不立即清除本次量算线段。
             * @param {Object} cancel
             */
            finalize: function(cancel){
				OpenLayers.Handler.Path.prototype.finalize.apply(this, arguments);
				if(this.layer && (cancel || !this.persist)) {
		            this.control.destoryAllResult();
		        }

//				var key = cancel ? "cancel" : "done";
//		        this.mouseDown = false;
//		        this.lastDown = null;
//		        this.lastUp = null;
//		        this.lastTouchPx = null;
//		        this.callback(key, [this.geometryClone()]);
//		        //this.destroyFeature(cancel);
//				this.line = null;
//				this.point = null;
            },
            
			/**
			 * 鼠标移动时光标显示提示信息，当未开始点击时显示"单击确定起点"。
			 * 点击起点后显示"单击确定中间点，双击结束量算"。
			 * 提示信息距光标位置有一定偏移量。
			 * @param {Object} evt
			 */
            mousemove: function(evt){
                var result = OpenLayers.Handler.Path.prototype.mousemove.apply(this, arguments);
                if (!this.moveTitleDiv) {
                    this.moveTitleDiv = document.createElement("div");
                    this.map.viewPortDiv.appendChild(this.moveTitleDiv);
                }else{
					this.moveTitleDiv.style.display = "";
				}
                
                var msg = "";
                if (this.lastUp) {
                    msg = "单击确定中间点，双击结束量算";
                }
                else {
                    msg = "单击确定起点";
                }
                this.moveTitleDiv.innerHTML = msg;
                this.moveTitleDiv.style.position = "absolute";
                this.moveTitleDiv.style.zIndex = this.control.div.style.zIndex;
                this.moveTitleDiv.style.left = evt.xy.x + 15 + "px";
                this.moveTitleDiv.style.top = evt.xy.y + 15 + "px";
                return result;
            },
			up: function(){
				var result = OpenLayers.Handler.Path.prototype.up.apply(this, arguments);
				if(this.persist) {
					this.control.destoryResult(this.control.result.length - 1);
				}
				return result;
			}
        });
        var handler = distanceMeatureHandler;
        
        //支持保存多个距离结果，保存当前所有节点提示框
        this.result = [];
        this.currentPopups = [];
        
        OpenLayers.Control.Measure.prototype.initialize.apply(this, [handler, options]);
        
        //量算过程中和结束有不同处理
        this.events.on({
            "measure": this.handleMeasurementsEnd,
            "measurepartial": this.handleMeasurements
        });
    },
    
    /**
     * Method: measurePartial
     * 判断第一次点击时节点提示为"起点"。
     * 
     * point - {<Geo.Geometry.Point>} 几何点对象。
     * geometry - {<Geo.Geometry>} 几何对象。
     */
    measurePartial: function(point, geometry){
        if (geometry.getLength() == 0) {
            var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
            this.addNodePopup(ll, "起点");
        }
        
        OpenLayers.Control.Measure.prototype.measurePartial.apply(this, arguments);
    },
    
    /**
     * Method: addNodePopup
     * 添加节点提示框，并保存到currentPopups数组。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * out - {String} 输出的HTML内容。
     */
    addNodePopup: function(lonlat, out){
    
        var popup = new OpenLayers.Popup("chicken", lonlat, null, "<span class='rightBg'>" + out + "<span>", false);
        popup.autoSize = true;
        popup.setBackgroundColor("transparent");
        this.map.addPopup(popup);
        this.currentPopups.push(popup);
    },
    
    /**
     * Method: removerNodePopups
     * 删除节点提示框。
     */
    removerNodePopups: function(){
		var popups = this.currentPopups;
		for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
    
    /**
     * Method: destoryResult
     * 清除指定索引号的量算结果。
     * 
     * Parameters:
     * resultIndex - {Number} 指定索引号。
     */
    destoryResult: function(resultIndex){
        var result = this.result[resultIndex];
		if(!result){
			return;
		}
        var feature = result.feature;
        var popups = result.popups;
        if (typeof(feature) == "string") {
            feature = this.handler.layer.getFeatureById(feature);
        }
        this.handler.layer.destroyFeatures([feature]);
        for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
	
    /**
     * Method: destoryResult
     * 清除所有的量算结果。
     */
    destoryAllResult: function(){
		for (var i = 0; i < this.result.length; i++) {
            this.destoryResult(i);
        }
		this.result = [];
    },
    
    /**
     * APIMethod: handleMeasurements
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurements: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
		if(measure == 0){
			return;
		}
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
        
        var point = geometry.components[geometry.components.length - 1];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 5, point.y - this.map.getResolution() * 5);
        this.addNodePopup(ll, out);
    },
    
    /**
     * APIMethod: handleMeasurementsEnd
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurementsEnd: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
        
        var point = geometry.components[geometry.components.length - 1];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
        var currentPath = this.handler.line;
        this.addNodePopup(ll, "总长：" + out + "<a id = '" + geometry.id + "_a' class='result_close' href='#' style=''> X</a>");
        
        var resultIndex = this.result.length;
        document.getElementById(geometry.id + "_a").onclick = OpenLayers.Function.bind(function(){
            this.destoryResult(resultIndex);
        }, this);
        
        this.result.push({
            feature: currentPath,
            popups: this.currentPopups
        });
        this.currentPopups = [];
    }


});
/**
 * Class: Geo.View2D.Control.Measure.Angle
 * 角度量算类，继承自Geo.View2D.Control.Measure类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 *
 * Inherits from:
 *  - <Geo.View2D.Control.Measure>
 */
Geo.View2D.Control.Measure.Angle = Geo.Class(Geo.View2D.Control.Measure, {
	
    /**
     * Constructor: Geo.View2D.Control.Measure.Angle
     * 构造函数。生成一个Geo.View2D.Control.Measure.Angle的实例。
     * 
     * Parameters:
     * options - {Object} 构造参数选项。
     */
    initialize: function(options){
        var handler = Geo.View2D.Handler.Path;
        Geo.View2D.Control.Measure.prototype.initialize.apply(this, [handler, options]);
    },
	
	/**
     * Method: measure
     *
     * Parameters:
     * geometry - {<Geo.View2D.Geometry>}
     * eventType - {String}
     */
    measure: function(geometry, eventType) {
        var stat, order;
        if(geometry.CLASS_NAME.indexOf('LineString') > -1) {
            //stat = this.getBestLength(geometry);
            stat = this.getAngle(geometry);
            order = 3;
        }
        this.events.triggerEvent(eventType, {
            measure: stat[0],
            units: stat[1],
			angles: stat[2],
            order: order,
            geometry: geometry
        });
    },
	
	/**
     * Method: getAngle
     * 获取当前绘制的线段与前一绘制的线段之间的角度值。
     *
     * Parameters:
     * geometry - {<Geo.View2D.Geometry>}
     *
     * Returns:
     * {Array([Float, String, Array])}
     * 返回一个数组，包含3个选项，最后量算的角度值，角度单位，所有量算的角度值的数组。
     */
    getAngle: function(geometry) {
        var unit = "°";
        var angle = 0;
        var angles = new Array();
		var kqs = [];
		var length = geometry.components.length;
        length = (geometry.components[length - 1].x == geometry.components[length - 2].x && geometry.components[length - 1].y == geometry.components[length - 2].y) ? length - 1 : length;
		for (var i = 0; i < length; i++) {
            if (i) {
                var x1 = geometry.components[i - 1].x;
                var y1 = geometry.components[i - 1].y;
                var x2 = geometry.components[i].x;
                var y2 = geometry.components[i].y;
				//直线的斜率
                var k = (y2 - y1) / (x2 - x1);
                
                var quadrant = "";
                if (y2 > y1 && x2 > x1) {
                    quadrant = 1;//"rt";//第一象限
                }
                if (y2 > y1 && x2 < x1) {
                    quadrant = 2;//"lt";//第二象限
                }
                if (y2 < y1 && x2 < x1) {
                    quadrant = 3;//"lb";//第三象限
                }
                if (y2 < y1 && x2 > x1) {
                    quadrant = 4;//"rb";//第四象限
                }
                
                kqs.push({
                    k: k,
                    quadrant: quadrant
                });
                if (i > 1) {
                    var k1 = kqs[i - 2].k;
                    var k2 = kqs[i - 1].k;
                    //两直线的斜率分别用k1与k2表示，则两直线夹角x的正切值可用下述公式表示：
                    //var tanx = Math.abs((k2 - k1) / (1 + (k2 * k1)));
                    var tanx = (k2 - k1) / (1 + (k2 * k1));
                    //反正切值。返回的值是 -PI/2 到 PI/2 之间的弧度值。
                    var radian = Math.atan(tanx);
                    //算角度值。弧度=角度*（2PI/360）
                    var angle = radian / ((2 * Math.PI) / 360);
                    
                    var q1 = kqs[i - 2].quadrant;
                    var q2 = kqs[i - 1].quadrant;
                    
//					一 一：正数则180-，负数则+180
//					一 二：正数则180-，负数则取绝对值
//					一 三：正负数都取绝对值
//					一 四：正数取绝对值，负数则+180
//					
//					二 一：正数取绝对值，负数则+180
//					二 二：正数则180-，负数则+180
//					二 三：正数则180-，负数则取绝对值
//					二 四：正负数都取绝对值
//					
//					三 一：正负数都取绝对值
//					三 二：正数取绝对值，负数则+180
//					三 三：正数则180-，负数则+180
//					三 四：正数则180-，负数则取绝对值
//					
//					四 一：正数则180-，负数则取绝对值
//					四 二：正负数都取绝对值
//					四 三：正数取绝对值，负数则+180
//					四 四：正数则180-，负数则+180
                    var res = (q2 - q1) < 0 ? (q2 - q1) + 4 : (q2 - q1);
                    switch (res) {
                        case 0:
                            angle = (angle > 0) ? (180 - angle) : (180 + angle);
                            break;
                        case 1:
                            angle = (angle > 0) ? (180 - angle) : Math.abs(angle);
                            break;
                        case 2:
                            angle = Math.abs(angle);
                            break;
                        case 3:
                            angle = (angle > 0) ? angle : (180 + angle);
                            break;
                    }
					angles.push(angle);
					
                }
            }
        }
        return [angle, unit, angles];
    }
});
/**
 * Class: Geo.View2D.Control.Measure.AngleMeasure
 * 角度量算类，继承自Geo.View2D.Control.Measure.Angle类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 在地图上动态显示每次测量的角度。
 *
 * Inherits from:
 *  - <Geo.View2D.Control.Measure.Angle>
 */
Geo.View2D.Control.Measure.AngleMeasure = Geo.Class(Geo.View2D.Control.Measure.Angle, {
    
	/**
     * APIProperty: result
     * {Array} 量算结果集合，用于存放量算结果和popup。
	 */
	result: null,
    
	/**
     * Property: currentPopups
     * {Array} 用于存放popup的数组。
	 */
    currentPopups: null,

    /**
     * APIProperty: persist
     * {Boolean} 如果设置为true，则在一次测量绘制完成后，保持这个临时的测量结果的几何要素。
     *  直到一个新的测量操作开始，几何要素被清除。
     *  如果设置为false，则在一次测量绘制完成后，清除几何要素。默认值为false。
     */
    persist: false,
	
    /**
     * Constructor: Geo.View2D.Control.Measure.DistanceMeasure
     * 构造函数。生成一个Geo.View2D.Control.Measure.DistanceMeasure的实例。
     */
    initialize: function(options){
        var distanceMeatureHandler = OpenLayers.Class(OpenLayers.Handler.Path, {
        
            //量算过程所有中间点
            points: null,
            
            //移动时光标提示框
            moveTitleDiv: null,
            
            //关闭控件时需要手工来清除绘制的多个距离量算结果
            deactivate: function(){
                if (!OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
                    return false;
                }
				
				//清除所有的量算结果。
                this.control.destoryAllResult();
				this.control.removerNodePopups();
				if(this.moveTitleDiv){
					this.moveTitleDiv.style.display = "none";
				}
                // call the cancel callback if mid-drawing
                if (this.lastUp) {
                    this.cancel();
                }
                
                 this.destroyFeature();
                 // If a layer's map property is set to null, it means that that layer
                 // isn't added to the map. Since we ourself added the layer to the map
                 // in activate(), we can assume that if this.layer.map is null it means
                 // that the layer has been destroyed (as a result of map.destroy() for
                 // example.
                 if (this.layer.map != null) {
                     this.layer.destroy(false);
                 }
                 this.layer = null;
                 
                return true;
            },
            
            /**
             * 绘制结束后不立即清除本次量算线段。
             */
            finalize: function(cancel){
				OpenLayers.Handler.Path.prototype.finalize.apply(this, arguments);
				if(this.layer && (cancel || !this.persist)) {
		            this.control.destoryAllResult();
		        }
            },
            
			/**
			 * 鼠标移动时光标显示提示信息，当未开始点击时显示"单击确定起点"。
			 * 点击起点后显示"单击确定中间点，双击结束量算"。
			 * 提示信息距光标位置有一定偏移量。
			 */
            mousemove: function(evt){
                var result = OpenLayers.Handler.Path.prototype.mousemove.apply(this, arguments);
                if (!this.moveTitleDiv) {
                    this.moveTitleDiv = document.createElement("div");
                    this.map.viewPortDiv.appendChild(this.moveTitleDiv);
                }else{
					this.moveTitleDiv.style.display = "";
				}
                
                var msg = "";
                if (this.lastUp) {
                    msg = "单击确定中间点，双击结束量算";
                }
                else {
                    msg = "单击确定起点";
                }
                this.moveTitleDiv.innerHTML = msg;
                this.moveTitleDiv.style.position = "absolute";
                this.moveTitleDiv.style.zIndex = this.control.div.style.zIndex;
                this.moveTitleDiv.style.left = evt.xy.x + 15 + "px";
                this.moveTitleDiv.style.top = evt.xy.y + 15 + "px";
                return result;
            },
			up: function(){
				var result = OpenLayers.Handler.Path.prototype.up.apply(this, arguments);
				if(this.persist) {
					this.control.destoryResult(this.control.result.length - 1);
				}
				return result;
			}
        });
        var handler = distanceMeatureHandler;
        
        //支持保存多个距离结果，保存当前所有节点提示框
        this.result = [];
        this.currentPopups = [];
        
        OpenLayers.Control.Measure.prototype.initialize.apply(this, [handler, options]);
        
        //量算过程中和结束有不同处理
        this.events.on({
            "measure": this.handleMeasurementsEnd,
            "measurepartial": this.handleMeasurements
        });
    },
    
    /**
     * Method: measurePartial
     * 判断第一次点击时节点提示为"起点"。
     * 
     * point - {<Geo.Geometry.Point>} 几何点对象。
     * geometry - {<Geo.Geometry>} 几何对象。
     */
    measurePartial: function(point, geometry){
        if (geometry.getLength() == 0) {
            var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
            this.addNodePopup(ll, "起点");
        }
        
        OpenLayers.Control.Measure.prototype.measurePartial.apply(this, arguments);
    },
    
    /**
     * Method: addNodePopup
     * 添加节点提示框，并保存到currentPopups数组。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * out - {String} 输出的HTML内容。
     */
    addNodePopup: function(lonlat, out){
    
        var popup = new OpenLayers.Popup("chicken", lonlat, null, "<span class='rightBg'>" + out + "<span>", false);
        popup.autoSize = true;
        popup.setBackgroundColor("transparent");
        this.map.addPopup(popup);
        this.currentPopups.push(popup);
    },
    
    /**
     * Method: removerNodePopups
     * 删除节点提示框。
     */
    removerNodePopups: function(){
		var popups = this.currentPopups;
		for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
    
    /**
     * Method: destoryResult
     * 清除指定索引号的量算结果。
     * 
     * Parameters:
     * resultIndex - {Number} 指定索引号。
     */
    destoryResult: function(resultIndex){
        var result = this.result[resultIndex];
		if(!result){
			return;
		}
        var feature = result.feature;
        var popups = result.popups;
        if (typeof(feature) == "string") {
            feature = this.handler.layer.getFeatureById(feature);
        }
        this.handler.layer.destroyFeatures([feature]);
        for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
	
    /**
     * Method: destoryResult
     * 清除所有的量算结果。
     */
    destoryAllResult: function(){
		for (var i = 0; i < this.result.length; i++) {
            this.destoryResult(i);
        }
		this.result = [];
    },
    
    /**
     * APIMethod: handleMeasurements
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurements: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
		if(measure == 0){
			return;
		}
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }else if(order == 2){
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }else if(order == 3){
			out += measure.toFixed(3) + " " + units;
		}
        //element.innerHTML = out;
        var point = geometry.components[geometry.components.length - 3];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 5, point.y - this.map.getResolution() * 5);
        this.addNodePopup(ll, out);
    },
    
    /**
     * APIMethod: handleMeasurementsEnd
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurementsEnd: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }else if(order == 2){
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }else if(order == 3){
			out += measure.toFixed(3) + " " + units;
		}
        //element.innerHTML = out;
        
        var point = geometry.components[geometry.components.length - 2];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
        var currentPath = this.handler.line;
        this.addNodePopup(ll, "" + out + "<a id = '" + geometry.id + "_a' class='result_close' href='#' style=''> X</a>");
        
        var resultIndex = this.result.length;
        document.getElementById(geometry.id + "_a").onclick = OpenLayers.Function.bind(function(){
            this.destoryResult(resultIndex);
        }, this);
        
        this.result.push({
            feature: currentPath,
            popups: this.currentPopups
        });
        this.currentPopups = [];
    }
});
/**
 * Class: Geo.View2D.Control.MapContextMenu
 * 鼠标右键地图菜单控件类。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.MapContextMenu = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: autoActivate
     * {Boolean} 是否自动激活。默认为true。
     */
    autoActivate: true,
    
    /** 
     * APIProperty: menuDiv
     * {DOMElement} 鼠标右键地图菜单容器。
     */
    menuDiv: null,
    
    /** 
     * APIProperty: contentHTML
     * {String} 鼠标右键地图菜单的内容。
     */
    contentHTML: null,
	
    /** 
     * APIProperty: lastRightClickXY
     * {<Geo.Pixel>} 最后一次右键点击的地图屏幕坐标信息。
     */
    lastRightClickXY: null,
	
    /** 
     * APIProperty: lastRightClickLonLat
     * {<Geo.LonLat>} 最后一次右键点击的经纬度坐标信息。
     */
    lastRightClickLonLat: null,
    
    /** 
     * Property: handlerOptions
     * {object}
     */
    handlerOptions: null,
    
    /**
     * Property: handleRightClicks
     * {Boolean} 是否开启鼠标右键点击事件。默认为true。
     */
    handleRightClicks: true,
    
    /**
     * Constructor: Geo.View2D.Control.MapContextMenu
     * 鼠标右键地图菜单控件的构造函数。
     * 
     * Parameters:
     * options - {Object} 构造参数选项。
     */
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, arguments);
        this.handlerOptions = OpenLayers.Util.extend({}, this.handlerOptions);
        this.handler = new Geo.View2D.Handler.Click(this, {
            'rightclick': this.showContextMenu,
            'click': this.leftClick
        }, this.handlerOptions);
        this.handler.mousedown = function(evt){
            this.control.hide();
            return Geo.View2D.Handler.Click.prototype.mousedown.apply(this, arguments);
        }
    },
    
    /**
     * Method: setMap
     */
    setMap: function(map){
        Geo.View2D.Control.prototype.setMap.apply(this, [map]);
    },
    
    /**
     * Method: destroy
     */
    destroy: function(){
        this.deactivate();
        Geo.View2D.Control.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * APIMethod: activate
     * 激活地图的右键菜单。
     * 
     * Returns:
     * {Boolean} 是否激活成功。
     */
    activate: function(){
        if (Geo.View2D.Control.prototype.activate.apply(this, arguments)) {
            this.map.viewPortDiv.oncontextmenu = OpenLayers.Function.False;
            return true;
        }
        else {
            return false;
        }
    },
    
    /**
     * APIMethod: deactivate
     * 关闭地图的右键菜单。
     * 
     * Returns:
     * {Boolean} 是否关闭成功。
     */
    deactivate: function(){
        if (Geo.View2D.Control.prototype.deactivate.apply(this, arguments)) {
            this.hide();
            this.map.viewPortDiv.oncontextmenu = OpenLayers.Function.True;
            return true;
        }
        else {
            return false;
        }
    },
    
    /**
     * Method: draw
     * 
     * Returns:
     * {DOMElement}
     */
    draw: function(){
        Geo.View2D.Control.prototype.draw.apply(this, arguments);
        var menu = this.div;
        menu.style.position = "absolute";
        menu.style.background = "white";
        menu.style.border = "1px solid #adbfe4";
        menu.style.zIndex = this.map.Z_INDEX_BASE['Control'] + this.map.controls.length;
        menu.innerHTML = this.contentHTML ? this.contentHTML : "";
        this.menuDiv = menu;
		this.menuDiv.onmousedown = OpenLayers.Function.bind(function(){
			//火狐事件对象event为arguments[0]。IE和chrome的事件对象则全局存在event。
        	var evt = arguments[0] || event;
			OpenLayers.Event.stop(evt);
        }, this);
        this.hide();
        this.map.viewPortDiv.appendChild(this.menuDiv);
        return this.div;
    },
    
    /**
     * Method: click
     */
    leftClick: function(evt){
    },
    
    /**
     * Method: showContextMenu
     * 点击右键在地图上显示菜单。
     */
    showContextMenu: function(evt){
        this.lastRightClickXY = evt.xy;
        this.lastRightClickLonLat = this.map.getLonLatFromPixel(evt.xy);
        var menu = this.menuDiv;
        menu.style.left = evt.xy.x + "px";
        menu.style.top = evt.xy.y + "px";
        this.show();
    },
    
    /**
     * Method: show
     * 显示右键菜单。
     */
    show: function(){
        if (this.menuDiv && this.menuDiv.style.display == "none") {
            this.menuDiv.style.display = "";
        }
    },
    
    /**
     * Method: hide
     * 隐藏右键菜单。
     */
    hide: function(){
        if (this.menuDiv && this.menuDiv.style.display != "none") {
            this.menuDiv.style.display = "none";
        }
    },
    
    /**
     * APIMethod: setContentHTML
     * 设置右键菜单的内容。
     *
     * Parameters:
     * contentHTML - {String} 右键菜单的HTML字符串。
     */
    setContentHTML: function(contentHTML){
        if (contentHTML != null) {
            this.contentHTML = contentHTML;
        }
        if ((this.menuDiv != null) && (this.contentHTML != null) &&
        (this.contentHTML != this.menuDiv.innerHTML)) {
            this.menuDiv.innerHTML = this.contentHTML;
        }
    },
	
    /**
     * APIMethod: addItem
     * 添加菜单选项。
     * 
     * Parameters:
     * menuItem - {<Geo.View2D.MenuItem>} 鼠标右键地图菜单选项。
     */
    addItem: function(menuItem){
        var itemDiv = document.createElement("div");
        itemDiv.style.cssText = "padding-bottom: 2px; line-height: 17px; margin: 0px 2px; padding-left: 6px; width:" + menuItem.width + "px; padding-right: 6px; color: #000; font-size: 12px; cursor: pointer; padding-top: 2px;";
		itemDiv.innerHTML = "<span>" + menuItem.text + "</span>";
		itemDiv.onclick = OpenLayers.Function.bind(function(){
			menuItem.callback();
			this.hide();
        }, this);
		itemDiv.onmouseover = function(){
			itemDiv.style.color = "#6688cc";
		}
		itemDiv.onmouseout = function(){
			itemDiv.style.color = "#000";
		}
        this.menuDiv.appendChild(itemDiv);
		this.setContentHTML(this.menuDiv.innerHTML);
    },
	
    /**
     * APIMethod: addSeparator
     * 添加菜单的分割线。
     */
	addSeparator: function(){
		var separatorDiv = document.createElement("div");
        separatorDiv.style.cssText = "border-bottom:#adbfe4 1px solid;margin:0px 6px;font-size:0px;padding:1px";
		this.menuDiv.appendChild(separatorDiv);
		this.setContentHTML(this.menuDiv.innerHTML);
	},
    
    CLASS_NAME: "Geo.View2D.Control.MapContextMenu"
});
﻿/**
 * Class: Geo.View2D.Control.TimeSlider
 * 时间轴控件类，控件为可视控件类型。该控件可设置时间轴上的刻度总数目，根据刻度总数把时间轴整条分成各个小段。
 * > 时间轴控件可以结合要素渲染，展现某段时间内的矢量要素按时间点先后顺序的动画绘制效果，使用时间轴来控制动画的播放进度。
 * > 时间轴控件类的功能包括：
 * > 1、用户使用鼠标左键按住时间轴指针进行拖动，来控制进度；
 * > 2、用户使用鼠标左键点击时间轴上某一刻度来控制进度的跳转。
 * > 3、控件具有“播放”、“暂停”、“前进”，“后退”的功能。
 * > 4、点击“播放”时，时间轴指针每秒移动一个刻度距离，直到移动至最后一个刻度线为止。
 * > 5、点击“暂停”，时间轴指针将停止不动，如这时再点击“播放”，则指针继续移动。
 * > 6、点击“后退”按钮，指针回退一个刻度。点击“前进”按钮，指针前进一个刻度。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.TimeSlider = Geo.Class(Geo.View2D.Control, {
	
    /**
     * Property: mouseDragStart
     * {Number} 鼠标拖动起点标识。
     */
    mouseDragStart: null,
	
    /**
     * Property: tmpNewWidthPX
     * {Number} 该属性临时最新存储进度条长度。
     */
    tmpNewWidthPX: null,
	
    /**
     * Property: progressBarPX
     * {Number} 进度条长度。
     */
    progressBarPX: null,
	
    /**
     * APIProperty: markNum
     * {Number} 进度条分成多少个刻度。
     */
	markNum: 100,
	
    /**
     * APIProperty: currentMark
     * {Number} 当前进度条所指向的刻度数。
     */
	currentMark: 0,
	
    /**
     * Property: timerId
     * {Object} 定时器的ID。
     */
    timerId: null,
	
    /**
     * APIProperty: interval
     * {Integer} 播放间隔。单位：毫秒。默认为1000毫秒。
     */
    interval: 1000,
	
    /**
     * APIProperty: onSliderBarMove
     * {Function} 时间轴指针移动时，调用该函数，具体事情由用户实现。
     */
	onSliderBarMove: function(){},
	
    /**
     * APIProperty: markInfo
     * {Array(String)} 时间点数组。
     */
	markInfo: null,
	
	/**
     * Constructor: Geo.View2D.Control.TimeSlider
     * 创建时间轴对象实例。
     *
     * Parameters:
     * options - {Object} 对象构造参数。
     */
    initialize: function(options){
        OpenLayers.Control.prototype.initialize.apply(this, arguments);
	},
	
    /** 
     * Method: setMap
     * 该控件与地图对象关联。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map){
        Geo.View2D.Control.prototype.setMap.apply(this, arguments);
    },


	/**
    * Method: draw
    *
    * Parameters:
    * px - {<Geo.Pixel>} 
    */
    draw: function(px){
		var timeSliderDiv = document.getElementById("timeSliderDiv");
		timeSliderDiv.innerHTML = Geo.View2D.Control.TimeSlider.timeSliderDivHTML;
		this.timeSliderDiv = timeSliderDiv;
		
		var sliderMoveableInfoDIV = document.getElementById("sliderMoveableInfo");
		this.sliderMoveableInfoDIV = sliderMoveableInfoDIV;
		
		var remainingBar = document.getElementById("remainingBar");
		var progressBar = document.getElementById("progressBar");
		var sliderBar = document.getElementById("sliderFocusNode");
		this.remainingBar = remainingBar;
		this.progressBar = progressBar;
		this.sliderBar = sliderBar;
		//进度条指针事件对象。
        this.sliderEvents = new OpenLayers.Events(this, sliderBar, null, true, {
            includeXY: true
        });
        this.documentEvents = new OpenLayers.Events(this, document, null, true, {
            includeXY: true
        });
		//设置进度条事件
        this.sliderEvents.on({
            "mousedown": this.sliderBarDown,
            "mousemove": this.sliderBarDrag,
            "mouseup": this.sliderBarUp
        });
		
		//设置初始化进度条长度。
		this.setProgressBarWidth();
		
		//绑定播放，后退，前进按钮的事件。
		var playButton = document.getElementById("playButton");
		var prevButton = document.getElementById("prevButton");
		var nextButton = document.getElementById("nextButton");
		this.playButton = playButton;
		this.prevButton = prevButton;
		this.nextButton = nextButton;
		this.playButton.onclick = OpenLayers.Function.bind(function(){
			if(this.timerId == null){
				this.play();
			}else{
				this.pause();
			}
		}, this);
		this.prevButton.onclick = OpenLayers.Function.bind(function(){
			if (this.timerId == null) {
				this.previous();
			}
		}, this);
		this.nextButton.onclick = OpenLayers.Function.bind(function(){
			if (this.timerId == null) {
				this.next();
			}
		}, this);
		
		//在进度条下填充刻度线。
		this._setRuleMarksHTML();
		
		
		//鼠标在进度条上时，进度条变色。
		this.sliderBar.onmouseover = OpenLayers.Function.bind(function(){
			this.sliderBar.className = "sliderImage sliderImageHover";
		}, this);
		this.sliderBar.onmouseout = OpenLayers.Function.bind(function(){
			if(this.mouseDragStart == null){
				this.sliderBar.className = "sliderImage";
			}
		}, this);
		var sliderBarContainerTable = document.getElementById("sliderBarContainerTableID");
		this.sliderBarContainerTable = sliderBarContainerTable;
		this.sliderBarContainerTable.onmouseover = OpenLayers.Function.bind(function(){
			this.sliderBarContainerTable.className = "timeSliderTable sliderBarContainerTable sliderHover";
		}, this);
		this.sliderBarContainerTable.onmouseout = OpenLayers.Function.bind(function(){
			if (this.mouseDragStart == null) {
				this.sliderBarContainerTable.className = "timeSliderTable sliderBarContainerTable";
			}
		}, this);
		
		
		//鼠标点击进度条上时，进度改变至鼠标点击的位置。
		var sliderBarContainerTr = document.getElementById("sliderBarContainerTrID");
		this.sliderBarContainerTr = sliderBarContainerTr;
        this.sliderBarContainerTr.onclick = OpenLayers.Function.bind(this.onCilckSliderBarContainerTr, this);
        this.sliderBarContainerTr.onmousemove = OpenLayers.Function.bind(this.onMousemoveSliderBarContainerTr, this);
    },
    
    /**
     * Method: onCilckSliderBarContainerTr
     * 鼠标移动至进度条上时，显示该位置的时间点。
     */
    onMousemoveSliderBarContainerTr: function(){
        //火狐事件对象event为arguments[0]。IE和chrome的事件对象则全局存在event。
        var eventObj = arguments[0] || event;
        //火狐:target存在。IE:srcElement存在。chrome:target和srcElement都存在。
        var srcElement = eventObj.target || eventObj.srcElement;
        if (srcElement.id == "sliderFocusNode") {
            return;
        }
        //火狐:layerX存在。IE:offsetX存在。chrome:offsetX存在。
        var offsetX = (eventObj.offsetX != undefined) ? eventObj.offsetX : eventObj.layerX;
        var newWidthPX = offsetX;
        if (newWidthPX < 0) {
            newWidthPX = 0;
        }
        if (srcElement.className == "") {
            return;
        }
        if (srcElement.className == "sliderBarContainerPanelLeft") {
            newWidthPX = 0;
        }
        if (srcElement.className == "sliderBarContainerPanelRight") {
            newWidthPX = this.remainingBar.clientWidth;
        }
        //所占的格子数
        var currentMark = Math.floor((newWidthPX / this.remainingBar.clientWidth) * this.markNum);
        if (this.markInfo) {
            this.sliderBarContainerTr.title = this.markInfo[currentMark];
        }
	},
    
    /**
     * Method: onCilckSliderBarContainerTr
     * 鼠标点击进度条上时，进度改变至鼠标点击的位置。
     */
    onCilckSliderBarContainerTr: function(){
        //火狐事件对象event为arguments[0]。IE和chrome的事件对象则全局存在event。
        var eventObj = arguments[0] || event;
        //火狐:target存在。IE:srcElement存在。chrome:target和srcElement都存在。
        var srcElement = eventObj.target || eventObj.srcElement;
        if (srcElement.id == "sliderFocusNode") {
            return;
        }
        //火狐:layerX存在。IE:offsetX存在。chrome:offsetX存在。
        var offsetX = (eventObj.offsetX != undefined) ? eventObj.offsetX : eventObj.layerX;
        var newWidthPX = offsetX;
        if (newWidthPX < 0) {
            newWidthPX = 0;
        }
		if(srcElement.className == ""){
			return;
		}
        if (srcElement.className == "sliderBarContainerPanelLeft") {
            newWidthPX = 0;
        }
        if (srcElement.className == "sliderBarContainerPanelRight") {
            newWidthPX = this.remainingBar.clientWidth;
        }
        //所占的格子数
        this.currentMark = Math.floor((newWidthPX / this.remainingBar.clientWidth) * this.markNum);
        //长度的最终百分比值  = 所占的份数 * 每份的百分比 
        var percentValueWidth = this.currentMark / this.markNum * 100;
        this.progressBar.style.width = percentValueWidth + "%";
        //同步this.tmpNewWidthPX存储进度条长度，防止拖动时错位的问题。
        this.tmpNewWidthPX = this.progressBar.clientWidth;
        //防止点击至起点或终点时，拖动错位的问题。
        this.progressBarPX = null;
		this.onSliderBarMove();
		this.setSliderBarTitle();
    },
    
    /**
     * Method: sliderBarDown
     * 鼠标光标在进度条指针上按下时，触发该方法。
     *
     * Parameters:
     * evt - {<Geo.Event>} 事件对象。
     */
    sliderBarDown: function(evt){
        if (!OpenLayers.Event.isLeftClick(evt) && !OpenLayers.Event.isSingleTouch(evt)) {
            return;
        }
        this.map.events.on({
            "touchmove": this.passEventToSlider,
            "mousemove": this.passEventToSlider,
            "mouseup": this.passEventToSlider,
            scope: this
        });
        this.documentEvents.on({
            "touchmove": this.passEventToSlider,
            "mousemove": this.passEventToSlider,
            "mouseup": this.passEventToSlider,
            scope: this
        });
		//鼠标光标居中于进程条上的按钮的偏移像素值
        var middleDelta = 0;
		
		var offsetX = (evt.offsetX != undefined) ? evt.offsetX : evt.layerX;
        if (offsetX >= 0 && offsetX <= 18) {
            middleDelta = offsetX - this.sliderBar.clientWidth / 2;
        }
        //鼠标起始坐标X
        this.mouseDragStart = evt.clientX - middleDelta;
        OpenLayers.Event.stop(evt);
    },
	
    /**
     * Method: sliderBarDrag
     * 鼠标光标在进度条指针上按下并拖动时，触发该方法。
     *
     * Parameters:
     * evt - {<Geo.Event>} 事件对象。
     */
    sliderBarDrag: function(evt){
        if (this.mouseDragStart != null) {
            
            //鼠标实际偏移像素值//screenX
            var deltaX = evt.clientX - this.mouseDragStart;
			
            //----------------------------------------------------------------------
			if(this.tmpNewWidthPX != null){
				this.tmpNewWidthPX += deltaX;
			}else{
				this.tmpNewWidthPX = this.progressBar.clientWidth + deltaX;
			}
            
            if (this.tmpNewWidthPX >= 0 && this.tmpNewWidthPX <= this.remainingBar.clientWidth) {
                //this.tmpNewWidthPX += deltaX;
            }
            else 
                if (this.tmpNewWidthPX < 0) {
                    this.tmpNewWidthPX = 0;
                }
                else 
                    if (this.tmpNewWidthPX > this.remainingBar.clientWidth) {
                        this.tmpNewWidthPX = this.remainingBar.clientWidth;
                    }
			//----------------------------------------------------------------------
			//每格子
			var OneMarkNum = (1 / this.markNum);
			//所占的格子数
			this.currentMark = Math.floor((this.tmpNewWidthPX / this.remainingBar.clientWidth) * this.markNum);
			//长度的最终百分比值  = 所占的份数 * 每份的百分比 
			var percentValueWidth = this.currentMark / this.markNum * 100;
			
			if (this.tmpNewWidthPX > 0 && this.tmpNewWidthPX < this.remainingBar.clientWidth) {
				//精确的进程像素长度
				this.progressBarPX = this.tmpNewWidthPX;
				//有误差的进程百分比长度
				this.progressBar.style.width = percentValueWidth + "%";
				this.mouseDragStart = evt.clientX;
			}else if(this.tmpNewWidthPX == 0){
				if(this.progressBarPX != null){
					this.mouseDragStart = this.mouseDragStart - this.progressBarPX;
				}
				//精确的进程像素长度
				this.progressBarPX = 0;
				this.progressBar.style.width = "0%";
			}else if(this.tmpNewWidthPX == this.remainingBar.clientWidth){
				//alert(this.remainingBar.clientWidth);
				if (this.progressBarPX != null) {
					this.mouseDragStart = this.mouseDragStart - this.progressBarPX + this.remainingBar.clientWidth;
				}
				//精确的进程像素长度
				this.progressBarPX = this.remainingBar.clientWidth;
				this.progressBar.style.width = "100%";
			}
			this.setSliderBarTitle();
        }
    },
    
    /**
     * Method: sliderBarUp
     * 鼠标光标在进度条指针上按下或按下拖动后抬起时，触发该方法。
     *
     * Parameters:
     * evt - {<Geo.Event>} 事件对象。
     */
    sliderBarUp: function(evt){
        if (!OpenLayers.Event.isLeftClick(evt) && evt.type !== "touchend") {
            return;
        }
		
		var srcElement = evt.target || evt.srcElement;
		if(srcElement.id != "sliderFocusNode"){
			this.sliderBar.className = "sliderImage";
			this.sliderBarContainerTable.className = "timeSliderTable sliderBarContainerTable";
		}
		
        if (this.mouseDragStart) {
            this.map.events.un({
                "touchmove": this.passEventToSlider,
                "mouseup": this.passEventToSlider,
                "mousemove": this.passEventToSlider,
                scope: this
            });
            this.documentEvents.un({
                "touchmove": this.passEventToSlider,
                "mouseup": this.passEventToSlider,
                "mousemove": this.passEventToSlider,
                scope: this
            });
            this.mouseDragStart = null;
            OpenLayers.Event.stop(evt);
        }
		
		this.onSliderBarMove();
    },
	
    /**
     * Method: passEventToSlider
     * 传递事件至进度条指针。
     *
     * Parameters:
     * evt - {<Geo.Event>} 事件对象。
     */
    passEventToSlider: function(evt) {
        this.sliderEvents.handleBrowserEvent(evt);
    },
	
    /**
     * APIMethod: play
     * 播放。
     */
    play: function(){
		if (this.interval <= 0) {
			return;
		}
		this.timerId && clearInterval(this.timerId);
		//播放时，按钮设置为暂停图标
		this.playButton.children[0].className = "sliderButtonNodeIcon pauseButton sliderInline";
		this.prevButton.className = "sliderButtonNode sliderInline sliderButtonDisabled";
		this.nextButton.className = "sliderButtonNode sliderInline sliderButtonDisabled";
		
        var timerCallback = function(){
            if (this.currentMark >= this.markNum) {
				//暂停
                this.pause();
                return;
            }
			//前进一个刻度
			this.setProgressBarWidth(1);
        };
		this.timerId = window.setInterval(OpenLayers.Function.bind(timerCallback, this), this.interval);
    },
	
    /**
     * APIMethod: pause
     * 暂停。
     */
	pause: function(){
		clearInterval(this.timerId);
		this.timerId = null;
		//停止播放时，按钮设置为播放图标
		this.playButton.children[0].className = "sliderButtonNodeIcon playButton sliderInline";
		this.prevButton.className = "sliderButtonNode sliderInline";
		this.nextButton.className = "sliderButtonNode sliderInline";
	},
	
    /**
     * APIMethod: previous
     * 后退。
     */
	previous: function(){
		this.setProgressBarWidth(-1);
	},
	
    /**
     * APIMethod: next
     * 前进。
     */
	next: function(){
		this.setProgressBarWidth(1);
	},
	
    /**
     * APIMethod: setCurrentMark
     * 设置当前进度条需指向的时间点索引。
     * 
     * Parameters:
     * currentMark - {Number} 当前进度条需指向的时间点索引。
     */
	setCurrentMark: function(currentMark){
		this.currentMark = currentMark;
		this.setProgressBarWidth();
	},
	
    /**
     * Method: setProgressBarWidth
     * 根据偏移刻度值设置进度条长度。
     * 
     * Parameters:
     * delta - {Number} 偏移刻度值。
     */
	setProgressBarWidth: function(delta){
		if(!delta){
			delta = 0;
		}
		var cm = this.currentMark + delta;
		if (cm > this.markNum || cm < 0) {
			return;
		}
		this.currentMark += delta;
		var percentValueWidth = this.currentMark / this.markNum * 100;
		this.progressBar.style.width = percentValueWidth + "%";
		//同步this.tmpNewWidthPX存储进度条长度，防止拖动时错位的问题。
		this.tmpNewWidthPX = this.progressBar.clientWidth;
		this.onSliderBarMove();
		this.setSliderBarTitle();
	},
	
    /**
     * Method: _setRuleMarksHTML
     * 在进度条下填充刻度线。
     */
	_setRuleMarksHTML: function(){
        var html = '';
		this.textArr = new Array();
        for (var i = 0; i <= this.markNum; i += 1) {
            var percentValue = i / this.markNum * 100;
			var title = "";
			if (this.markInfo) {
				title = this.markInfo[i];
			}
            html += '<div class="ruleMark" style="left:' + percentValue + '%" title="' + title +'"></div>';
        }
		document.getElementById("ruleContainer").innerHTML = html;
	},
	
    /**
     * Method: setSliderBarTitle
     * 设置指针标题。
     */
	setSliderBarTitle: function(){
		if (!this.markInfo) {
			this.sliderMoveableInfoDIV.style.display = "none";
			return;
		}
		this.sliderMoveableInfoDIV.innerHTML = this.markInfo[this.currentMark];
		var num = this.sliderMoveableInfoDIV.innerHTML.length;
		//每个字的宽度。
		var wordWidth = 9;
		this.sliderMoveableInfoDIV.style.width = num * wordWidth + "px";
		this.sliderMoveableInfoDIV.style.left = -(num * wordWidth / 2 - 6) + "px";
		this.sliderMoveableInfoDIV.style.display = "block";
	},
	
    /**
     * APIMethod: setMarkInfo
     * 设置时间点数组。
     * 
     * Parameters:
     * markInfo - {Array(String)} 偏移刻度值。
     */
	setMarkInfo: function(markInfo){
		this.markInfo = markInfo;
	},
	
    /**
     * Method: _removeSliderEvents
     * 移除进度条指针事件监听。
     */
    _removeSliderEvents: function(){
        this.sliderEvents.un({
            "mousedown": this.sliderBarDown,
            "mousemove": this.sliderBarDrag,
            "mouseup": this.sliderBarUp
        });
        this.sliderEvents.destroy();
    },
	
    /**
     * APIMethod: destroy
     * 销毁该对象。
     */
    destroy: function(){
        this._removeSliderEvents();
        
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
        
        delete this.mouseDragStart;
    },
	
    CLASS_NAME: "Geo.View2D.Control.TimeSlider"
});
Geo.View2D.Control.TimeSlider.timeSliderDivHTML = '' +
	'<table width="100%" class="timeSliderTable" style="margin-left:5px;">' +
		'<tbody>' +
			'<tr>' +
				'<td align="right">' +
					'<div id="buttonLeftPanel">' +
						'<span class="sliderButtonNode sliderInline" id="playButton">' +
							'<span class="sliderButtonNodeIcon playButton sliderInline"></span>' +
						'</span>' +
					'</div>' +
				'</td>' +
					'<!-- 刻度条容器面板-->' +
				'<td width="80%" align="center">' +
					'<table class="timeSliderTable sliderBarContainerTable" id="sliderBarContainerTableID" >' +
		        		'<tbody>' +
		        			'<tr id="sliderBarContainerTrID">' +
		        				'<!-- 刻度条容器左侧封闭-->' +
		        				'<td><div class="sliderBarContainerPanelLeft"></div></td>' +
		        				'<td width="100%"><div id="sliderBarContainerPanel">' +
										'<!-- 刻度条容器-->' +
										'<div id="sliderBarContainer">' +
											'<!-- 已播放的进程条 -->' +
											'<div id="progressBar" class="sliderBarC">' +
												'<!-- 隐藏的 -->' +
												'<div id="sliderMoveable">' +
												'<!-- 显示当前时间信息的DIV -->' +
												'<div id="sliderMoveableInfo"></div>' +
													'<!-- 指针 -->' +
													'<div class="sliderImage" id="sliderFocusNode">' +
													'</div>' +
												'</div>' +
											'</div>' +
											'<div id="remainingBar" class="sliderBarC">' +
											'</div>' +
										'</div>' +
									'</div>' +
								'</td>' +
		        				'<td><div class="sliderBarContainerPanelRight"></div></td>' +
							'</tr>' +
							'<tr>' +
								'<td></td>' +
								'<td width="100%">' +
									'<div id="ruleContainer">' +
										'<div class="ruleMark" style="left:0%"></div>' +
									'</div>' +
								'</td>' +
								'<td></td>' +
							'</tr>' +
						'</tbody>' +
					'</table>' +
				'</td>' +
				'<td width=30>' +
					'<span class="sliderButtonNode sliderInline" id="prevButton">' +
						'<span class="sliderButtonNodeIcon prevButton sliderInline"></span>' +
					'</span>' +
				'</td>' +
				'<td align="left">' +
					'<div id="buttonRightPanel">' +
						'<span class="sliderButtonNode sliderInline" id="nextButton">' +
							'<span class="sliderButtonNodeIcon nextButton sliderInline"></span>' +
						'</span>' +
					'</div>' +
				'</td>' +
			'</tr>' +
		'</tbody>' +
	'</table>';﻿/**
 * Class: Geo.View2D.Control.PrintMap
 * 打印控件类，控件为可视控件类型。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.PrintMap = Geo.Class(Geo.View2D.Control, {
	/**
     * APIProperty: titleName
     * {String} 打印预览页面title标签元素内显示的名称。
     */
    titleName: "地图打印",
	
    /**
     * APIProperty: headerName
     * {String} 打印预览页面显示的打印名称。
     */
    headerName: "地图",
	
	/**
     * APIProperty: containerWidth
     * {String} 打印地图容器的宽度，默认值为1024。
     */
	containerWidth: "1024",
	
	/**
     * APIProperty: containerHeight
     * {String} 打印地图容器的高度，默认值为768。
     */
	containerHeight: "768",
	
	/**
     * APIProperty: printImgSrc
     * {String} 打印按钮的背景图片地址。
     */
	printImgSrc: "",
	/**
     * Constructor: Geo.View2D.Control.PrintMap
     * 创建打印控件对象实例。
     *
     * Parameters:
     * options - {Object} 对象构造参数。
     */
    initialize: function(options){
        OpenLayers.Control.prototype.initialize.apply(this, arguments);
	},
	
    /** 
     * Method: setMap
     * 该控件与地图对象关联。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map){
        Geo.View2D.Control.prototype.setMap.apply(this, arguments);
    },
    
	/**
     * APIMethod: createPrintMap
     * 显示打印预览页面，打印地图操作。
     * 
     * Parameters:
     * id - {String} 地图容器的id值。 
     */
	createPrintMap: function(id){
		var size = map.getSize();
		if(this.containerWidth > size.w){
			alert("打印地图容器宽度超过了地图的宽度，请重新设置打印地图容器宽度。");
			return;
		}
		if(this.containerHeight > size.h){
			alert("打印地图容器高度超过了地图的高度，请重新设置打印地图容器高度。");
			return;
		}
		/*
		if(OpenLayers.BROWSER_NAME == 'msie'){
			var arVersion = navigator.appVersion.split("MSIE");
        	var version = parseFloat(arVersion[1]);
			if(parseInt(version) < 9){
				alert("控件不支持在IE9以下版本的浏览器中运行!");
				return;
			}
		}
		*/
		var printWindow = window.open("");
		var strInnerHTML = document.getElementById(id).innerHTML;
		var strHeader = "<!DOCTYPE html><html><head><META HTTP-EQUIV='pragma' CONTENT='no-cache'><META HTTP-EQUIV='Cache-Control' CONTENT='no-cache, must-revalidate'><META HTTP-EQUIV='expires' CONTENT='Wed, 26 Feb 1997 08:21:57 GMT'><meta http-equiv='Content-Type' content='text/html; charset=utf-8' /><meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' /><meta name='apple-mobile-web-app-capable' content='yes' /><title>"+this.titleName+"</title>";
//		var strCSS = "<link href='../../css/demoComm.css' rel='stylesheet' /><link href='../../../css/print.css' rel='stylesheet' />";
		var height = parseInt(this.containerHeight)-10;
		var strCSS = '';
		var printButton = "";
		strCSS = strCSS + '<style type="text/css">';
		strCSS = strCSS + '.olImageLoadError{background-color: pink; opacity: 0!important; filter: alpha(opacity=0)!important;}';
		strCSS = strCSS + '.print-container {margin: auto;width:'+this.containerWidth+'px;height:'+this.containerHeight+'px;top: 50px;position: relative;}';
		strCSS = strCSS + '.geoD {width: 100%;height: 24px;line-height: 24px;border-bottom: 3px solid #B2B2B2;font-size: 14px;margin-bottom: 6px;}';
		strCSS = strCSS + '#'+ id + '{position: relative;height:'+ height +'px;margin-bottom: 15px;clear: both;}';
		strCSS = strCSS + '#geoft {content: ".";height: 77px;display: block;overflow: hidden;clear: both;}';
		strCSS = strCSS + '.printMap {margin-bottom: 20px;float: right;}';
		if(this.printImgSrc != undefined && this.printImgSrc != ""){
			strCSS = strCSS + '.printMap span {background-position: 0px 0px;cursor: pointer;margin-right: 0px;margin-top: 5px;display: inline-block;width: 69px;height: 29px;background-image: url('+this.printImgSrc+');}';
			printButton = "<span id='printMap' onclick = 'printDiv()'></span>";
		}else {
			printButton = "<input id='printMap' type='button' value='打印' onclick = 'printDiv()'></input>";
		}
		strCSS = strCSS + '</style>';
		var strScript = "<script type = 'text/javascript'>" + "\n" + "function printDiv(){var divObj = document.getElementById('printMap');divObj.style.display = 'none';window.print();divObj.style.display = 'block';}<\/script>";
		var strBody = "</head><body><div class='print-container'><div class='geoD'><h3>"+this.headerName+"</h3></div><div id='"+id+"' >" +strInnerHTML + "</div><div id='geoft'><div class='printMap'>"
		strBody = strBody + printButton;
		strBody = strBody + "</div></div></div></body></html>";
        var strHTML = strHeader + strCSS + strScript + strBody;
		printWindow.document.write(strHTML);
		printWindow.document.close();
	},
			
    /**
     * APIMethod: destroy
     * 销毁该对象。
     */
    destroy: function(){
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
    },
	
    CLASS_NAME: "Geo.View2D.Control.PrintMap"
});/**
 * Class: Geo.View2D.MenuItem
 * 鼠标右键地图菜单选项类。
 */
Geo.View2D.MenuItem = Geo.Class({

    /**
     * APIProperty: text
     * {String} 菜单项显示的文本。
     */
    text: null,

    /**
     * APIProperty: callback
     * {Function} 回调函数。
     */
    callback: null,

    /**
     * APIProperty: width
     * {String} 菜单项长度。默认值为100px。
     */
	width: 100,
	
    /**
     * Constructor: Geo.View2D.MenuItem
     * 鼠标右键地图菜单选项的构造函数。
     * 
     * Parameters:
     * options - {Object} 构造参数选项。
     */
    initialize: function(options){
		OpenLayers.Util.extend(this, options);
    },
	
	
    /**
     * APIMethod: setText
     * 设置菜单项显示的文本。
     *
     * Parameters:
     * text - {String} 菜单项显示的文本。
     */
	setText: function(text){
		this.text = text;
	},
	
    CLASS_NAME: "Geo.View2D.MenuItem"
});
/**
 * Class: Geo.View2D.TemporalRenderer
 * 本类是一个能展现不同时间段内数据实时走向的动画渲染类，展现的应用场景包括，地震，台风等。
 */
Geo.View2D.TemporalRenderer = Geo.Class({
    
	/**
	 * APIProperty: classId
	 * {String} 要素分类ID。
	 */
	classId: "EVENTID",
	
	/**
	 * 队列对象。
	 */
	hash: {},
	
	//动画队列
    _queue:null,
	
	/**
	 * 是否停止行走
	 */
	isStop: null,
	
	/**
	 * Property: frequence
	 * 移动频率，默认值为1秒
	 */
	frequence: 1000,
	
	/**
	 * Property: trackStyle
	 * 线的样式。
	 */
	trackStyle: null,
	
	/**
	 * Property: sourceProjection
	 * 源投影
	 */
	sourceProjection:null,
	
	/**
	 * Property: destProjection
	 * 目标投影
	 */
	destProjection: null,
	
	/**
	 * Property: latestStyle
	 */
	latestStyle: null,
	
	/**
	 * Property: dateTimes
	 */
	dateTimes: [],
	
	/**
	 * Property: currentTime
	 */
	currentTime: null,
	
	/**
	 * Property: ispause
	 * 是否暂停
	 */
	ispause: null,
	
    /**
     * Constructor: Geo.View2D.TemporalRenderer
     * 构造函数。矢量要素动画类实例。
     *
     * Parameters:
     * options - {Object} 对象相关选项设置。
     */
    initialize: function(options) {
        this.id = OpenLayers.Util.createUniqueID("Geo.TemporalRenderer_");
		OpenLayers.Util.extend(this, options);
		this._queue = {};
    },
	
	/**
	 * APIMethod: setFeatures
	 * 设置要素。方法中的features参数值是通过地图服务查询接口获取的。
	 * 
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)}  
	 */
	setFeatures: function(features){
		if(Geo.Util.isArray(features)) {
			for(var i = 0; i < features.length; i++) {
				var classId = features[i].attributes[this.classId];
				if(!Geo.Util.isArray(this.hash[classId])) {
					this.hash[classId] = [];
				}
				//分类保存要素
				this.hash[classId].push(features[i].clone());
				//设置时间轴数据
				this.setDateTimes(features[i].attributes["Date_Time"]);
				this.setCurrentTime(this.dateTimes[0]);
				this.dateTimes = this.getUniqueArray(this.dateTimes);
			}
		}
		this.cacheFeatures(this.hash);
	},
	
	/**
	 * APIMethod: getDateTimes
	 * 获取时间戳数组。说明：先调用setFeatures方法设置要素数组，然后调用本方法获取dateTimes数组。
	 * 
	 * Returns:
	 * {Array(<Integer>)} 时间戳数组。
	 */
	getDateTimes: function() {
		return this.dateTimes;
	},
	
	/**
	 * Method: sortNumber
	 */
	sortNumber: function(a, b) {
		return a - b
	},
	
	/**
	 * Method: getUniqueArray
	 */
	getUniqueArray: function(data){
		data = data || []; 
		var a = {}; 
		len = data.length; 
		for (var i=0; i<len;i++){ 
		var v = data[i]; 
		if (typeof(a[v]) == 'undefined'){ 
		a[v] = 1; 
		} 
		}; 
		data.length=0; 
		for (var i in a){ 
		data[data.length] = i; 
		} 
		return data; 
	},
	
	/**
	 * Method: setDateTimes
	 */
	setDateTimes: function(dateTime) {
		this.dateTimes.push(dateTime);
		//按照升序排序
		this.dateTimes.sort(this.sortNumber);
	},
	
	/**
	 * Method: setDateTime
	 */
	setDateTime: function() {
		
	},
	
	/**
	 * Method: cacheFeatures
	 * 初始化缓存
	 */
	cacheFeatures: function(hash) {
		for(var fs in hash) {
			var features = hash[fs];
			this._queue[fs] = this._getQueueItem();
			this.recordFeatures(features,this._queue[fs]);
		};
	},
	
	/**
	 * APIMethod: setMap
	 * 与地图关联
	 */
	setMap: function(map) {
		if(map && !this.map){
			this.map = map;
			
			//添加结果图层
//			this.vectorLayer = new OpenLayers.Layer.Vector("GeoGlobeRendererVector", {
//			//	styleMap: this.styleMap,
//				isOnTop: true,
//				displayInLayerSwitcher: false,
//				//要素的显示级别设置为开启状态，默认为false
//				rendererOptions: {zIndexing: true}
//			});
			this.vectorLayer = new OpenLayers.Layer.Vector();
			map.addLayer(this.vectorLayer);
		}
	},
	
	/**
	 * APIMethod: locateTime
	 * 定位到某个时间点
	 */
    locateTime: function(dateTime) {
		//绘制各个要素组合
		var hash = this.hash;
		this.vectorLayer.removeAllFeatures();
		for(var fs in hash) {
			var item = this._queue[fs];
			var dateTimes = item.dateTimes;
			if(dateTime < dateTimes[0]) {
				continue;
			}
			for(var i = 0; i < dateTimes.length - 1; i++) {
				if(dateTime >= dateTimes[i] && dateTime < dateTimes[i + 1] ) {
					this.vectorLayer.addFeatures(item.record[dateTimes[i]]);
				}else if(dateTime >= dateTimes[dateTimes.length - 1]) {
					this.vectorLayer.addFeatures(item.record[dateTimes[dateTimes.length - 1]]);
				//	window.clearInterval(item.interval);
				}
			}
		};
	},
	
	/**
	 * Method: fallback
	 * 后退
	 */
	fallback: function(dateTime) {
		if(this.counter > 0) {
			this.currentTime = this.dateTimes[this.counter - 1];
			this.locateTime(this.currentTime);
		}
	},
	
	/**
	 * Method: goAlong
	 * 前进
	 */
	goAlong: function(currentTime) {
		if(this.counter < this.dateTimes.length - 1) {
			this.currentTime = this.dateTimes[this.counter + 1];
			this.locateTime(this.currentTime);
		}
	},
	
	/**
	 * Method: pause
	 * 暂停
	 */
	pause: function() {
		var hash = this.hash;
		for(var fs in hash) {
			var item = this._queue[fs];
        	window.clearInterval(item.interval);
		};
		window.clearInterval(this.interval);
	},
	
	/**
	 * Method:recordFeatures
	 *  初始化缓存数据
	 */
	recordFeatures: function(features,item) {
		//逐个绘制要素
		//将要素记录在备忘录中
		for(var i = 0; i < features.length - 1; i++) {
			if(i === 0) {
				//TODO
		//		features[i].geometry = features[i].geometry.transform(new Geo.Projection("EPSG:4326"),new Geo.Projection("EPSG:4326"));
				var style = OpenLayers.Util.extend({ pointRadius: 3}, OpenLayers.Feature.Vector.style["default"]);
				style.pointRadius = 4;
				features[i].style = style;
				//TODO
				item.record[features[i].attributes["Date_Time"]] = [features[i]];
				item.dateTimes.push(features[i].attributes["Date_Time"]);
				
			}else {
				var pointGeometryArray = [];
				var pointFeatures = [];
				for(var j = 0; j <= i; j++) {
					//TODO
		//			features[j].geometry = features[j].geometry.transform(new Geo.Projection("EPSG:4326"),new Geo.Projection("EPSG:4326"));
					pointGeometryArray.push(features[j].geometry.clone());
					var style = OpenLayers.Util.extend({ pointRadius: 2}, OpenLayers.Feature.Vector.style["default"]);
					style.pointRadius = 4;
					features[j].style = style;
					pointFeatures.push(features[j]);
				}
				var tempLine = new Geo.Feature.Vector(new Geo.Geometry.LineString(pointGeometryArray));
				//TODO
		//		features[i].geometry = features[i].geometry.transform(new Geo.Projection("EPSG:4326"),new Geo.Projection("EPSG:4326"));
				//TODO
				item.record[features[i].attributes["Date_Time"]] = pointFeatures.concat(tempLine);
				item.dateTimes.push(features[i].attributes["Date_Time"]);
			}
		}
	},
	
	/**
	 * Method: setCurrentTime
	 * 设置当前时间
	 */
	setCurrentTime: function(currentTime) {
		this.currentTime = currentTime;
	},
	
	/**
	 * Method: getCurrentTime
	 * 设置当前时间
	 */
	getCurrentTime: function() {
		return this.currentTime;
	},
	
	/**
	 * Method: drawFeatures
	 * 绘制数据
	 */
	drawFeatures: function(item) {
		var hash = this.hash;
		for (var fs in hash) {
			var item = this._queue[fs];
			this.currentTime = this.getCurrentTime();
			//绘制以时间为导向
			for(var i = 0; i < item.dateTimes.length - 1; i++) {
				if(this.currentTime >= item.dateTimes[i] && this.currentTime < item.dateTimes[i + 1] ) {
					this.vectorLayer.addFeatures(item.record[item.dateTimes[i]]);
				}else if(this.currentTime >= item.dateTimes[item.dateTimes.length - 1]) {
					this.vectorLayer.addFeatures(item.record[item.dateTimes[item.dateTimes.length - 1]]);
					window.clearInterval(item.interval);
				}
			}
		}
	},
	
	/**
	 * Method: _getQueueItem
	 */
	_getQueueItem: function() {
        return {
            counter: 0,
            isStop: false,
			record: {},
			dateTimes:[],
            interval: null,
            options: {}
        };
    },
	
	//TODO：测试属性
	counter: 0,
	
//	//TODO：此方法为测试方法，以后会去掉
//	startTimeZhou: function() {
//		var fn = Geo.Function.bind(function() {
//			this.currentTime = this.dateTimes[this.counter];
//			this.counter++;
//			if(this.dateTimes.length -1 < this.counter) {
//				window.clearInterval(this.interval);
//				this.counter = 0;
//			}
//		},this);
//		this.interval = window.setInterval(fn, this.frequence + 500);
//	},
	
	/**
	 * Method: stop
	 * 停止
	 */
	stop: function() {
		this.isStop = true;
		var hash = this.hash;
		for(var fs in hash) {
			var item = this._queue[fs];
        	window.clearInterval(item.interval);
		};
		window.clearInterval(this.interval);
		this.currentTime = this.dateTimes[0];
		this.counter = 0;
	},
	
	/**
	 * Method: start
	 * 开始
	 */
	start: function() {
		var hash = this.hash;
		var i = 0;
		//如果是停止状态就清除之前的元素，只有在执行停止操作后属性才为true
		if(this.isStop === true) {
			this.vectorLayer.removeAllFeatures();
		}
		this.isStop = false;
//		this.startTimeZhou();
	
		var fn1 = Geo.Function.bind(function(fs) {
			var fn = Geo.Function.bind(function() {
				this.drawFeatures();
			},this);
			this._queue.interval = window.setInterval(fn, this.frequence);
        },this);
		fn1();
	},
	
    CLASS_NAME: "Geo.View2D.TemporalRenderer"
});

/**
 * 用来给要素设置样式
 */
Geo.View2D.TemporalRenderer.HashStyle = Geo.Class({
	
	data: [],
	
 	/**
     * Constructor: Geo.View2D.TemporalRenderer.HashStyle
     *
     * Parameters:
     * options - {Object} 对象相关选项设置。
     */
    initialize: function(options) {
        this.id = OpenLayers.Util.createUniqueID("Geo.TemporalRenderer.HashStyle_");
    },
	
	put: function(key, value) {
        this.data[key] = value;
    },
			
	get: function(key) {
        return this.data[key];
    },
	
	remove: function(key) {
        this.data[key] = null;
    },
	
	isEmpty: function() {
        return this.data.length == 0;
    },
	
	size: function() {
        return this.data.length;
    },
	
	CLASS_NAME: "Geo.View2D.TemporalRenderer.HashStyle"
});/**
 * Class: Geo.View2D.Layer.DynamicMapService
 * rest服务的动态地图图层类。继承自Geo.View2D.Layer.Grid类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 本图层用于展示rest服务的动态地图服务提供的瓦片数据。
 * 本图层支持的服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Grid>
 */
Geo.View2D.Layer.DynamicMapService = Geo.Class(Geo.View2D.Layer.Grid, {

    /**
     * Constant: DEFAULT_PARAMS
     * {Object} 键值对对象。为参数设置默认值
     */
    DEFAULT_PARAMS: {
      format: "png"
    },
        
    /**
     * APIProperty: isBaseLayer
     * {Boolean} 是否为基础图层
     */
    isBaseLayer: true,
	
	/**
	 *  APIProperty: layers
	 * 确定哪些图层在导出图像上出现。可以通过四种方式指定图层显示。
	 * 
	 * 参数如下：
	 *	show: 仅导出列表中指定的图层。 
	 *	hide: 导出列表指定图层以外的所有图层。 
	 *	include: 除了以默认方式导出图层以外, 列表中指定的图层也会被导出。 
	 *	exclude:没有在这个列表中指定的,以默认方式导出的图层将会被导出。
	 *	示例: layers=show:2,4,7
     *
	 */
	layers:null,
	
	/**
	 * APIProperty: time
	 * {Object} 请求指定时间段内的瓦片。默认可不填
		取值举例：
		timeExtent： {
			startTime:new Date("6/1/2013"),
			endTime:new Date("6/1/2003")
		}
	 */
	timeExtent:null,
	
	/**
	 * APIProperty: layerDefs
	 * 允许你通过定义图层的表达式来过滤单个图层的要素。 
     *
	 *	语法: layerId1:layerDef1;layerId2:layerDef2
	 *	layerId1, layerId2 是地图服务资源返回的图层ID 
	 *	
	 *	示例: 0:POP2000 > 1000000;5:AREA > 100000
	 */
	layerDefs: null,
	
    /**
     * Constructor: Geo.View2D.Layer.DynamicMapService
     * 创建一个动态地图图层
     *
     * Parameters：
     * name - {String} 图层名称
     * url - {String} 动态地图服务地址
     * params - {object}
     * 		format - {String}瓦片格式
     * 		transparent - {Boolean} 透明度
     *      layers: {String} 确定哪些图层在导出图像上出现。
     * 		time - {String} 指定请问时间范围内的瓦片，比如：time:"2013-05-16,2013-05-16"
     * 		gdbVersion - {String} 地图的数据版本，在10.1版本后支持     
     * Example:
     * (code)
     * var arcims = new Geo.View2D.Layer.DynamicMapService("MyName",
     * "http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer", 
     * {
     *    layers: "0,1,2"
     * }
     * );
     * (end)
     * 	
     */
    initialize: function(name, url, params, options) {
		var location = url.indexOf("/",url.length - 1);
		if(location != -1) {
			url = url + "export";
		}else {
			url = url + "/" + "export";
		}
        var newArguments = [];
        //uppercase params
        params = OpenLayers.Util.upperCaseObject(params);
        newArguments.push(name, url, params, options);
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, newArguments);
        OpenLayers.Util.applyDefaults(
                       this.params, 
                       OpenLayers.Util.upperCaseObject(this.DEFAULT_PARAMS)
                       );
                       
        //layer is transparent        
        if (this.params.TRANSPARENT && 
            this.params.TRANSPARENT.toString().toLowerCase() == "true") {
            
            // unless explicitly set in options, make layer an overlay
            if ( (options == null) || (!options.isBaseLayer) ) {
                this.isBaseLayer = false;
            } 
            
            // jpegs can never be transparent, so intelligently switch the 
            //  format, depending on the browser's capabilities
            if (this.params.FORMAT == "jpg") {
                this.params.FORMAT = OpenLayers.Util.alphaHack() ? "gif"
                                                                 : "png";
            }
        }
		
		if(this.params.TIMEEXTENT) {
			if(this.params.TIMEEXTENT.startTime instanceof Date && this.params.TIMEEXTENT.endTime instanceof Date) {
				var startTime = Date.parse(this.params.TIMEEXTENT.startTime);
				var endTime = Date.parse(this.params.TIMEEXTENT.endTime);
				this.params.TIME = startTime + "," + endTime;
				delete this.params.TIMEEXTENT;
			}
		}
    },    

    
    /**
     * Method: destroy
     * Destroy this layer
     */
    destroy: function() {
        // for now, nothing special to do here. 
        OpenLayers.Layer.Grid.prototype.destroy.apply(this, arguments);  
    },   
    
    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Returns:
     * {<Geo.View2D.Layer.DynamicMapService>} An exact clone of this layer
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new Geo.View2D.Layer.DynamicMapService(this.name,
                                           this.url,
                                           this.params,
                                           this.getOptions());
        }

        //get all additions from superclasses
        obj = OpenLayers.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },
    
    /**
     * Method: getURL
     * Return an image url this layer.
     *
     * Parameters:
     * bounds - {<OpenLayers.Bounds>} A bounds representing the bbox for the
     *                                request.
     *
     * Returns:
     * {String} A string with the map image's url.
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);

        // ArcGIS Server only wants the numeric portion of the projection ID.
        var projWords = this.projection.getCode().split(":");
        var srid = projWords[projWords.length - 1];

        var imageSize = this.getImageSize(); 
        var newParams = {
            'BBOX': bounds.toBBOX(),
            'SIZE': imageSize.w + "," + imageSize.h,
            // We always want image, the other options were json, image with a whole lotta html around it, etc.
            'F': "image",
            'BBOXSR': srid,
            'IMAGESR': srid
        };

        // Now add the filter parameters.
        if (this.layerDefs) {
            var layerDefStrList = [];
            var layerID;
            for(layerID in this.layerDefs) {
                if (this.layerDefs.hasOwnProperty(layerID)) {
                    if (this.layerDefs[layerID]) {
                        layerDefStrList.push(layerID);
                        layerDefStrList.push(":");
                        layerDefStrList.push(this.layerDefs[layerID]);
                        layerDefStrList.push(";");
                    }
                }
            }
            if (layerDefStrList.length > 0) {
                newParams['LAYERDEFS'] = layerDefStrList.join("");
            }
        }
        var requestString = this.getFullRequestString(newParams);
        return requestString;
    },
    
    /**
     * Method: setLayerFilter
     * addTile creates a tile, initializes it, and adds it to the layer div. 
     *
     * Parameters:
     * id - {String} The id of the layer to which the filter applies.
     * queryDef - {String} A sql-ish query filter, for more detail see the ESRI
     *                     documentation at http://sampleserver1.arcgisonline.com/ArcGIS/SDK/REST/export.html
     */
    setLayerFilter: function ( id, queryDef ) {
        if (!this.layerDefs) {
            this.layerDefs = {};
        }
        if (queryDef) {
            this.layerDefs[id] = queryDef;
        } else {
            delete this.layerDefs[id];
        }
    },
    
    /**
     * Method: clearLayerFilter
     * Clears layer filters, either from a specific layer,
     * or all of them.
     *
     * Parameters:
     * id - {String} The id of the layer from which to remove any
     *               filter.  If unspecified/blank, all filters
     *               will be removed.
     */
    clearLayerFilter: function ( id ) {
        if (id) {
            delete this.layerDefs[id];
        } else {
            delete this.layerDefs;
        }
    },
    
    /**
     * APIMethod: mergeNewParams
     * 在调用父类的可变参数以前将可变参数与大写的新参数合并。一旦参数变化，瓦片将会使用新的参数重新加载。
     * 
     * Parameters:
     * newParams - {Object}键值对参数，参数是本类的成员属性
     */
    mergeNewParams:function(newParams) {
        var upperParams = OpenLayers.Util.upperCaseObject(newParams);
        var newArguments = [upperParams];
        return OpenLayers.Layer.Grid.prototype.mergeNewParams.apply(this, 
                                                             newArguments);
    },

    CLASS_NAME: "Geo.View2D.Layer.DynamicMapService"
});/**
 * Class: Geo.View2D.Layer.TileMapService
 *	 地图瓦片图层。地图瓦片图层请求的是地图瓦片服务，该服务请求的瓦片是服务端已经缓存好的瓦片，而不是实时渲染生成的。  
 *   本图层支持的服务类型包括：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest。
 */
Geo.View2D.Layer.TileMapService = Geo.Class(Geo.View2D.Layer.XYZ, {  

    /**
     * APIProperty: url
     * {String} 地图瓦片服务地址。
     */
    url: null,
    
   /**
    * APIProperty: tileOrigin
    * {<Geo.LonLat>} 瓦片原点
    */
    tileOrigin: null, 
   
   /**
    * APIProperty: tileSize
    * {<Geo.Size>} 每个瓦片的大小，默认宽高是256像素
    */
    tileSize: new Geo.Size(256, 256),
    
   /**
    * APIProperty: useArcGISServer
    * {Boolean} 是否按照tile/z/y/x格式去请求瓦片。
    * 如果为true,请求格式为tile/z/y/x；如果为false,请求格式为tile/z/y/x.type；其中type为瓦片类型，其默认值为png
	*	
    */    
    useArcGISServer: true,

   /**
    * APIProperty: type
    * {String}请求瓦片的格式
    */
    type: 'png',
    
   /**
    * Constructor: Geo.View2D.Layer.TileMapService
    * 创建一个地图瓦片图层
    * 
    * Parameters: 
    * name - {String} 图层名
    * url - {String} 地图瓦片服务地址
    * options - {Object} 键值对对象。可以设置本类及其父类的属性。
    * 
    * (code)
    * 	//墨卡托投影下创建地图服务瓦片图层
	* 	var tileLayer = new Geo.View2D.Layer.TileMapService( "TileMapService",
    *     	"http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer", {
    *       isBaseLayer: true,                    
    *       tileSize: new Geo.Size(256, 256),                        
    *       tileOrigin: new Geo.LonLat(-20037508.342787 , 20037508.342787),                        
    *       maxExtent: new Geo.Bounds(-20037507.067162,-19971868.880409,20037507.067162,19971868.880409)
    *  });
    * (end)
    * 	
    */ 
    initialize: function(name, url, options) { 
        Geo.View2D.Layer.XYZ.prototype.initialize.apply(this, arguments);

        if (this.resolutions) {        
            this.serverResolutions = this.resolutions;
       //     this.maxExtent = this.getMaxExtentForResolution(this.resolutions[0]);
        }

        // this block steps through translating the values from the server layer JSON 
        // capabilities object into values that we can use.  This is also a helpful
        // reference when configuring this layer directly.
        if (this.layerInfo) {
            // alias the object
            var info = this.layerInfo;
            
            // build our extents
            var startingTileExtent = new Geo.Bounds(
                info.fullExtent.xmin, 
                info.fullExtent.ymin, 
                info.fullExtent.xmax, 
                info.fullExtent.ymax  
            );

            // set our projection based on the given spatial reference.
            // esri uses slightly different IDs, so this may not be comprehensive
            this.projection = 'EPSG:' + info.spatialReference.wkid;
            this.sphericalMercator = (info.spatialReference.wkid == 102100);
            
            // convert esri units into openlayers units (basic feet or meters only)
            this.units = (info.units == "esriFeet") ? 'ft' : 'm';

            // optional extended section based on whether or not the server returned
            // specific tile information
            if (!!info.tileInfo) {            
                // either set the tiles based on rows/columns, or specific width/height
                this.tileSize = new Geo.Size(
                    info.tileInfo.width || info.tileInfo.cols, 
                    info.tileInfo.height || info.tileInfo.rows
                );
                
                // this must be set when manually configuring this layer
                this.tileOrigin = new Geo.LonLat(
                    info.tileInfo.origin.x, 
                    info.tileInfo.origin.y
                );

                var upperLeft = new Geo.Geometry.Point(
                    startingTileExtent.left, 
                    startingTileExtent.top
                );
                
                var bottomRight = new Geo.Geometry.Point(
                    startingTileExtent.right, 
                    startingTileExtent.bottom
                );            
                
                if (this.useScales) {
                    this.scales = [];
                } else {
                    this.resolutions = [];
                }
                
                this.lods = [];
                for(var key in info.tileInfo.lods) {
                    if (info.tileInfo.lods.hasOwnProperty(key)) {
                        var lod = info.tileInfo.lods[key];
                        if (this.useScales) {
                            this.scales.push(lod.scale);
                        } else {
                            this.resolutions.push(lod.resolution);
                        }
                    
                        var start = this.getContainingTileCoords(upperLeft, lod.resolution);
                        lod.startTileCol = start.x;
                        lod.startTileRow = start.y;
                    
                        var end = this.getContainingTileCoords(bottomRight, lod.resolution);
                        lod.endTileCol = end.x;
                        lod.endTileRow = end.y;    
                        this.lods.push(lod);
                    }
                }

                this.maxExtent = this.calculateMaxExtentWithLOD(this.lods[0]);
                this.serverResolutions = this.resolutions;
                if (this.overrideDPI && info.tileInfo.dpi) {
                    // see comment above for 'overrideDPI'
                    OpenLayers.DOTS_PER_INCH = info.tileInfo.dpi;
                }
            } 
       }
    }, 

   /** 
    * Method: getContainingTileCoords
    * Calculates the x/y pixel corresponding to the position of the tile
    *     that contains the given point and for the for the given resolution.
    * 
    * Parameters:
    * point - {<Geo.Geometry.Point>} 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getContainingTileCoords: function(point, res) {
        return new Geo.Pixel(
           Math.max(Math.floor((point.x - this.tileOrigin.lon) / (this.tileSize.w * res)),0),
           Math.max(Math.floor((this.tileOrigin.lat - point.y) / (this.tileSize.h * res)),0)
        );
    },
    
   /** 
    * Method: calculateMaxExtentWithLOD
    * Given a Level of Detail object from the server, this function
    *     calculates the actual max extent
    * 
    * Parameters: 
    * lod - {Object} a Level of Detail Object from the server capabilities object 
            representing a particular zoom level
    * 
    * Returns: 
    * {<Geo.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithLOD: function(lod) {
        // the max extent we're provided with just overlaps some tiles
        // our real extent is the bounds of all the tiles we touch

        var numTileCols = (lod.endTileCol - lod.startTileCol) + 1;
        var numTileRows = (lod.endTileRow - lod.startTileRow) + 1;        

        var minX = this.tileOrigin.lon + (lod.startTileCol * this.tileSize.w * lod.resolution);
        var maxX = minX + (numTileCols * this.tileSize.w * lod.resolution);

        var maxY = this.tileOrigin.lat - (lod.startTileRow * this.tileSize.h * lod.resolution);
        var minY = maxY - (numTileRows * this.tileSize.h * lod.resolution);
        return new Geo.Bounds(minX, minY, maxX, maxY);
   },
    
   /** 
    * Method: calculateMaxExtentWithExtent
    * Given a 'suggested' max extent from the server, this function uses
    *     information about the actual tile sizes to determine the actual
    *     extent of the layer.
    * 
    * Parameters: 
    * extent - {<Geo.Bounds>} The 'suggested' extent for the layer
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithExtent: function(extent, res) {
        var upperLeft = new Geo.Geometry.Point(extent.left, extent.top);
        var bottomRight = new Geo.Geometry.Point(extent.right, extent.bottom);
        var start = this.getContainingTileCoords(upperLeft, res);
        var end = this.getContainingTileCoords(bottomRight, res);
        var lod = {
            resolution: res,
            startTileCol: start.x,
            startTileRow: start.y,
            endTileCol: end.x,
            endTileRow: end.y
        };
        return this.calculateMaxExtentWithLOD(lod);
   },
    
    /** 
    * Method: getUpperLeftTileCoord
    * Calculates the x/y pixel corresponding to the position 
    *     of the upper left tile for the given resolution.
    * 
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getUpperLeftTileCoord: function(res) {
        var upperLeft = new Geo.Geometry.Point(
            this.maxExtent.left,
            this.maxExtent.top);
        return this.getContainingTileCoords(upperLeft, res);
    },

    /** 
    * Method: getLowerRightTileCoord
    * Calculates the x/y pixel corresponding to the position 
    *     of the lower right tile for the given resolution.
    *  
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Pixel>} The x/y pixel corresponding to the position
    * of the lower right tile for the given resolution.
    */
    getLowerRightTileCoord: function(res) {
        var bottomRight = new Geo.Geometry.Point(
            this.maxExtent.right,
            this.maxExtent.bottom);
        return this.getContainingTileCoords(bottomRight, res);
    },
    
   /** 
    * Method: getMaxExtentForResolution
    * Since the max extent of a set of tiles can change from zoom level
    *     to zoom level, we need to be able to calculate that max extent 
    *     for a given resolution.
    * 在进行级别切换的时候瓦片的最大范围会发生变化，所以我们需要计算给定分辨率的最大范围。
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Bounds>} The extent for this resolution
    */ 
    getMaxExtentForResolution: function(res) {
        var start = this.getUpperLeftTileCoord(res);
        var end = this.getLowerRightTileCoord(res);

        var numTileCols = (end.x - start.x) + 1;
        var numTileRows = (end.y - start.y) + 1;

        var minX = this.tileOrigin.lon + (start.x * this.tileSize.w * res);
        var maxX = minX + (numTileCols * this.tileSize.w * res);
        
        var maxY = this.tileOrigin.lat - (start.y * this.tileSize.h * res);
        var minY = maxY - (numTileRows * this.tileSize.h * res);
        return new Geo.Bounds(minX, minY, maxX, maxY);
    },
    
   /** 
    * APIMethod: clone 
    * 克隆图层
    * 
    * Parameters: 
    * [obj] - {Object} 传入本对象的一个实例.
    *  
    * Returns: 
    * {<Geo.View2D.Layer.ArcGISCache>} 返回克隆对象 
    */ 
    clone: function (obj) { 
        if (obj == null) { 
            obj = new Geo.View2D.Layer.TileMapService(this.name, this.url, this.options);
        }
        return Geo.View2D.Layer.XYZ.prototype.clone.apply(this, [obj]);
    },

   /**
    * Method: getURL
    * Determine the URL for a tile given the tile bounds.  This is should support
    *     urls that access tiles through an ArcGIS Server MapServer or directly through
    *     the hex folder structure using HTTP.  Just be sure to set the useArcGISServer
    *     property appropriately!  This is basically the same as 
    *     'OpenLayers.Layer.TMS.getURL',  but with the addition of hex addressing,
    *     and tile rounding.
    *	
    * Parameters:
    * bounds - {<Geo.Bounds>}
    *
    * Returns:
    * {String} The URL for a tile based on given bounds.
    */
	getURL: function (bounds) {
		bounds = this.adjustBounds(bounds);
        var res = this.map.getResolution();
        var x = Math.round((bounds.left - this.tileOrigin.lon) /
            (res * this.tileSize.w));
        var y = Math.round((this.tileOrigin.lat - bounds.top) /
            (res * this.tileSize.h));
        var z = 
            this.map.getZoom() + this.zoomOffset;

        var limit = Math.pow(2, z);
        if (this.wrapDateLine)
        {
           x = ((x % limit) + limit) % limit;
        }

   //     return {'x': x, 'y': y, 'z': z};
   		var url = this.url;
		var location = url.indexOf("/",url.length - 1);
		if(location != -1) {
			url = url + 'tile/${z}/${y}/${x}';
		}else {
			url = url + '/tile/${z}/${y}/${x}';
		}
//		url = url + '/tile/${z}/${y}/${x}';
        // Write the values into our formatted url
        url = OpenLayers.String.format(url, {'x': x, 'y': y, 'z': z});

        return url;
    }, 

    /**
     * Method: zeroPad
     * Create a zero padded string optionally with a radix for casting numbers.
     *
     * Parameters:
     * num - {Number} The number to be zero padded.
     * len - {Number} The length of the string to be returned.
     * radix - {Number} An integer between 2 and 36 specifying the base to use
     *     for representing numeric values.
     */
    zeroPad: function(num, len, radix) {
        var str = num.toString(radix || 10);
        while (str.length < len) {
            str = "0" + str;
        }
        return str;
    },

    CLASS_NAME: 'Geo.View2D.Layer.TileMapService' 
}); /**
 * Class: Geo.View2D.Layer.GeoMarkers
 * 吉奥标记图层构造类，本类的实例用来在吉奥标记图层上显示地图上的吉奥标注。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Markers> 
 */
Geo.View2D.Layer.GeoMarkers = Geo.Class(Geo.View2D.Layer.Markers, {

    /** 
     * Method: drawMarker
     * Calculate the pixel location for the marker, create it, and 
     *    add it to the layer's div
     *
     * Parameters:
     * marker - {<OpenLayers.Marker>} 
     */
    drawMarker: function(marker) {
        var px = this.map.getLayerPxFromLonLat(marker.lonlat);
        if (px == null) {
            marker.display(false);
        } else {
            if (!marker.isDrawn()) {
                var markerImg = marker.draw(px);
                this.div.appendChild(markerImg);
            } else if(marker.icon) {
                marker.icon.moveTo(px);
            }
			// 新增标签div绘制
			if (!marker.isDrawnTag()) {
                var div = marker.drawTag(px);
				if(div){
					this.div.appendChild(div);
				}
            } else if(marker.tag) {
                marker.tag.moveTo(px);
            }
        }
    },
    
    CLASS_NAME: "Geo.View2D.Layer.GeoMarkers"
});
/**
 * Class: Geo.View2D.ChartContainer
 * 专题图图表容器类。
 */
Geo.View2D.ChartContainer = Geo.Class({

    /** 
     * Property: events  
     * {<OpenLayers.Events>} custom event manager 
     */
    events: null,
    
    /** Property: id
     * {String} the unique identifier assigned to this popup.
     */
    id: "",

    /** 
     * Property: lonlat 
     * {<OpenLayers.LonLat>} the position of this popup on the map
     */
    lonlat: null,

    /** 
     * Property: div 
     * {DOMElement} the div that contains this popup.
     */
    div: null,

    /** 
     * Property: contentSize 
     * {<OpenLayers.Size>} the width and height of the content.
     */
    contentSize: null,    

    /** 
     * Property: size 
     * {<OpenLayers.Size>} the width and height of the popup.
     */
    size: null,    

    /** 
     * Property: contentHTML 
     * {String} An HTML string for this popup to display.
     */
    contentHTML: null,
    
    /** 
     * Property: backgroundColor 
     * {String} the background color used by the popup.
     */
    backgroundColor: "",
    
    /** 
     * Property: opacity 
     * {float} the opacity of this popup (between 0.0 and 1.0)
     */
    opacity: "",

    /** 
     * Property: border 
     * {String} the border size of the popup.  (eg 2px)
     */
    border: "",
    
    /** 
     * Property: contentDiv 
     * {DOMElement} a reference to the element that holds the content of
     *              the div.
     */
    contentDiv: null,
    
    /** 
     * Property: groupDiv 
     * {DOMElement} First and only child of 'div'. The group Div contains the
     *     'contentDiv' and the 'closeDiv'.
     */
    groupDiv: null,

    /** 
     * Property: closeDiv
     * {DOMElement} the optional closer image
     */
    closeDiv: null,

    /** 
     * APIProperty: autoSize
     * {Boolean} 根据内容自动调整浮云的大小，默认为false。
     */
    autoSize: false,

    /**
     * APIProperty: minSize
     * {<Geo.Size>}允许窗口显示的最小尺寸。
     */
    minSize: null,

    /**
     * APIProperty: maxSize
     * {<Geo.Size>}允许窗口显示的最大尺寸。
     */
    maxSize: null,

    /** 
     * Property: displayClass
     * {String} The CSS class of the popup.
     */
    displayClass: "olPopup",

    /** 
     * Property: contentDisplayClass
     * {String} The CSS class of the popup content div.
     */
    contentDisplayClass: "olPopupContent",

    /** 
     * Property: padding 
     * {int or <OpenLayers.Bounds>} An extra opportunity to specify internal 
     *     padding of the content div inside the popup. This was originally
     *     confused with the css padding as specified in style.css's 
     *     'olPopupContent' class. We would like to get rid of this altogether,
     *     except that it does come in handy for the framed and anchoredbubble
     *     popups, who need to maintain yet another barrier between their 
     *     content and the outer border of the popup itself. 
     * 
     *     Note that in order to not break API, we must continue to support 
     *     this property being set as an integer. Really, though, we'd like to 
     *     have this specified as a Bounds object so that user can specify
     *     distinct left, top, right, bottom paddings. With the 3.0 release
     *     we can make this only a bounds.
     */
    padding: 0,

    /** 
     * Property: disableFirefoxOverflowHack
     * {Boolean} The hack for overflow in Firefox causes all elements 
     *     to be re-drawn, which causes Flash elements to be 
     *     re-initialized, which is troublesome.
     *     With this property the hack can be disabled.
     */
    disableFirefoxOverflowHack: false,

    /**
     * Method: fixPadding
     * To be removed in 3.0, this function merely helps us to deal with the 
     *     case where the user may have set an integer value for padding, 
     *     instead of an <OpenLayers.Bounds> object.
     */
    fixPadding: function() {
        if (typeof this.padding == "number") {
            this.padding = new OpenLayers.Bounds(
                this.padding, this.padding, this.padding, this.padding
            );
        }
    },

    /**
     * APIProperty: panMapIfOutOfView
     *  {Boolean} 当绘制和地图的上下左右移动时，整个弹出框在当前视口是可见的。默认为false。
     */
    panMapIfOutOfView: false,
    
    /**
     * APIProperty: keepInMap 
     * {Boolean} 将该容器保存在地图对象里，默认为false。
     */
    keepInMap: false,

    /**
     * APIProperty: closeOnMove
     * {Boolean} 当地图平移时，关闭该容器。默认为false。
     */
    closeOnMove: false,

    /**
     * APIProperty: offset
     * {<Geo.Pixel>} 像素对象，表示图表容器的偏移量。
     */
    offset: null,
    
    /** 
     * Property: map 
     * {<OpenLayers.Map>} this gets set in Map.js when the popup is added to the map
     */
    map: null,

    /** 
    * Constructor: Geo.View2D.ChartContainer
    * 创建一个专题图图表容器。
    * 
    * Parameters: 
    * id - {String}  该容器的唯一标识，如果没有设置将会自动生成一个。
    * lonlat - {<Geo.LonLat>}  容器显示的地理位置。
    * contentSize - {<Geo.Size>} 容器的尺寸。
    * contentHTML - {String}  容器内容。
    * closeBox - {Boolean}   是否显示关闭该容器。
    * closeBoxCallback - {Function}   点击关闭该容器时的回调方法。
    */
    initialize:function(id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback) {
        if (id == null) {
            id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }

        this.id = id;
        this.lonlat = lonlat;

        this.contentSize = (contentSize != null) ? contentSize 
                                  : new OpenLayers.Size(
                                                   Geo.View2D.ChartContainer.WIDTH,
                                                   Geo.View2D.ChartContainer.HEIGHT);
        if (contentHTML != null) { 
             this.contentHTML = contentHTML;
        }
        this.backgroundColor = Geo.View2D.ChartContainer.COLOR;
        this.opacity = Geo.View2D.ChartContainer.OPACITY;
        this.border = Geo.View2D.ChartContainer.BORDER;

        this.div = OpenLayers.Util.createDiv(this.id, null, null, 
                                             null, null, null, "hidden");
        this.div.className = this.displayClass;
        
        var groupDivId = this.id + "_GroupDiv";
        this.groupDiv = OpenLayers.Util.createDiv(groupDivId, null, null, 
                                                    null, "relative", null,
                                                    "hidden");

        var id = this.div.id + "_contentDiv";
        this.contentDiv = OpenLayers.Util.createDiv(id, null, this.contentSize.clone(), 
                                                    null, "relative");
        this.contentDiv.className = this.contentDisplayClass;
        this.groupDiv.appendChild(this.contentDiv);
        this.div.appendChild(this.groupDiv);

        if (closeBox) {
            this.addCloseBox(closeBoxCallback);
        } 

        this.registerEvents();
    },

    /** 
     * Method: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {

        this.id = null;
        this.lonlat = null;
        this.size = null;
        this.contentHTML = null;
        
        this.backgroundColor = null;
        this.opacity = null;
        this.border = null;
        
        if (this.closeOnMove && this.map) {
            this.map.events.unregister("movestart", this, this.hide);
        }

        this.events.destroy();
        this.events = null;
        
        if (this.closeDiv) {
            OpenLayers.Event.stopObservingElement(this.closeDiv); 
            this.groupDiv.removeChild(this.closeDiv);
        }
        this.closeDiv = null;
        
        this.div.removeChild(this.groupDiv);
        this.groupDiv = null;

        if (this.map != null) {
            this.map.removePopup(this);
        }
        this.map = null;
        this.div = null;
        
        this.autoSize = null;
        this.minSize = null;
        this.maxSize = null;
        this.padding = null;
        this.panMapIfOutOfView = null;
    },

    /** 
    * Method: draw
    * Constructs the elements that make up the popup.
    *
    * Parameters:
    * px - {<OpenLayers.Pixel>} the position the popup in pixels.
    * 
    * Returns:
    * {DOMElement} Reference to a div that contains the drawn popup
    */
    draw: function(px) {
        if (px == null) {
            if ((this.lonlat != null) && (this.map != null)) {
                px = this.map.getLayerPxFromLonLat(this.lonlat);
            }
        }

        // this assumes that this.map already exists, which is okay because 
        // this.draw is only called once the popup has been added to the map.
        if (this.closeOnMove) {
            this.map.events.register("movestart", this, this.hide);
        }
        
        //listen to movestart, moveend to disable overflow (FF bug)
        if (!this.disableFirefoxOverflowHack && OpenLayers.BROWSER_NAME == 'firefox') {
            this.map.events.register("movestart", this, function() {
                var style = document.defaultView.getComputedStyle(
                    this.contentDiv, null
                );
                var currentOverflow = style.getPropertyValue("overflow");
                if (currentOverflow != "hidden") {
                    this.contentDiv._oldOverflow = currentOverflow;
                    this.contentDiv.style.overflow = "hidden";
                }
            });
            this.map.events.register("moveend", this, function() {
                var oldOverflow = this.contentDiv._oldOverflow;
                if (oldOverflow) {
                    this.contentDiv.style.overflow = oldOverflow;
                    this.contentDiv._oldOverflow = null;
                }
            });
        }

        this.moveTo(px);
        if (!this.autoSize && !this.size) {
            this.setSize(this.contentSize);
        }
        this.setBackgroundColor();
        this.setOpacity();
        this.setBorder();
        this.setContentHTML();
        
        if (this.panMapIfOutOfView) {
            this.panIntoView();
        }    

        return this.div;
    },

    /** 
     * Method: updatePosition
     * if the popup has a lonlat and its map members set, 
     * then have it move itself to its proper position
     */
    updatePosition: function() {
        if ((this.lonlat) && (this.map)) {
            var px = this.map.getLayerPxFromLonLat(this.lonlat);
            if (px) {
                this.moveTo(px);           
            }    
        }
    },

    /**
     * Method: moveTo
     * 
     * Parameters:
     * px - {<OpenLayers.Pixel>} the top and left position of the popup div. 
     */
    moveTo: function(px) {
        if ((px != null) && (this.div != null)) {
			var px = px.offset(this.offset);
            this.div.style.left = px.x + "px";
            this.div.style.top = px.y + "px";
        }
    },

    /**
     * Method: visible
     *
     * Returns:      
     * {Boolean} Boolean indicating whether or not the popup is visible
     */
    visible: function() {
        return OpenLayers.Element.visible(this.div);
    },

    /**
     * Method: toggle
     * Toggles visibility of the popup.
     */
    toggle: function() {
        if (this.visible()) {
            this.hide();
        } else {
            this.show();
        }
    },

    /**
     * Method: show
     * Makes the popup visible.
     */
    show: function() {
        this.div.style.display = '';

        if (this.panMapIfOutOfView) {
            this.panIntoView();
        }    
    },

    /**
     * Method: hide
     * Makes the popup invisible.
     */
    hide: function() {
        this.div.style.display = 'none';
    },

    /**
     * Method: setSize
     * Used to adjust the size of the popup. 
     *
     * Parameters:
     * contentSize - {<OpenLayers.Size>} the new size for the popup's 
     *     contents div (in pixels).
     */
    setSize:function(contentSize) { 
        this.size = contentSize.clone(); 
        
        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
        //  must add that to the desired "size". 
        var contentDivPadding = this.getContentDivPadding();
        var wPadding = contentDivPadding.left + contentDivPadding.right;
        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

        // take into account the popup's 'padding' property
        this.fixPadding();
        wPadding += this.padding.left + this.padding.right;
        hPadding += this.padding.top + this.padding.bottom;

        // make extra space for the close div
        if (this.closeDiv) {
            var closeDivWidth = parseInt(this.closeDiv.style.width);
            wPadding += closeDivWidth + contentDivPadding.right;
        }

        //increase size of the main popup div to take into account the 
        // users's desired padding and close div.        
        this.size.w += wPadding;
        this.size.h += hPadding;

        //now if our browser is IE, we need to actually make the contents 
        // div itself bigger to take its own padding into effect. this makes 
        // me want to shoot someone, but so it goes.
        if (OpenLayers.BROWSER_NAME == "msie") {
            this.contentSize.w += 
                contentDivPadding.left + contentDivPadding.right;
            this.contentSize.h += 
                contentDivPadding.bottom + contentDivPadding.top;
        }

        if (this.div != null) {
            this.div.style.width = this.size.w + "px";
            this.div.style.height = this.size.h + "px";
        }
        if (this.contentDiv != null){
            this.contentDiv.style.width = contentSize.w + "px";
            this.contentDiv.style.height = contentSize.h + "px";
        }
    },  

    /**
     * APIMethod: updateSize
     * 更新尺寸大小。
     */
    updateSize: function() {
        
        // determine actual render dimensions of the contents by putting its
        // contents into a fake contentDiv (for the CSS) and then measuring it
        var preparedHTML = "<div class='" + this.contentDisplayClass+ "'>" + 
            this.contentDiv.innerHTML + 
            "</div>";
 
        var containerElement = (this.map) ? this.map.layerContainerDiv
        								  : document.body;
        var realSize = OpenLayers.Util.getRenderedDimensions(
            preparedHTML, null,	{
                displayClass: this.displayClass,
                containerElement: containerElement
            }
        );

        // is the "real" size of the div is safe to display in our map?
        var safeSize = this.getSafeContentSize(realSize);

        var newSize = null;
        if (safeSize.equals(realSize)) {
            //real size of content is small enough to fit on the map, 
            // so we use real size.
            newSize = realSize;

        } else {

            //make a new OL.Size object with the clipped dimensions 
            // set or null if not clipped.
            var fixedSize = new OpenLayers.Size();
            fixedSize.w = (safeSize.w < realSize.w) ? safeSize.w : null;
            fixedSize.h = (safeSize.h < realSize.h) ? safeSize.h : null;
        
            if (fixedSize.w && fixedSize.h) {
                //content is too big in both directions, so we will use 
                // max popup size (safeSize), knowing well that it will 
                // overflow both ways.                
                newSize = safeSize;
            } else {
                //content is clipped in only one direction, so we need to 
                // run getRenderedDimensions() again with a fixed dimension
                var clippedSize = OpenLayers.Util.getRenderedDimensions(
                    preparedHTML, fixedSize, {
                        displayClass: this.contentDisplayClass,
                        containerElement: containerElement
                    }
                );
                
                //if the clipped size is still the same as the safeSize, 
                // that means that our content must be fixed in the 
                // offending direction. If overflow is 'auto', this means 
                // we are going to have a scrollbar for sure, so we must 
                // adjust for that.
                //
                var currentOverflow = OpenLayers.Element.getStyle(
                    this.contentDiv, "overflow"
                );
                if ( (currentOverflow != "hidden") && 
                     (clippedSize.equals(safeSize)) ) {
                    var scrollBar = OpenLayers.Util.getScrollbarWidth();
                    if (fixedSize.w) {
                        clippedSize.h += scrollBar;
                    } else {
                        clippedSize.w += scrollBar;
                    }
                }
                
                newSize = this.getSafeContentSize(clippedSize);
            }
        }                        
        this.setSize(newSize);     
    },    

    /**
     * Method: setBackgroundColor
     * Sets the background color of the popup.
     *
     * Parameters:
     * color - {String} the background color.  eg "#FFBBBB"
     */
    setBackgroundColor:function(color) { 
        if (color != undefined) {
            this.backgroundColor = color; 
        }
        
        if (this.div != null) {
            this.div.style.backgroundColor = this.backgroundColor;
        }
    },  
    
    /**
     * Method: setOpacity
     * Sets the opacity of the popup.
     * 
     * Parameters:
     * opacity - {float} A value between 0.0 (transparent) and 1.0 (solid).   
     */
    setOpacity:function(opacity) { 
        if (opacity != undefined) {
            this.opacity = opacity; 
        }
        
        if (this.div != null) {
            // for Mozilla and Safari
            this.div.style.opacity = this.opacity;

            // for IE
            //this.div.style.filter = 'alpha(opacity=' + this.opacity*100 + ')';
        }
    },  
    
    /**
     * Method: setBorder
     * Sets the border style of the popup.
     *
     * Parameters:
     * border - {String} The border style value. eg 2px 
     */
    setBorder:function(border) { 
        if (border != undefined) {
            this.border = border;
        }
        
        if (this.div != null) {
            this.div.style.border = this.border;
        }
    },      
    
    /**
     * Method: setContentHTML
     * Allows the user to set the HTML content of the popup.
     *
     * Parameters:
     * contentHTML - {String} HTML for the div.
     */
    setContentHTML:function(contentHTML) {

        if (contentHTML != null) {
            this.contentHTML = contentHTML;
        }
       
        if ((this.contentDiv != null) && 
            (this.contentHTML != null) &&
            (this.contentHTML != this.contentDiv.innerHTML)) {
       
            this.contentDiv.innerHTML = this.contentHTML;
       
            if (this.autoSize) {
                
                //if popup has images, listen for when they finish
                // loading and resize accordingly
                this.registerImageListeners();

                //auto size the popup to its current contents
                this.updateSize();
            }
        }    

    },
    
    /**
     * Method: registerImageListeners
     * Called when an image contained by the popup loaded. this function
     *     updates the popup size, then unregisters the image load listener.
     */   
    registerImageListeners: function() { 

        // As the images load, this function will call updateSize() to 
        // resize the popup to fit the content div (which presumably is now
        // bigger than when the image was not loaded).
        // 
        // If the 'panMapIfOutOfView' property is set, we will pan the newly
        // resized popup back into view.
        // 
        // Note that this function, when called, will have 'popup' and 
        // 'img' properties in the context.
        //
        var onImgLoad = function() {
            
            this.popup.updateSize();
     
            if ( this.popup.visible() && this.popup.panMapIfOutOfView ) {
                this.popup.panIntoView();
            }

            OpenLayers.Event.stopObserving(
                this.img, "load", this.img._onImageLoad
            );
    
        };

        //cycle through the images and if their size is 0x0, that means that 
        // they haven't been loaded yet, so we attach the listener, which 
        // will fire when the images finish loading and will resize the 
        // popup accordingly to its new size.
        var images = this.contentDiv.getElementsByTagName("img");
        for (var i = 0, len = images.length; i < len; i++) {
            var img = images[i];
            if (img.width == 0 || img.height == 0) {

                var context = {
                    'popup': this,
                    'img': img
                };

                //expando this function to the image itself before registering
                // it. This way we can easily and properly unregister it.
                img._onImgLoad = OpenLayers.Function.bind(onImgLoad, context);

                OpenLayers.Event.observe(img, 'load', img._onImgLoad);
            }    
        } 
    },

    /**
     * APIMethod: getSafeContentSize
     * 该容器的尺寸既不小于最小尺寸，也不大于最大尺寸，而是计算相对于视口的合适尺寸大小。
     * 
     * Parameters:
     * size - {<Geo.Size>} 所需区域的大小。
     * 
     * Returns:
     * {<Geo.Size>} 返回合适的尺寸。
     */
    getSafeContentSize: function(size) {

        var safeContentSize = size.clone();

        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
        //  must add that to the desired "size". 
        var contentDivPadding = this.getContentDivPadding();
        var wPadding = contentDivPadding.left + contentDivPadding.right;
        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

        // take into account the popup's 'padding' property
        this.fixPadding();
        wPadding += this.padding.left + this.padding.right;
        hPadding += this.padding.top + this.padding.bottom;

        if (this.closeDiv) {
            var closeDivWidth = parseInt(this.closeDiv.style.width);
            wPadding += closeDivWidth + contentDivPadding.right;
        }

        // prevent the popup from being smaller than a specified minimal size
        if (this.minSize) {
            safeContentSize.w = Math.max(safeContentSize.w, 
                (this.minSize.w - wPadding));
            safeContentSize.h = Math.max(safeContentSize.h, 
                (this.minSize.h - hPadding));
        }

        // prevent the popup from being bigger than a specified maximum size
        if (this.maxSize) {
            safeContentSize.w = Math.min(safeContentSize.w, 
                (this.maxSize.w - wPadding));
            safeContentSize.h = Math.min(safeContentSize.h, 
                (this.maxSize.h - hPadding));
        }
        
        //make sure the desired size to set doesn't result in a popup that 
        // is bigger than the map's viewport.
        //
        if (this.map && this.map.size) {
            
            var extraX = 0, extraY = 0;
            if (this.keepInMap && !this.panMapIfOutOfView) {
                var px = this.map.getPixelFromLonLat(this.lonlat);
                switch (this.relativePosition) {
                    case "tr":
                        extraX = px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                    case "tl":
                        extraX = this.map.size.w - px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                    case "bl":
                        extraX = this.map.size.w - px.x;
                        extraY = px.y;
                        break;
                    case "br":
                        extraX = px.x;
                        extraY = px.y;
                        break;
                    default:    
                        extraX = px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                }
            }    
          
            var maxY = this.map.size.h - 
                this.map.paddingForPopups.top - 
                this.map.paddingForPopups.bottom - 
                hPadding - extraY;
            
            var maxX = this.map.size.w - 
                this.map.paddingForPopups.left - 
                this.map.paddingForPopups.right - 
                wPadding - extraX;
            
            safeContentSize.w = Math.min(safeContentSize.w, maxX);
            safeContentSize.h = Math.min(safeContentSize.h, maxY);
        }
        
        return safeContentSize;
    },
    
    /**
     * Method: getContentDivPadding
     * Glorious, oh glorious hack in order to determine the css 'padding' of 
     *     the contentDiv. IE/Opera return null here unless we actually add the 
     *     popup's main 'div' element (which contains contentDiv) to the DOM. 
     *     So we make it invisible and then add it to the document temporarily. 
     *
     *     Once we've taken the padding readings we need, we then remove it 
     *     from the DOM (it will actually get added to the DOM in 
     *     Map.js's addPopup)
     *
     * Returns:
     * {<OpenLayers.Bounds>}
     */
    getContentDivPadding: function() {

        //use cached value if we have it
        var contentDivPadding = this._contentDivPadding;
        if (!contentDivPadding) {

        	if (this.div.parentNode == null) {
	        	//make the div invisible and add it to the page        
	            this.div.style.display = "none";
	            document.body.appendChild(this.div);
	    	}
	            
            //read the padding settings from css, put them in an OL.Bounds        
            contentDivPadding = new OpenLayers.Bounds(
                OpenLayers.Element.getStyle(this.contentDiv, "padding-left"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-bottom"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-right"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-top")
            );
    
            //cache the value
            this._contentDivPadding = contentDivPadding;

            if (this.div.parentNode == document.body) {
	            //remove the div from the page and make it visible again
	            document.body.removeChild(this.div);
	            this.div.style.display = "";
            }
        }
        return contentDivPadding;
    },

    /**
     * Method: addCloseBox
     * 
     * Parameters:
     * callback - {Function} The callback to be called when the close button
     *     is clicked.
     */
    addCloseBox: function(callback) {

        this.closeDiv = OpenLayers.Util.createDiv(
            this.id + "_close", null, new OpenLayers.Size(17, 17)
        );
        this.closeDiv.className = "olPopupCloseBox"; 
        
        // use the content div's css padding to determine if we should
        //  padd the close div
        var contentDivPadding = this.getContentDivPadding();
         
        this.closeDiv.style.right = contentDivPadding.right + "px";
        this.closeDiv.style.top = contentDivPadding.top + "px";
        this.groupDiv.appendChild(this.closeDiv);

        var closePopup = callback || function(e) {
            this.hide();
            OpenLayers.Event.stop(e);
        };
        OpenLayers.Event.observe(this.closeDiv, "touchend", 
                OpenLayers.Function.bindAsEventListener(closePopup, this));
        OpenLayers.Event.observe(this.closeDiv, "click", 
                OpenLayers.Function.bindAsEventListener(closePopup, this));
    },

    /**
     * Method: panIntoView
     * Pans the map such that the popup is totaly viewable (if necessary)
     */
    panIntoView: function() {
        
        var mapSize = this.map.getSize();
    
        //start with the top left corner of the popup, in px, 
        // relative to the viewport
        var origTL = this.map.getViewPortPxFromLayerPx( new OpenLayers.Pixel(
            parseInt(this.div.style.left),
            parseInt(this.div.style.top)
        ));
        var newTL = origTL.clone();
    
        //new left (compare to margins, using this.size to calculate right)
        if (origTL.x < this.map.paddingForPopups.left) {
            newTL.x = this.map.paddingForPopups.left;
        } else 
        if ( (origTL.x + this.size.w) > (mapSize.w - this.map.paddingForPopups.right)) {
            newTL.x = mapSize.w - this.map.paddingForPopups.right - this.size.w;
        }
        
        //new top (compare to margins, using this.size to calculate bottom)
        if (origTL.y < this.map.paddingForPopups.top) {
            newTL.y = this.map.paddingForPopups.top;
        } else 
        if ( (origTL.y + this.size.h) > (mapSize.h - this.map.paddingForPopups.bottom)) {
            newTL.y = mapSize.h - this.map.paddingForPopups.bottom - this.size.h;
        }
        
        var dx = origTL.x - newTL.x;
        var dy = origTL.y - newTL.y;
        
        this.map.pan(dx, dy);
    },

    /** 
     * Method: registerEvents
     * Registers events on the popup.
     *
     * Do this in a separate function so that subclasses can 
     *   choose to override it if they wish to deal differently
     *   with mouse events
     * 
     *   Note in the following handler functions that some special
     *    care is needed to deal correctly with mousing and popups. 
     *   
     *   Because the user might select the zoom-rectangle option and
     *    then drag it over a popup, we need a safe way to allow the
     *    mousemove and mouseup events to pass through the popup when
     *    they are initiated from outside. The same procedure is needed for
     *    touchmove and touchend events.
     * 
     *   Otherwise, we want to essentially kill the event propagation
     *    for all other events, though we have to do so carefully, 
     *    without disabling basic html functionality, like clicking on 
     *    hyperlinks or drag-selecting text.
     */
     registerEvents:function() {
        this.events = new OpenLayers.Events(this, this.div, null, true);

        function onTouchstart(evt) {
            OpenLayers.Event.stop(evt, true);
        }
        this.events.on({
            "mousedown": this.onmousedown,
            "mousemove": this.onmousemove,
            "mouseup": this.onmouseup,
            "click": this.onclick,
            "mouseout": this.onmouseout,
            "dblclick": this.ondblclick,
            "touchstart": onTouchstart,
            scope: this
        });
        
     },

    /** 
     * Method: onmousedown 
     * When mouse goes down within the popup, make a note of
     *   it locally, and then do not propagate the mousedown 
     *   (but do so safely so that user can select text inside)
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmousedown: function (evt) {
        this.mousedown = true;
        OpenLayers.Event.stop(evt, true);
    },

    /** 
     * Method: onmousemove
     * If the drag was started within the popup, then 
     *   do not propagate the mousemove (but do so safely
     *   so that user can select text inside)
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmousemove: function (evt) {
        if (this.mousedown) {
            OpenLayers.Event.stop(evt, true);
        }
    },

    /** 
     * Method: onmouseup
     * When mouse comes up within the popup, after going down 
     *   in it, reset the flag, and then (once again) do not 
     *   propagate the event, but do so safely so that user can 
     *   select text inside
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmouseup: function (evt) {
        if (this.mousedown) {
            this.mousedown = false;
            OpenLayers.Event.stop(evt, true);
        }
    },

    /**
     * Method: onclick
     * Ignore clicks, but allowing default browser handling
     * 
     * Parameters:
     * evt - {Event} 
     */
    onclick: function (evt) {
        OpenLayers.Event.stop(evt, true);
    },

    /** 
     * Method: onmouseout
     * When mouse goes out of the popup set the flag to false so that
     *   if they let go and then drag back in, we won't be confused.
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmouseout: function (evt) {
        this.mousedown = false;
    },
    
    /** 
     * Method: ondblclick
     * Ignore double-clicks, but allowing default browser handling
     * 
     * Parameters:
     * evt - {Event} 
     */
    ondblclick: function (evt) {
        OpenLayers.Event.stop(evt, true);
    },

    CLASS_NAME: "OpenLayers.Popup"
});

Geo.View2D.ChartContainer.WIDTH = 200;
Geo.View2D.ChartContainer.HEIGHT = 200;
Geo.View2D.ChartContainer.COLOR = "white";
Geo.View2D.ChartContainer.OPACITY = 1;
Geo.View2D.ChartContainer.BORDER = "0px";
/**
 * Class: Geo.View2D.Popup.GeoFrameCloud
 * 带有阴影的浮云框。
 * 
 * Inherits from:
 *  - <Geo.View2D.Popup.FramedCloud>
 */
Geo.View2D.Popup.GeoFrameCloud = Geo.Class(Geo.View2D.Popup.FramedCloud, {
	
	/**
	 * Property: shadowSrc
	 * {String} 阴影图片的地址
	 */
	shadowSrc: null,
	
	/**
	 * APIProperty: isShowShadow
	 * {Boolean} 是否显示阴影，默认为true。
	 */
	isShowShadow: true,
	
	/**
	 * APIProperty: shadowOffset
	 * {Geo.Pixel} 阴影偏移量。
	 */
	shadowOffset: null,
	
	/**
	 * APIProperty: minSize
	 * {<Geo.Size>} 最小宽度等于左下角阴影宽度+尾巴阴影宽度。
	 * 说明：如果使用带阴影的浮云框，最小宽度不得低于120。
	 */
	minSize: new Geo.Size(120, 10),
	
	/**
	 * APIProperty: borderStyle
	 * {Integer} 浮云边框样式。默认为圆角边框样式。
	 * > 浮云框边角为圆角，指向为斜向(Geo.View2D.Popup.GeoFrameCloud.CORNER)，
	 * > 浮云框边角为直角，指向为斜向(Geo.View2D.Popup.GeoFrameCloud.SHARP)，
	 * > 浮云框边角为直角，指向为垂直(Geo.View2D.Popup.GeoFrameCloud.VERTICALDIRECTION)。
	 */
	borderStyle: 1,

	/** 
	 * Constructor: Geo.View2D.Popup.GeoFrameCloud
	 * Geo.View2D.Popup.GeoFrameCloud构造函数。
	 * 
	 * Parameters:
	 * id - {String}  浮云框的唯一标识，如果没有设置将会自动生成一个。
     * lonlat - {<Geo.LonLat>} 地图上浮云显示的位置。
     * contentSize - {<Geo.Size>} 浮云的尺寸。
     * contentHTML - {String} 浮云内容，浮云内容为HTML要素的字符串。
     * anchor - {Object} 锚点。包含一个大小信息{<Geo.Size>}和偏移信息{<Geo.Pixel>}的对象。(一般为{<Geo.View2D.Icon>}类型）。
     * closeBox - {Boolean} 是否显示关闭浮云窗口的按钮。
     * closeBoxCallback - {Function} 关闭浮云触发该回调函数。
	 * shadowOptions - {Object}
	 * >   isShowShadow -  {Boolean} 是否显示阴影,默认为true。
	 * >   shadowOffset - {<Geo.Pixel>} 阴影偏移,默认无偏移。
	 * >   取值举例：shadowOffset的值为new Geo.Pixel(2,3)，表示浮云框阴影向右偏移2个像素，向下偏移3个像素。
	 * borderStyle - {Number} 浮云边框样式。
	 */
	initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
						closeBoxCallback, shadowOptions, borderStyle) {
		
		if(shadowOptions && typeof shadowOptions.isShowShadow === "boolean" ) {
			this.isShowShadow = shadowOptions.isShowShadow === false ?  shadowOptions.isShowShadow : true;
		}
		if(shadowOptions && shadowOptions.shadowOffset instanceof OpenLayers.Pixel) {
			this.shadowOffset = shadowOptions.shadowOffset;
		}
		if(typeof shadowOptions.clickShadow === "function") {
			this.clickShadow = shadowOptions.clickShadow;
		}	
		if(typeof shadowOptions.moveoverShadow === "function") {
			this.moveoverShadow = shadowOptions.moveoverShadow;
		}				
		
		this.fixedRelativePosition = true;
		//固定浮云框显示位置为右上角
		this.relativePosition = "tr";
		this.shadowSrc = OpenLayers.Util.getImagesLocation() + "shadow.png";
		
		this.borderStyle = borderStyle ? borderStyle : Geo.View2D.Popup.GeoFrameCloud.CORNER;
		//OpenLayers.Popup.FramedCloud.prototype.initialize.apply(this, arguments);
        switch (this.borderStyle) {
            case Geo.View2D.Popup.GeoFrameCloud.CORNER:
				this.imageSrc = OpenLayers.Util.getImageLocation('cloud-popup-relative.png');
                break;
            case Geo.View2D.Popup.GeoFrameCloud.SHARP:
				this.imageSrc = OpenLayers.Util.getImageLocation('cloud-popup-relative-2.png');
                break;
            case Geo.View2D.Popup.GeoFrameCloud.VERTICALDIRECTION:
				this.imageSrc = OpenLayers.Util.getImageLocation('cloud-popup-relative-3.png');
                break;
        }
		OpenLayers.Popup.Framed.prototype.initialize.apply(this, arguments);
        this.contentDiv.className = this.contentDisplayClass;
		
		//让阴影能够显示出来
		this.div.style.overflow = "visible";
	},
	
	/** 
	 *	Method: createShadow
	 */
	createShadow: function() {
		var imgId = this.id + '_shadomImg_' ;
		//创建一个图片
		
		if ((this.lonlat != null) && (this.map != null)) {
			px = this.map.getLayerPxFromLonLat(this.lonlat);
		}
		
		var divId = this.id + '_shadomDiv_' ;
		this.shadowDiv = OpenLayers.Util.createDiv(divId, 
			null, null, null, "absolute", null, "visible", null
		);
		this.shadowDiv.style.position="absolute";
	   
		this.shadowDiv.style.zIndex = 0;
		this.calculateShadowDivLocation(this.size, this.shadowDiv);
		this.map.layerContainerDiv.appendChild(this.shadowDiv);
		this.shadowevents = new OpenLayers.Events(this, this.shadowDiv, null, true);
		var isClick = false;	
		this.shadowevents.on({
			"click": this.clickShadow,
			//鼠标是否经过阴影区
			"mousemove":this.moveoverShadow,
			scope: this
		});		
		this.map.events.register("zoomend", this,this.calculateShadowLocation);
	},
	
	/**
	 * Method: calculateShadowDivLocation
	 * 计算阴影div的位置。
	 */
	calculateShadowDivLocation: function(size, div) {
		var divId = this.id + '_leftTop_shadowdiv_';
		var divLocation = new OpenLayers.Pixel(0,0);
	
		this.divSize = new OpenLayers.Size();
		this.divSize.h = size.h * 0.5 - 30; //30是尾巴的高度
		this.divSize.w = size.w;// - divSize.h;//浮云框的宽度等于左上角阴影的宽度
		//创建左上角DIV
		var leftTop_shadowdiv = OpenLayers.Util.createDiv(divId,
			divLocation, this.divSize, null, "absolute",null, "hidden", null
		);
		
		var imgId = this.id + '_leftTop_shadomImg_' ;
		
		//左上角阴影left = (0+this.divSize.w);top = 0 TODO:需要限制divSize.h最大高度为330
		var imgleftLocation = 320 - this.divSize.h - 24; //320是浮云框阴影左边斜线组成的正方形的宽度，24是偏移
		var imgLocation = new OpenLayers.Pixel(-(0 + imgleftLocation), 0);
		
		
		var imgSize = new OpenLayers.Size(1062,356);
		
		var image = OpenLayers.Util.createImage(imgId, 
			imgLocation, imgSize, this.shadowSrc,
			"absolute", null, null, null
		);
		leftTop_shadowdiv.appendChild(image);
		div.appendChild(leftTop_shadowdiv);
		
		this.setrightTopshadowdiv(this.divSize,imgSize,div);
		this.setleftBottomShadowDiv(this.divSize,imgSize,div);
		this.setleftBottom23shadowdiv(this.divSize,imgSize,div);
		this.setrightBottomshadowdiv(this.divSize,imgSize,div);
		
	},
	/**
	 * Method: calculateShadowDivLocation
	 * 计算右上角阴影的位置。
	 */						
	setrightTopshadowdiv:function(divSize,imgSize,div) {
		//创建右上角DIV
		var divId = this.id + '_rightTop_shadowdiv_';
		var divrightTopLocation = new OpenLayers.Pixel(divSize.w,0);
		var divrightTopSize = new OpenLayers.Size();
		divrightTopSize.h = divSize.h; //40是尾巴的高度
		divrightTopSize.w = divSize.h + 20+11;//20是多加的长度
		var rightTop_shadowdiv = OpenLayers.Util.createDiv(divId,
			divrightTopLocation, divrightTopSize, null, "absolute",  null, "hidden", null
		);
		//创建右上角img
		var imgrightTopLocation = new OpenLayers.Pixel(-(1062 - divSize.h - 20-24-25), 1);//上面的div宽度多加了20，这里减去20
		var imgId = this.id + '_rightTop_shadomImg_' ;
		var rightTopImage = OpenLayers.Util.createImage(imgId, 
			imgrightTopLocation, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		rightTop_shadowdiv.appendChild(rightTopImage);
		div.appendChild(rightTop_shadowdiv);
		
	},
	/**
	 * Method: calculateShadowLocation
	 * 计算整个阴影的位置。
	 */	
	calculateShadowLocation: function() {
		var divleftBottomSize = this.divleftBottomSize;
		var div = this.shadowDiv;
		var shadowoffsetY = (this.divSize.h + divleftBottomSize.h);
		var px = this.map.getLayerPxFromLonLat(this.lonlat);
		//阴影尾巴的位置
		if(this.shadowOffset instanceof OpenLayers.Pixel) {
		div.style.top= (px.y - shadowoffsetY - 10 + this.shadowOffset.y)  + "px";//
		div.style.left= (px.x - divleftBottomSize.w - 5 + this.shadowOffset.x)+ "px";//
		}else {
			div.style.top= (px.y - shadowoffsetY - 10)  + "px";//
			div.style.left= (px.x - divleftBottomSize.w - 5)+ "px";//
		}
		this.setShadowzIndex(div);
	},
	
	/**
	 * Method: recalculateShadowLocation
	 * 重新计算整个阴影的位置。
	 */		
	recalculateShadowLocation: function(divSize, divleftBottomSize, div) {
		var shadowoffsetY = (this.divSize.h + divleftBottomSize.h);
		var px = this.map.getLayerPxFromLonLat(this.lonlat);
		//阴影尾巴的位置
		if(this.shadowOffset instanceof OpenLayers.Pixel) {
			div.style.top= (px.y - shadowoffsetY - 10 + this.shadowOffset.y)  + "px";//
			div.style.left= (px.x - divleftBottomSize.w - 5 + this.shadowOffset.x)+ "px";//
		}else {
			div.style.top= (px.y - shadowoffsetY - 10)  + "px";//
			div.style.left= (px.x - divleftBottomSize.w - 5)+ "px";//
		}
		
		this.setShadowzIndex(div);
		
	},
	/**
	 * Method: setShadowzIndex
	 * 设置div阴影的的zindex。
	 */	
	setShadowzIndex: function(div) { //设置阴影级别
		div.style.zIndex = this.map.Z_INDEX_BASE['Popup'] +
				this.map.popups.length;
	},
	/**
	 * Method: setrightBottomshadowdiv
	 * 添加右下角div阴影。
	 */
	setrightBottomshadowdiv:function(divSize,imgSize,div) {
		//左下边第三个DIV
		var divId3 = this.id + '_rightBottom_shadowdiv_';
		var divrightBottomLocation = new OpenLayers.Pixel(divSize.w,divSize.h);
		var divrightBottomSize = new OpenLayers.Size();
		divrightBottomSize.h = 40; //27是临时定的值
		//TODO:需要判断divSize.w至少要大于等于(divleftBottom2Size.w + 30)
		divrightBottomSize.w = 45;
		
		var imgrightBottom_shadowdiv = OpenLayers.Util.createDiv(divId3,
			divrightBottomLocation, divrightBottomSize, null, "absolute",  null, "hidden", null
		);
		
		//img
		var imgrightBottomLocation = new OpenLayers.Pixel(-703, -290);
		var imgId3 = this.id + '_rightBottom_shadomImg_' ;
		var imgrightBottomImage = OpenLayers.Util.createImage(imgId3, 
			imgrightBottomLocation, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		imgrightBottom_shadowdiv.appendChild(imgrightBottomImage);
		div.appendChild(imgrightBottom_shadowdiv);
	},
	
	/**
	 * Method: setrightBottomshadowdiv
	 * 添加左下角右边的两个阴影。
	 */
	setleftBottom23shadowdiv:function(divSize,imgSize,div) {
		//左下边第二个DIV
		var divId = this.id + '_leftBottom2_shadowdiv_';
		var divleftBottom2Location = new OpenLayers.Pixel(35,divSize.h);
		var divleftBottom2Size = new OpenLayers.Size();
		divleftBottom2Size.h = 70; //40是尾巴的高度
		divleftBottom2Size.w = 70;
		var imgleftBottom2_shadowdiv = OpenLayers.Util.createDiv(divId,
			divleftBottom2Location, divleftBottom2Size, null, "absolute",  null, "hidden", null
		);
		
		//img
		var imgleftBottom2Location = new OpenLayers.Pixel(-440, -290);
		var imgId = this.id + '_leftBottom2_shadomImg_' ;
		var imgleftBottom2Image = OpenLayers.Util.createImage(imgId, 
			imgleftBottom2Location, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		imgleftBottom2_shadowdiv.appendChild(imgleftBottom2Image);
		div.appendChild(imgleftBottom2_shadowdiv);
		
		//左下边第三个DIV
		var divId3 = this.id + '_leftBottom3_shadowdiv_';
		var divleftBottom3Location = new OpenLayers.Pixel((35 + divleftBottom2Size.w),divSize.h);
		var divleftBottom3Size = new OpenLayers.Size();
		divleftBottom3Size.h = 35; //35是临时定的值
		//TODO:需要判断divSize.w至少要大于等于(divleftBottom2Size.w + 30)
		
		divleftBottom3Size.w = divSize.w - divleftBottom2Size.w - 35;//这个30是divleftBottomSize.w
		var imgleftBottom3_shadowdiv = OpenLayers.Util.createDiv(divId3,
			divleftBottom3Location, divleftBottom3Size, null, "absolute",  null, "hidden", null
		);
		
		//img
		var imgleftBottom3Location = new OpenLayers.Pixel(-60, -290);
		var imgId3 = this.id + '_leftBottom3_shadomImg_' ;
		var imgleftBottom3Image = OpenLayers.Util.createImage(imgId3, 
			imgleftBottom3Location, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		imgleftBottom3_shadowdiv.appendChild(imgleftBottom3Image);
		div.appendChild(imgleftBottom3_shadowdiv);
	},
	
	/**
	 * Method: setrightBottomshadowdiv
	 * 添加左下角阴影。
	 */
	setleftBottomShadowDiv:function(divSize,imgSize, div) {
		//创建左下角DIV
		var divId = this.id + '_leftBottom_shadowdiv_';
		var divleftBottomLocation = new OpenLayers.Pixel(0,divSize.h);
		this.divleftBottomSize = new OpenLayers.Size();
		this.divleftBottomSize.h = 70 - 30; //TODO:70是临时得出来的，没有经过计算
		this.divleftBottomSize.w = 35;//TODO:30是临时得出来的，没有经过计算
		var leftBottom_shadowdiv = OpenLayers.Util.createDiv(divId,
			divleftBottomLocation, this.divleftBottomSize, null, "absolute",  null, "hidden", null
		);
		//创建左下角img
		var imgleftBottomLocation = new OpenLayers.Pixel(-5, -290);//TODO:310是临时得出来的，没有经过计算
		var imgId = this.id + '_leftBottom_shadomImg_' ;
		var leftBottomImage = OpenLayers.Util.createImage(imgId, 
			imgleftBottomLocation, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		leftBottom_shadowdiv.appendChild(leftBottomImage);
		div.appendChild(leftBottom_shadowdiv);
		this.recalculateShadowLocation(divSize, this.divleftBottomSize, div);
	},
	
	/**
	 * Method: setrightBottomshadowdiv
	 * 设置浮云框阴影的大小和位置。
	 */
	setShadowSize: function() {
		var image = this.image;
		var size = this.size;
		//设置阴影框大小
		image.style.width= (size.w + 80) + "px";
		image.style.height= size.h / 2+ "px";
		image.style.left= 0 + "px";
		image.style.bottom= 40 + "px";
	},
	
    /** 
     * Method: draw
     * 
     * Parameters:
     * px - {<Geo.Pixel>}
     * 
     * Returns:
     * {DOMElement} 包含浮云框的div。
     */
    draw: function(px) {
        
        OpenLayers.Popup.Anchored.prototype.draw.apply(this, arguments);
        if(this.isShowShadow) {
			//创建阴影图
			this.createShadow();
		}

        return this.div;
    },
	
	/**
	 * Method: addCloseBox
	 * 
	 * Parameters:
	 * callback - {Function} 点击关闭按钮的时候执行该回调。
	 */
	addCloseBox: function(callback) {

		this.closeDiv = OpenLayers.Util.createDiv(
			this.id + "_close", null, new OpenLayers.Size(17, 17)
		);
		this.closeDiv.className = "olPopupCloseBox"; 
		
		// use the content div's css padding to determine if we should
		//  padd the close div
		var contentDivPadding = this.getContentDivPadding();
		 
		this.closeDiv.style.right = contentDivPadding.right + "px";
		this.closeDiv.style.top = contentDivPadding.top + "px";
		this.groupDiv.appendChild(this.closeDiv);
		
		var closePopup = callback || function(e) {
			this.hide();
			OpenLayers.Event.stop(e);
		};
		OpenLayers.Event.observe(this.closeDiv, "touchend", 
				OpenLayers.Function.bindAsEventListener(closePopup, this));
		OpenLayers.Event.observe(this.closeDiv, "click", 
				OpenLayers.Function.bindAsEventListener(closePopup, this));
	},
	
	/**
	 * Method: hide
	 * 设置浮云框隐藏。
	 */
	hide: function() {
	   if(this.shadowDiv) {
			this.shadowDiv.style.display = 'none';
		}
		OpenLayers.Popup.FramedCloud.prototype.hide.apply(this, arguments);
	},
	
	/**
	 * Method: show
	 * 设置浮云框可显。
	 */
	show: function() {
		if(this.shadowDiv) {
			this.shadowDiv.style.display = '';
		}
		OpenLayers.Popup.FramedCloud.prototype.show.apply(this, arguments);   
	},
	
	/**
	 * APIMethod: clickShadow
	 * 鼠标点击浮云框阴影时执行的函数，可由用户重写此函数，自定义操作内容。
	 * 
	 * Parameters:
	 * event - {Object} 事件对象。
	 */
	clickShadow:function(event) {	
	},	
	
	/**
	 * APIMethod: moveoverShadow
	 * 鼠标移入浮云框阴影时执行的函数，可由用户重写此函数，自定义操作内容。
	 * 
	 * Parameters:
	 * event - {Object} 事件对象。
	 */
	moveoverShadow: function(event) {
	},	
	
	/** 
	 * APIMethod: destroy
	 * 销毁浮云框对象。
	 */
	destroy: function() {
		if(this.shadowDiv && this.map) {
			this.shadowevents.unregister({
				"click": this.clickShadow,
				//鼠标是否经过阴影区
				"mousemove":this.moveoverShadow,
				scope: this
			});	
			//移除浮云框阴影
			this.map.events.unregister("zoomend", this,this.calculateShadowLocation);
			this.map.layerContainerDiv.removeChild(this.shadowDiv);
			this.shadowDiv = null;	
		}
		OpenLayers.Popup.FramedCloud.prototype.destroy.apply(this, arguments);
	},	
	
    /**
     * Method: updateBlocks
     * Internal method, called on initialize and when the popup's relative
     *     position has changed. This function takes care of re-positioning
     *     the popup's blocks in their appropropriate places.
     */
    updateBlocks: function() {
        if (!this.blocks) {
            this.createBlocks();
        }
        
        if (this.size && this.relativePosition) {
            var position = this.positionBlocks[this.relativePosition];
            for (var i = 0; i < position.blocks.length; i++) {
    
                var positionBlock = position.blocks[i];
                var block = this.blocks[i];
    
                // adjust sizes
                var l = positionBlock.anchor.left;
                var b = positionBlock.anchor.bottom;
                var r = positionBlock.anchor.right;
                var t = positionBlock.anchor.top;
    
                //note that we use the isNaN() test here because if the 
                // size object is initialized with a "auto" parameter, the 
                // size constructor calls parseFloat() on the string, 
                // which will turn it into NaN
                //
                var w = (isNaN(positionBlock.size.w)) ? this.size.w - (r + l) 
                                                      : positionBlock.size.w;
    
                var h = (isNaN(positionBlock.size.h)) ? this.size.h - (b + t) 
                                                      : positionBlock.size.h;
    
                block.div.style.width = (w < 0 ? 0 : w) + 'px';
                block.div.style.height = (h < 0 ? 0 : h) + 'px';
    
                block.div.style.left = (l != null) ? l + 'px' : '';
                block.div.style.bottom = (b != null) ? b + 'px' : '';
                block.div.style.right = (r != null) ? r + 'px' : '';            
                block.div.style.top = (t != null) ? t + 'px' : '';
    
                block.image.style.left = positionBlock.position.x + 'px';
                block.image.style.top = positionBlock.position.y + 'px';
            }
			
			switch (this.borderStyle) {
	            case Geo.View2D.Popup.GeoFrameCloud.CORNER:
					this.contentDiv.style.left = this.padding.left + "px";
					this.contentDiv.style.top = this.padding.top + "px";
	                break;
	            case Geo.View2D.Popup.GeoFrameCloud.SHARP:
					this.contentDiv.style.left = 0 + "px";
					this.contentDiv.style.top = 0 + "px";
	                break;
	            case Geo.View2D.Popup.GeoFrameCloud.VERTICALDIRECTION:
					this.contentDiv.style.left = 0 + "px";
					this.contentDiv.style.top = 0 + "px";
	                break;
	        }
        }
    },
	
	CLASS_NAME: "Geo.View2D.Popup.GeoFrameCloud"
});

/**
 * Constant: CORNER
 * {Integer} 浮云边框为圆角的标识。
 */
Geo.View2D.Popup.GeoFrameCloud.CORNER = 1;


/**
 * Constant: SHARP
 * {Integer} 浮云边框为直角的标识。
 */
Geo.View2D.Popup.GeoFrameCloud.SHARP = 2;

/**
 * Constant: VERTICALDIRECTION
 * {Integer} 浮云边框为垂直指向要素的标识。
 */
Geo.View2D.Popup.GeoFrameCloud.VERTICALDIRECTION = 3;
/**
 * Class: Geo.View3D.Map
 * 三维地图对象。
 */
Geo.View3D.Map = Geo.Class({

    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
    
    /**
     * APIProperty: div
     * {DOMElement} 三维地图所在的div容器。
     */
    div: null,
    
    /**
     * APIProperty: activexObj
     * {DOMElement} 三维地图的ActiveX对象引用。
     */
    activexObj: null,
    
    /**
     * APIProperty: layers
     * {Array} 地图中所有图层。
     */
    layers: null, 
   
    /**
     * APIProperty: overLayers
     * {Array} 所有的覆盖图层。
     */
    overLayers: null,
    
    /**
     * APIProperty: controls
     * {Array} 地图中所有控件。
     */
    controls: null,
	
	/**
     * APIProperty: popups
     * {Array(<Geo.View3D.Popup>)} 添加到地图上的弹出框。
     */
    popups: null,
    
	/**
	 * Property: handlers
	 * {Object} 地图中所有鼠标事件监听器。
	 */
    handlers:null,
	
	/**
     * APIProperty: BaseLayerGroup
     * {Geo.View3D.BaseLayerGroup} 基础图层组。
     */
	baseLayerGroup: null,
    
	_auxStatus: null,
	
    /**
     * APIProperty: zoomRatio
     * {Number} 调用地图缩放方法zoomIn和zoomOut方法时的缩放比率值，默认值为0.05。
     */
    zoomRatio: 0.05,
    
    /**
     * APIProperty: EVENT_TYPES
     * {Array} 支持的事件类型。
     */
    EVENT_TYPES: ["unloadLayerGroup", "loadlayergroup"],
    
    /**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图的金字塔方案对象，在三维地图中只能为360度金字塔方案。
     */
    pyramid: null,
        
    events: null,
	
	// 图层移动方式的枚举变量
	_enumMoveLayerType: {
		"MOVE_TO_TOP": 0, //移动图层到顶层显示
		"MOVE_TO_BOTTOM": 1, //移动图层到底层显示
		"MOVE_UP": 2, //向上移动一层
		"MOVE_DOWN": 3 //向下移动一层
	},
	
	//三维球元素类型枚举
	_enumScreenElementType: {
		LATLONGGRID: 0,//经纬网格
		COMPASS: 1,//罗盘
		ATMOSPHERE: 2,//大气圈
		COODINFO: 3,//坐标信息
		CROSSHAIR: 5 //十字丝
	},
	
	/**
     * APIProperty: projection
     * {String} 地图投影,默认 "EPSG:4326".
     */
    projection: "EPSG:4326",    
        
    /**
     * APIProperty: units
     * {String} 地图单位，默认为'degrees'. 
     */
    units: 'degrees',	
    
    /** 
     * Constructor: Geo.View3D.Map
     * Geo.View3D.Map构造方法。
     *
     * Parameters:
     * div - {DOMElement|String} DIV元素。
     * options - {Object} 选项。
     * (code)
     * var map = new Geo.View3D.Map("simpleMap");
     * (end)
     *
     */
    initialize: function(div, options){
    
        if (typeof(div) == "string") {
            this.div = document.getElementById(div);
        }
        else {
            this.div = div;
        }
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME);
        
        //初始化插件
        var initResult = Geo.View3D.Map.getActivex(this.id + "_Activex");
        this.activexObj = initResult.obj;
        var version = initResult.version;
        
        //检查三维插件是否安装
//        if (!this.activexObj || initResult.version < Geo.View3D.Map.ACTIVEX_DEFAULT_VERSION) {
//            this.div.innerHTML = Geo.View3D.Map.activexErrorInfo;
//            return;
//        }        
        
        this.div.appendChild(this.activexObj);
		
		//this.setFocus(true);
		/*
		this.activexObj.onfocus = function(){
			this.parentNode.onfocus = "true";
		}
		*/
        this.setScenario("no server", 2);
        
        this.events = new OpenLayers.Events(this, 
                                            this.div, 
                                            this.EVENT_TYPES, 
                                            this.fallThrough, 
                                            {includeXY: true});
        //金字塔对象                                    
		this.pyramid = new Geo.Pyramid();                                            
        this.layers = [];
        this.overLayers = [];
        this.handlers = [];
		this.popups = [];
		
		//辅助图层状态信息初始化
    	this._auxStatus = {
	        latLongGrid: false,
	        compass:true,
	        coodInfo:true,
	        atmosphere:true,
	        crossHair:true
	    };
//        
//		this._initGeoRaster();
//        
//        //绑定量算事件
//        var measureHandler = OpenLayers.Function.bind(function(eventObj){
//            this._measureHandler(eventObj);
//        }, this);
//        this.activexObj.attachEvent("GGMeasureEvent", measureHandler);
//
		//绑定鼠标事件
        var mouseEventHandler = OpenLayers.Function.bind(function(eventObj){
			
            this._mouseEventHandler(eventObj);
        }, this);
     //   this.activexObj.attachEvent("OnMouseEvent", mouseEventHandler);
		if (this.activexObj.addEventListener){
			this.activexObj.addEventListener("MouseEvent",mouseEventHandler,false);      
		}else if (this.activexObj.attachEvent){
			this.activexObj.attachEvent("OnMouseEvent",mouseEventHandler);        
		}		
		
		//绑定视图范围改变事件
        var _viewExtentChanged = OpenLayers.Function.bind(function(eventObj){
            this.viewExtentChanged(eventObj);
        }, this);
     //   this.activexObj.attachEvent("OnViewExtentChanged", _viewExtentChanged);
		if (this.activexObj.addEventListener){
			this.activexObj.addEventListener("ViewExtentChanged",_viewExtentChanged,false);      
		}else if (this.activexObj.attachEvent){
			this.activexObj.attachEvent("OnViewExtentChanged",_viewExtentChanged);        
		}		
		
		//绑定键盘事件
//        var keyEventHandler = OpenLayers.Function.bind(function(eventObj){KeyCode,keyState
        var keyEventHandler = OpenLayers.Function.bind(function(keyCode,keyState){
        	var eventObj = {};
        	eventObj.keyCode = keyCode;
        	eventObj.keyState = keyState;
            this._keyEventHandler(eventObj);
        }, this);
    //    this.activexObj.attachEvent("OnKeyEvent", keyEventHandler);
		if (this.activexObj.addEventListener){
			this.activexObj.addEventListener("KeyEvent",keyEventHandler,false);      
		}else if (this.activexObj.attachEvent){
			this.activexObj.attachEvent("OnKeyEvent",keyEventHandler);        
		}
//		
//		//修正页面后退，刷新三维插件对不销毁问题
//		this.unloadDestroy = OpenLayers.Function.bind(this.destroy, this);
//        OpenLayers.Event.observe(window, 'unload', this.unloadDestroy);
// 
 		//如果未在构造地图对象时指定加载控件，则加载默认控件（键盘控制控件）
        if (this.controls == null) {
			
			//如果不存在Control也不加载控件
            if (Geo.View3D.Control != null) { 
                this.controls = [new Geo.View3D.Control.KeyboardDefaults()];
            }
            else {
                this.controls = [];
            }
        }
        for(var i=0, len=this.controls.length; i<len; i++) {
            this.addControlToMap(this.controls[i]);
        }
//		
//		//坐标信息显示设置为红色字体
//        var options = {
//            fontColor: 0x00ff0000
//        };
//		this.setCoodInfo(options);
    },

    /**
     * APIMethod: zoomTo
     * 缩放到指定的级别。
     * 
     * Parameters:
     * zoom - {Integer}
     */    
    zoomTo: function(zoom){
       if (zoom != null && zoom >= 0) {
            this.setCenter(null, zoom);
        }
    },
    
    /**
     * APIMethod: zoomIn
     * 放大地图级别。
     */    
    zoomIn: function(){
        this.zoom(this.zoomRatio);
    },
    
    /**
     * APIMethod: zoomOut
     * 缩小地图级别。
     */
    zoomOut: function(){
        this.zoom(-this.zoomRatio);
    },
    
    /**
     * APIMethod: zoom
     * 按指定比率缩放地图。
     */
    zoom: function(ratio){
        ratio = ratio ? ratio : 0.05;
        var camera = this.activexObj.Camera;
        camera.Zoom(ratio);
    },
	
	/**
     * APIMethod: pan
     * 允许用户根据屏幕的像素值来进行平移。
     * 
     * Parameters:
     * dx - {Integer}
     * dy - {Integer}
     */
    pan: function(dx, dy) {
		if ( (dx == null) || (dy == null) ) {
            var msg = OpenLayers.i18n("pixelAddError");
            OpenLayers.Console.error(msg);
            return null;
        }
        var globe = this.activexObj;
		if (globe) {
			globe.SceneBox.PanByScreen(dx, dy);
        }
	},
	
    /**
     * APIMethod: panTo
     * 根据坐标信息参数，将地图平移相应的距离。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 
     */
    panTo: function(lonlat){
        if(!lonlat){
            return;
        }
        // center will not change, don't do nothing
        var center = map.getCenter();
        if (lonlat.equals(center)) {
            return;
        }
		//经纬度各偏移1度
        var globe = this.activexObj;
        var lat = parseFloat(lonlat.lat - center.lat);
        var lon = parseFloat(lonlat.lon - center.lon);
        if (globe) {
			globe.SceneBox.Pan(lat, lon);
        } 
    },   
    
    /**
     * APIMethod: setCenter
     * 设置三维地图中心点和地图级别(没有飞行过程)。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 中心点。
     * level - {Integer} 地图级别。
     * isFly - {Boolean} 是否开启飞行动画效果。
     */
    setCenter: function(lonlat, level, isFly){
    	if(level === undefined){
	        level = this.getZoom();
	    }
	
	    isFly = isFly || false;
	    this._gotoPosition({
	        lon: lonlat.lon,
	        lat: lonlat.lat,
	        level: level
	    }, isFly);
    },
    
    /**
     * APIMethod: flyTo
     * 飞到三维地图中心点和海拨高度。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 中心点。
     * alt - {Integer} 海拨高度(单位为米) 。
     */
    flyTo: function(lonlat, alt){
        this._gotoPosition({
            lon: lonlat.lon,
            lat: lonlat.lat,
            alt: alt
        }, true);
    },

	/**
     * APIMethod: zoomToExtent
     * 缩放到指定地图范围。
     * 
     * Parameters:
     * bounds - {<Geo.Bounds>} 范围。
     * isFlyTo - {Boolean} 是否飞行过去。
     */
    zoomToExtent: function(bounds, isFlyTo) {
    	var center = bounds.getCenterLonLat();
	    var viewSize = this.getSize();
	    var idealResolution = Math.max( bounds.getWidth()  / viewSize.w,
	                                    bounds.getHeight() / viewSize.h );
		var p360 = this.pyramid;	                                    
	    var zoom = p360.getLevelForResolution(idealResolution);
	    if(zoom > Geo.View3D.Map.ZOOMTOEXTENT_MINILEVEL){
	        zoom = Geo.View3D.Map.ZOOMTOEXTENT_MINILEVEL;
	    }
	    this.setCenter(center,zoom,isFlyTo);
    },
        
    //定位到指定位置,可以指定是否飞行方式
    _gotoPosition: function(position, isFlyTo){
        var globe = this.activexObj;
        if(!globe){
            return;
        }
        
        var lon = position.lon;
        var lat = position.lat;
        var level = position.level;
        
        //如果未指定海拨高度,则用默认高度
        var alt = (typeof(position.alt) == "undefined") ? Geo.View3D.Map.DEFAULT_ALT : position.alt;
        
        //如果有指定级别则优先以级别换算高度
        alt = (typeof(level) != "undefined") ? Geo.View3D.Map.getZfromLevel(level) : alt;
        
		// 如果当前高度大于等于目标高度（alt）并且小于目标高度前一级别换算的高度，则不改变定位的高度。
        if (this.getAltitude() >= alt && level != 0 && this.getAltitude() < Geo.View3D.Map.getZfromLevel(level - 1)) {
			alt = this.getAltitude();
        }
		// 如果当前高度大于等于目标高度（alt）并且目标级别为0，则不改变定位的高度。
        if (this.getAltitude() >= alt && level == 0) {
			alt = this.getAltitude();
        }
		
        if (isFlyTo) {
	   		globe.SceneBox.ParabolaFlyTo(lon, lat, alt);
        }
        else {
			globe.SceneBox.PutCameraPosition(lon, lat, alt);
        }
    },
    
    /**
     * APIMethod: addLayer
     * 添加单个图层对象到地图中。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer>} 图层对象。
     */
    addLayer: function(layer){
        var layers = this.layers;
        if(!layer){
            return false;
        }
        for(var i=0, len=layers.length; i<len; i++) {
            if (this.layers[i] == layer) {
                var msg = OpenLayers.i18n('layerAlreadyAdded', 
                                                      {'layerName':layer.name});
                OpenLayers.Console.warn(msg);
                return false;
            }
        }
        this.layers.push(layer);
        layer.setMap(this);
    },
    
    /**
     * APIMethod: addLayers
     * 添加多个图层到地图中。
     * 
     * Parameters:
     * layers - {Array(<Geo.View3D.Layer>)}图层对象数组。
     */
    addLayers: function(layers){
        if (!(Geo.Util.isArray(layers))) {
            layers = [layers];
        }
        for (var i = 0; i < layers.length; i++) {
            this.addLayer(layers[i]);
        }
    },

    /**
	 * APIMethod: addOverLayer
	 * 将指定图层作为覆盖层添加。与addLayer方法不同的是，该图层的引用除了保存到地图对象的layers数组中，还将保存到overLayers数组。
	 * 覆盖层在基础图层组切换时，叠加顺序不受基础图层加载、卸载的影响，始终保持在所有基础图层的上方。
	 *
	 * Parameters: 
	 * layer - {Geo.View3D.Layer} 三维视图图层对象。
	 */		
    addOverLayer: function(layer){
        this.addLayer(layer);
        this.overLayers.push(layer);
    },
        
    /**
     * APIMethod: removeLayer
     * 从地图中移除图层。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer>} 图层对象。
     */
    removeLayer: function(layer){
        OpenLayers.Util.removeItem(this.overLayers, layer);
        OpenLayers.Util.removeItem(this.layers, layer);
        layer.removeMap();
        layer.map = null;
    },

    /**
     * APIMethod: getNumLayers
     * 获取当前地图中的图层个数。
     * 
     * Returns:
     * {Number} 图层个数。
     */
    getNumLayers:function(){
        return this.layers.length;
    },
    
    /**
     * APIMethod: getLayerByIndex
     * 获取指定图层在地图所有图层中的位置。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer>} 图层对象。
     * 
     * Returns:
     * {Number} 图层所在位置。
     */
    getLayerIndex: function (layer) {
        return OpenLayers.Util.indexOf(this.layers, layer);
    },
    
    /**
     * APIMethod: getLayer
     * 根据指定图层ID获取指定图层对象的引用。
     * 
     * Parameters:
     * id - {String} 编号。
     * 
     * Returns:
     * {<Geo.View3D.Layer>} 图层对象。
     */
    getLayer: function(id) {
        var foundLayer = null;
        
        //在数据图层中查询
        for (var i=0, len=this.layers.length; i<len; i++) {
            var layer = this.layers[i];
            if (layer.id == id) {
                foundLayer = layer;
                break;
            }
        }
        return foundLayer;
    },
    
    /**
     * APIMethod: raiseLayer
     * 移动指定图层，正数为下移，负数为上移。
     * 
     * Parameters:
     * layer - {Object} 图层对象。
     * delta - {}
     * 
     */
    raiseLayer: function (layer, delta) {
		//要移动图层的当前位置
		var currentIndex = this.getLayerIndex(layer);
		//delta表示移动几位
	    var tempDelta = Math.abs(delta);
		if(delta > 0) {
			for (var i = currentIndex, len=this.layers.length; i<len; i++) {
				//若起大于0
				if(tempDelta == 0 || len <= i+1) {
					break;
				}
				if(!this.layers[i+1].displayInLayerSwitcher) {
					delta ++;
				}else {
					tempDelta--;
				}
        		
        	}
		}else if(delta < 0) {
			for (var i = currentIndex, len=this.layers.length;i >= 0; i--) {
        		if(tempDelta == 0 || i - 1 < 0) {
					break;
				}
				if(!this.layers[i-1].displayInLayerSwitcher) {
					delta = delta - 1;
				}else {
					tempDelta--;
				}
        	}
		}
        var idx = this.getLayerIndex(layer) + delta;
        this.setLayerIndex(layer, idx);
    },

	
    /**
	 * APIMethod: resetTopLayer
	 * 将置顶图层重新排列。
	 */	
    resetTopLayer: function(){
        var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            if (layer.isOnTop) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
    },
	
	/**
	 * APIMethod: resetOverLayer
	 * 将覆盖图层重新排列。
	 */	
	resetOverLayer:function(){
		var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            
            //如果不是覆盖图层则视为底图图层将之移到最底层
            if (OpenLayers.Util.indexOf(this.overLayers,layer) != -1) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
	},
    
    /**
     * APIMethod: setLayerIndex
     * 改变图层所在位置。
     * 
     * Parameters:
     * layer - {Object} 图层对象。
     * idx - {Integer}
     * 
     */
    setLayerIndex: function (layer, idx) {
        var base = this.getLayerIndex(layer);
		/***/
		// 该图层前一个索引图层
		var aLayer = null;
		// 该图层后一个索引图层
		var bLayer = null;
		if(base == 0){
			var bLayer = this.layers[base + 1];
		}else if(base == this.layers.length - 1){
			var aLayer = this.layers[base - 1];
		}else{
			var aLayer = this.layers[base - 1];
			var bLayer = this.layers[base + 1];
		}
        var alayerData = null;
        var blayerData = null;
        
        if (aLayer && aLayer._layerData) {
            alayerData = aLayer._layerData;
            //针对前一个索引图层为WMS图层中会有多个指定子图层
            if (!(Geo.Util.isArray(aLayer._layerData))) {
                alayerData = [aLayer._layerData];
            }
        }
        if (bLayer && bLayer._layerData) {
            blayerData = bLayer._layerData;
            //针对后一个索引图层为WMS图层中会有多个指定子图层
            if (!(Geo.Util.isArray(bLayer._layerData))) {
                blayerData = [bLayer._layerData];
            }
        }
        
		/***/
        if (idx < 0) {
            idx = 0;
        } else if (idx > this.layers.length) {
            idx = this.layers.length;
        }
        if (base != idx) {
            this.layers.splice(base, 1);
            this.layers.splice(idx, 0, layer);
            
            //根据偏移量，移动插件中的图层
            var delta = base - idx;
			var layerData = layer._layerData;
			/***/
			//针对前一个索引图层为WMS图层中会有多个指定子图层，则偏移量多加上（图层个数-1（默认个数））
			if (alayerData && delta > 0) {
				delta += alayerData.length -1;
			}
			//针对后一个索引图层为WMS图层中会有多个指定子图层，则偏移量多减去（图层个数-1（默认个数））
			if (blayerData && delta < 0) {
				delta -= blayerData.length -1;
			}
			/***/
			if (layerData) {
				//针对WMS图层中会有多个指定子图层
				if (!(Geo.Util.isArray(layerData))) {
					layerData = [layerData];
				}
				for (var i = 0; i < Math.abs(delta); i++) {
					for (var m = 0; m < layerData.length; m++) {
						if (delta < 0) {
							this._moveLayerUp(layerData[m]);
						}
						if (delta > 0) {
							// 如果是需要置顶的图层（绘制图层）中如果包含标注图层则下移（置顶）
							if (layer.isOnTop && layer._markerLayer) {
								this._moveLayerDown(layer._markerLayer);
							}
							this._moveLayerDown(layerData[layerData.length - m - 1]);
						}
					}
				}
			}
        }
    },

    //图层组相关------------------------------------------------------------
    /**
     * APIMethod: loadLayerGroup
     * 加载图层组到地图中。
     * 
     * Parameters:
     * layerGroup - {Geo.View3D.BaseLayerGroup} 图层组对象。
     * 
     */
    loadLayerGroup: function(layerGroup){
		
        if (this.baseLayerGroup == layerGroup) {
            msg = "不能重复加载图层组到地图中！";
            OpenLayers.Console.warn(msg);
            return false;
        }
        this.unloadLayerGroup();

        layerGroup.setMap(this);
        this.baseLayerGroup = layerGroup;
        
        this.resetOverLayer();
        this.resetTopLayer();
        
        this.events.triggerEvent("loadlayergroup", {
            layerGroup: layerGroup,
			map : this
        });
    },
	
    /**
     * APIMethod: unloadLayerGroup
     * 卸载图层组。
     */
    unloadLayerGroup: function(){
		var layerGroup = this.baseLayerGroup;
        if (!layerGroup) {
			return false;
		}
        var layers = layerGroup.layers;
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            this.removeLayer(layer);
        }
        layerGroup.map = null;
        this.baseLayerGroup = null;
        this.events.triggerEvent("unloadLayerGroup", {
            layerGroup: layerGroup,
			map : this
        });
    },
    
    /**
     * APIMethod: addControl
     * 添加单个控件到地图中。
     * 
     * Parameters:
     * control - {Object} 控件对象。
     * 
     */
    addControl: function(control){
        this.controls.push(control);
        this.addControlToMap(control);
    },
    
    /**
     * APIMethod: addControls
     * 添加多个控件到地图中。
     * 
     * Parameters:
     * controls - {Object} 控件组。
     * 
     */
    addControls: function (controls) {
        for (var i=0, len=controls.length; i<len; i++) {
            var ctrl = controls[i];
            this.addControl(ctrl);
        }
    },
	
    //添加控件到地图中
    addControlToMap: function(control,px){
        control.setMap(this);
        control.draw(px);
        if(control.autoActivate) {
            control.activate();
        }
    },
    
    /**
     * APIMethod: getControl
     * 根据给定ID获取控件对象的引用。
     * 
	 * Parameters:
     * id - {String} 控件唯一标识。
     * 
     * Returns:
     * {<Geo.View3D.Control>} 控件对象。
     */
    getControl: function(id){
        var returnControl = null;
        for (var i = 0, len = this.controls.length; i < len; i++) {
            var control = this.controls[i];
            if (control.id == id) {
                returnControl = control;
                break;
            }
        }
        return returnControl;
    },
    
	/**
     * APIMethod: removeControl
     * 删除地图中的控件。移除的控件来自于地图对象的控件列表。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 移除的控件。
     */
    removeControl: function(control){
        if ((control) && (control == this.getControl(control.id))) {
            OpenLayers.Util.removeItem(this.controls, control);
			control.deactivate();
        }
    },
    
    /** 
     * APIMethod: addPopup
     * 添加浮云框。
     * 
     * Parameters:
     * popup - {<Geo.View3D.Popup>}
     * exclusive - {Boolean} 是否关闭其他的浮云框。
     */
    addPopup: function(popup, exclusive) {

        if (exclusive) {
            //remove all other popups from screen
            for (var i = this.popups.length - 1; i >= 0; --i) {
                this.removePopup(this.popups[i]);
            }
        }

        popup.map = this;
        this.popups.push(popup);
        popup.draw();
    },

    /** 
    * APIMethod: removePopup
    * 移除浮云框。
    * 
    * Parameters:
    * popup - {<Geo.View3D.Popup>}
    */
    removePopup: function(popup) {
		//如果参数为空，清除全部
		if(!popup){
			popup = this.popups;
		}
		if (!(Geo.Util.isArray(popup))) {
            popup = [popup];
        }
		for(var i = popup.length - 1; i >= 0; i--){
	        if (popup[i].map) {
	            popup[i]._clear();
	        }
	        popup[i].map = null;
			OpenLayers.Util.removeItem(this.popups, popup[i]);
		}
    },  
   
   /**
    * APIMethod: getAuxStatus
    * 获取指定辅助图层状态,如果为"all"则返回所有辅助图层的状态。
    * 
    * Parameters:
    * type - {Object}
    */
    getAuxStatus: function(type){
        return type == "all" ? this._auxStatus : this._auxStatus[type];
    },
	
    /**
     * APIMethod: showLatLongGrid
     * 设置是否显示经纬网格。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showLatLongGrid: function(isShow){
        var globe = this.activexObj;
        if (globe) {
            //auxTools = globe.GetAuxTools();
            //auxTools.ShowLatLongGrid(isShow);
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.LATLONGGRID,isShow);
            this._auxStatus["latLongGrid"] = isShow;
        }
        
    },
	
    /**
     * APIMethod: showCompass
     * 设置是否显示罗盘。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showCompass: function(isShow){
        var globe = this.activexObj;
        if (globe) {
            //参数1表示罗盘
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.COMPASS,isShow);
            this._auxStatus["compass"] = isShow;
        }
        
    },
    
    /**
     * APIMethod: showCoodInfo
     * 设置是否显示坐标信息。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showCoodInfo: function(isShow){
        var globe = this.activexObj;
        if (globe) {
            //参数3表示坐标信息
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.COODINFO,isShow);
            this._auxStatus["coodInfo"] = isShow;
        }
        
    },

    /**
     * APIMethod: setCoodInfo
     * 设置坐标信息相关选项，可以改变坐标信息的屏幕位置、文本对齐方式、字体颜色、字体名称、是否加粗、字号。
     * 
     * Parameters:
     * options - {<Object>} 参数对象，支持以下属性：
     *  - screenPosition 屏幕位置，可以为以下值：
     *      0：屏幕左下（默认）
     *      2：屏幕中下
     *      4：屏幕右下
     *      6：屏幕中央
     *      8：屏幕右上
     *      10：屏幕中上
     *      12：屏幕左上
     *  - textAlignment 文本对齐方式，可以为以下值：
     *      0：左对齐（默认）
     *      1：居中对齐
     *      2：右对齐
     *  - fontColor 字体颜色(默认0x000000ff)。
     *  - fontName 字体名称（默认"宋体"）。
     *  - fontBold 字体是否加粗。
     *  - fontSize 字号（默认14）。
     *  
     *  示例：
     *  (code)
     *  map.setCoodInfo({
     *     screenPosition: 2,
     *     fontSize: 18
     *  });
     *  (end)
     */    
    setCoodInfo:function(options){
        var defaultOption = {
            screenPosition: 0,
            textAlignment: 0, 
            fontColor: 0x000000ff, 
            fontName: "宋体", 
            fontBold: true, 
            fontSize: 14
        };
        
        OpenLayers.Util.applyDefaults(options,defaultOption);
        options.fontColor = Geo.Util.ToArgb(options.fontColor,255);
        var globe = this.activexObj;
		var coodInfo = globe.ScreenBox.QueryScreenElement(this._enumScreenElementType.COODINFO);
		coodInfo.ScreenPosition = options.screenPosition;
		coodInfo.TextAlignment = options.textAlignment;
		coodInfo.FontColor = options.fontColor;
		coodInfo.FontName = options.fontName;
		coodInfo.FontBold = options.fontBold;
		coodInfo.FontSize = options.fontSize;
	//	globe.ConfigBox.SaveConfigItem(8, options.screenPosition);
//        globe.GetAuxTools().SetPositionInfoParam(
//            options.screenPosition,
//            options.textAlignment,
//            options.fontColor,
//            options.fontName,
//            options.fontBold,
//            options.fontSize
//        )
    },
    

    /**
     * APIMethod: showAtmosphere
     * 设置是否显示大气圈。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showAtmosphere: function(isShow){
        var globe = this.activexObj;
        if (globe) {
			 //参数2表示大气圈
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.ATMOSPHERE,isShow);
            this._auxStatus["atmosphere"] = isShow;
        }
    },
    
    /**
     * APIMethod: showCrossHair
     * 设置是否显示十字丝。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showCrossHair: function(isShow){
        var globe = this.activexObj;
        if (globe) {
			//参数5表示十字丝
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.CROSSHAIR,isShow);
            this._auxStatus["crossHair"] = isShow;
        }
        
    },
	
    /**
     * APIMethod: setCompassPosition
     * 设置罗盘在屏幕上显示的位置。
     * 
     * Parameters:
     * positoin - {String} 罗盘的屏幕位置，目前只支持"left"或"right"，表示设置罗盘显示在屏幕右上或屏幕左上。
     * 
     */
    setCompassPosition: function(positoin){
        var globe = this.activexObj;
        if (globe) {
			switch(positoin){
				case "left" :
				   //第二个参数12表示罗盘在地图右上角；第一个参数7表示设置罗盘位置
					globe.ConfigBox.SaveConfigItem(7, 12);
					break;
				case "right" :
					globe.ConfigBox.SaveConfigItem(7, 8);
					break;
				default:
					return;
			}
        }
    },

    
    /**
     * APIMethod: setExaggeration
     * 设置地形夸张系数。
     * 
     * Parameters:
     * num - {Number} 为夸张的系数。
     */
    setExaggeration:function(num){
        num = (num < 0) ? 0 : num;
        num = (num > 5) ? 5 : num;
        
        var globe = this.activexObj;
        if (globe) {
            //globe.GetLayerBox().TerrainExaggeration(num);
			globe.Camera.TerrainExaggeration = num;
        }
    },    
    
    /**
     * APIMethod: resetNorth
     * 重新设置三维视图的指北方向。
     */
	resetNorth: function(){
		var globe = this.activexObj;
		if(globe){
//			globe.Camera.SetNorth();
			globe.Camera.Rotate(0, 0, 0.01 - globe.Camera.Heading); 
		}
	},

    /**
     * APIMethod: cameraRotation
     * 场景旋转。参数分别代表XYZ三个轴的偏移量。
     * 
     * Parameters:
     * dYaw - {Object}
     * dPitch - {Object}
     * dRoll - {Object}
     */
    cameraRotation: function(dYaw, dPitch, dRoll){
        var globe = this.activexObj;
        if (globe) {
            //参数分别代表XYZ三个轴的偏移量   
            globe.SceneBox.Rotate(dYaw, dPitch, dRoll);
        }
    },
    /**
     * APIMethod: getZoom
     * 获取当前海拨高度转换后的地图级别。
     * 
     * Returns:
     * {Integer} 地图级别。
     */
    getZoom: function(){
		var alt = this.getAltitude();
        return Geo.View3D.Map.getZoomfromAlt(Math.round(alt));
    },
    /**
    * APIMethod: getGeography
    * 获取当前中心点三维地理坐标。
    * 
    * Returns:
    * {Array} 三维地理坐标。
    */
    getGeography:function(){
    	return eval(this.activexObj.SceneBox.CameraLookAtScript);
    },
     /**
     * APIMethod: lonlatToScreen
     * 经纬度转屏幕像素。
     * 
     * Parameters:
     * lon - {Number} 经度。
     * lat - {Number} 纬度。
     * z - {Number} 
     * Returns:
     * {Pixel} 屏幕坐标。
     */
    lonlatToScreen: function(lon,lat,z){
    	var box = this.activexObj.AnalysisBox;
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var screenScript = eval(box.GeographyToScreenScript(lon, lat,z, 1));
		return new Geo.Pixel(parseFloat(screenScript[0]),parseFloat(screenScript[1]));
    },
     /**
     * APIMethod: lonlatToScreen
     * 屏幕像素转经纬度。
     * 
     * Parameters:
     * pX - {Number} 屏幕X坐标。
     * pX - {Number} 屏幕Y坐标。
     * Returns:
     * {LonLat} 经纬度。
     */
    screenToLonlat: function(pX,pY){
    	var box = this.activexObj.AnalysisBox;
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var geographyScript = eval(box.ScreenToGeographyScript(pX, pY,1));
		return new Geo.LonLat(parseFloat(geographyScript[0]),parseFloat(geographyScript[1]));
    },
    
    /**
     * APIMethod: getViewPortPxFromLonLat
     * 经纬度转屏幕像素.
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>}
     * 
     * Returns:
     * {<Geo.Pixel>} 屏幕坐标.
     */
    getViewPortPxFromLonLat: function (lonlat) {
        var box = this.activexObj.AnalysisBox;
        var geography = this.getGeography();
        var z = parseFloat(geography[2]);
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var screenScript = eval(box.GeographyToScreenScript(lonlat.lon, lonlat.lat,z, 1));
		return new Geo.Pixel(parseFloat(screenScript[0]),parseFloat(screenScript[1]));
    },
    
    /**
     * Method: getLonLatFromViewPortPx
     * 屏幕像素转经纬度.
     * 
     * Parameters:
     * viewPortPx - {<Geo.Pixel>}
     * 
     * Returns:
     * {<Geo.LonLat>} 经纬度.
     */
    getLonLatFromViewPortPx: function (viewPortPx) {
    	var box = this.activexObj.AnalysisBox;
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var geographyScript = eval(box.ScreenToGeographyScript(pX, pY,1));
		return new Geo.LonLat(parseFloat(geographyScript[0]),parseFloat(geographyScript[1]));
    },
    
    /**
     * APIMethod: getCenter
     * 获取当前中心点地理坐标。
     */
    getCenter: function(){
        var cameraLookAtScript = eval(this.activexObj.SceneBox.CameraLookAtScript);
    	return new Geo.LonLat(parseFloat(cameraLookAtScript[0]),parseFloat(cameraLookAtScript[1]));
    },   
    
    /**
     * APIMethod: getAltitude
     * 获取当前中心点海拨高度，单位为米。
     */    
    getAltitude: function(){
		return this.activexObj.SceneBox.MaxCameraAltitude;
    }, 
    
    /**
     * APIMethod: setTasService
     * 设置地形分析服务。
     * 
     * Parameters:
     * url - {String} 地形分析服务地址。
     */
    setTasService: function(url){
        var globe = this.activexObj;
        if (globe) {
            globe.SetTerrainAnalysisService(url);
        }
    },
	
	/**
	 * APIMethod: getExtent
	 * 获取三维视图下的视口范围。
	 * 
     * Returns:
     * {Geo.Bounds} 视口范围
	 */
	getExtent:function() {
		var center = this.getCenter();
    	var pixelSize = this.getSize();
    	var res = this.getResolution();
    	var lonlatSize = new Geo.Size(pixelSize.w * res, pixelSize.h * res);
    	return new Geo.Bounds(center.lon - lonlatSize.w/2, center.lat - lonlatSize.h/2,
                        center.lon + lonlatSize.w/2, center.lat + lonlatSize.h/2);

	},
	
	/**
     * APIMethod: getResolution
     * 获取当前地图的分辨率。
     * 
     * Returns:
     * {Float} 分辨率
     */
	getResolution : function(){
	    var currentZoom = this.getZoom();
	    var p360 = this.pyramid;
	    return p360.getResolutionForLevel(currentZoom);
	},
	
	/**
     * APIMethod: getResolutionForZoom
     * 根据地图级别获取分辨率。
     * 
     * Parameter:
     * zoom - {Float}
     * 
     * Returns:
     * {Float} 分辨率
     */
	getResolutionForZoom : function(zoom){
    	var p360 = this.pyramid;
    	return p360.getResolutionForLevel(zoom);
	},
	
	/**
     * APIMethod: getZoomForResolution
     * 根据地图分辨率获取地图级别。
     * 
     * Parameter:
     * resolution - {Float}
     * 
     * Returns:
     * {Integer} 地图级别
     */
	getZoomForResolution : function(resolution){
    	var p360 = this.pyramid;
    	return p360.getLevelForResolution(resolution);
	},
	
	/**
     * APIMethod: getSize
     * 获取三维控件尺寸大小。
     * 
     * Returns:
     * {<Geo.Size>} 控件尺寸
     */
	getSize : function(){
		var globe = this.activexObj;
	    if(globe){
	        return new Geo.Size(parseInt(globe.offsetWidth),
	                              parseInt(globe.offsetHeight));
	    }
	},
	
	/**
      * APIMethod: getScale
      * 获取当前地图的比例尺。
      * 
      * Returns:
      * {Float} 比例尺 
      */
    getScale: function () {
        var scale = null;
        var res = this.getResolution();
        var units = this.units;
        scale = OpenLayers.Util.getScaleFromResolution(res, units);
        return scale;
    },
	
//    /**
//     * APIMethod: setFocus
//     * 设置球体容器的焦点。参数flag为true表示焦点在三维球体上时，则容器获得焦点。
//     * 
//     * Parameter:
//     * flag - {Boolean}
//     */	 
//	setFocus: function(flag){
//		if(flag){
//			this.activexObj.onfocus = function(){
//				this.parentNode.onfocus = "true";
//			}
//		}else{
//			this.activexObj.onfocus = "true";
//		}
//	},
	
	/**
     * Method: destroy
     * 销毁地图对象。
     */
    destroy:function() {
        for(var i=(this.layers.length-1); i>=0; i--){
            this.removeLayer(this.layers[i]);
        }
		if(this.activexObj){
			this.div.removeChild(this.activexObj);
		}
		this.activexObj = null;
    },	
    
    /**
     * Method: setScenario
     * 连接服务（应有加新服务和老服务之分，目前未处理）。
     *
     * Parameters:
     * scenario - {String} 方案地址。
     */
    setScenario: function(scenario){
		/*
        if (scenario) {
            this.activexObj.ConnectServer(scenario, 1);
        }
        */
        if (scenario) {
	        if(arguments.length < 2) {
	        		this.activexObj.ConnectServer(scenario, 1);
	        	}else{
	        		this.activexObj.ConnectServer(arguments[0], arguments[1]);
	        }
        }		
    },
	
	//初始化光栅对象
	_initGeoRaster: function(){
		this._geoRaster = this.activexObj.CreateGeoRasterObj();
		//设置为1绘制的几何对象贴地		
		this._geoRaster.GeoRasterType = 1;
	},
	
	/**
     * APIMethod: viewExtentChanged
     * 当地图的视图范围改变时，运行该函数，函数可以覆写，使用方式：
     * 
     * (code)
     *  var map = new Geo.View3D.Map("simpleMap");
     *  map.viewExtentChanged = function(e){
     *  //Todo
     *  }
     * (end)
     */
	viewExtentChanged: function() {
			
	},
        
	//鼠标事件监听
    _mouseEventHandler: function(e){
//		if (e.MouseButton === 0 && e.MouseState === 3) {
//            return true;
//        }
		//e.Cancel=true;
//        for (var i = 0; i < this.handlers.length; i++) {
//            var handler = this.handlers[i];
//            if (handler instanceof Geo.View3D.Handler.KeybordDefaults) {
//                continue;
//            }
//            if (handler.active) {
//                handler.listener(e);
//            }
//        }
		//记录鼠标键按下位置，用以区分点击与拖拽行为
	    if(Geo.View3D.Event.MouseEvent.isMouseDown(e)){
	        Geo.View3D.Event.MouseEvent._mouseDownPos = {
	            x:e.ScreenX,
	            y:e.ScreenY
	        };
	    };
	
	    for (var i = 0; i < this.handlers.length; i++) {
	        var handler = this.handlers[i];
	        if (handler instanceof Geo.View3D.Handler.KeybordDefaults) {
	            continue;
	        }
	        if (handler.active) {
	            handler.listener(e);
	        }
	    };
	
	    //鼠标键抬起后清除位置记录
	    if(Geo.View3D.Event.MouseEvent.isMouseUp(e)){
	        Geo.View3D.Event.MouseEvent._mouseDownPos = null;
	    };
    },
	
	//键盘事件监听
    _keyEventHandler: function(e){
        for (var i = 0; i < this.handlers.length; i++) {
            var handler = this.handlers[i];
            if (handler instanceof Geo.View3D.Handler.KeybordDefaults || handler instanceof Geo.View3D.Handler.Keyboard) {
                if (handler.active) {
                    handler.listener(e);
                }
            }
        }
    },
    
    //量算事件监听
    _measureHandler: function(e){
        
    },
    
    //添加GLOBE瓦片服务
    _addGlobeTileService: function(url,version,type){
        var globe = this.activexObj;
		//创建吉奥瓦片图层，第二个参数是版本,第三个参数是数据源类型，6表示数据源来自于吉奥瓦片
		var geoGlobeTileLayer = globe.DataSourceBox.CreateDataLayer(url, version, type);
		//吉奥瓦片图层对象
		globe.LayerBox.UserGroupLayer.AddLayer(geoGlobeTileLayer);
		return geoGlobeTileLayer;
    },
    
    //删除GLOBE瓦片服务
    _removeLayerData: function(layer){
        var globe = this.activexObj;
        if (globe && layer) {
			globe.LayerBox.UserGroupLayer.RemoveLayer(layer);
        }
    },
    
     //获取点的坐标值
    _getPointGeometryArr:function (strPoints){
        var start = strPoints.indexOf("(") + 1;
		var end = strPoints.indexOf(")");
		var points = strPoints.slice(start,end).split(" ");
        return points;
    },
	
	//数字唯一标示计数器
	_i: 0,
	
	//生成数字唯一表示其
	_createUniqueID: function() {
		var i = this._i;
		i++;
		if(i == 1.7976931348623157E+308) {
			i = 0;
		}
		this._i = i;
		return i;
	},
	
    //在指定图层上绘制给定几何对象
    //featureid, rastLayer, strPoints, type, style
    _drawGeometry: function(options){
        var globe = this.activexObj;
        if (globe) {
            var drawBox = options.drawBox;
            var wkt = options.strPoints;
			var _style = OpenLayers.Util.extend({},Geo.Feature.Vector.style['default']);
			var style = OpenLayers.Util.extend(_style,options.style);
			options.feature.style = style;
            switch (options.type) {
                case 0:
					//如果要素样式中有外部图片的地址，则以标注方式创建点要素
					if(style.externalGraphic){
						var dynamicLayer = options.dynamicLayer;
						var fontColor = style.fontColor ? this._convertColorValue(style.fontColor) : 0x00ff0000;
						var fontSize = style.fontSize ? style.fontSize : 12;
						var fontFamily = style.fontFamily ? style.fontFamily : "宋体"
						var label = style.label?style.label : "";
						var lonlat = options.strPoints.split(" ");
//						var fid = this._createUniqueID();
//						options.feature.fid = fid;
						var id = options.feature.id;
						//var markpoint = globe.DrawBox.AddPOIDrawObject(fid, options.strPoints, "", label, style.externalGraphic, 12, 12, "12");
						var markpoint = globe.DrawBox.AddPOIDrawObject(id, options.strPoints, "", label, style.externalGraphic, fontColor, fontSize, fontFamily);
						dynamicLayer.AddPOI(markpoint);
						globe.DrawBox.RemoveObject(markpoint);
					} else {
						//创建三维geometry
						var geometry = globe.DrawBox.CreateGeometryObject(wkt, "", 1, 1);
						//geometry的唯一标示，删除要素需要使用这个唯一标示来进行删除
						geometry.Key = options.featureid;
						//0表示贴地,注意，如果设成成贴地必须要有矢量或影像图层作为底图才能显示贴地的要素
			            geometry.ZType = 0;
						geometry.PutViewRange(0, 36000000);
						//样式
						var rgb = style.fillColor.replace("#","");
						var argb = Geo.Util.ToArgb(rgb,parseInt(style.strokeOpacity * 255));
						//第一个参数是线的宽度，第二个参数是ARGB值
			            var style = globe.DrawBox.CreatePointSymbolObject(style.pointRadius, argb);
						drawBox.AddOrReplaceGeometry(geometry, style);	
//						var geometry = drawBox.CreateGeometryObject(wkt,null,1,1);
//						var pointSybol = drawBox.CreatePointSymbolObject(10, -65536);
//						geometry.ZType= 0;
//						geometry.Key = OpenLayers.Util.createUniqueID("point" + "_");
//						options.feature.geometry._3dGeometry = geometry;
//						var points = this._getPointGeometryArr(options.strPoints);
//						drawBox.AddDrawObject(geometry,pointSybol);				
					}
                    break;
                case 1:
					//第三个参数1表示point ,2表示lineString,3表示Ring,4表示Model，5表示 Box
					var geometry = globe.DrawBox.CreateGeometryObject(wkt, "", 2, 1);
		            geometry.Key = options.featureid;
		            geometry.ZType = 0;//0表示贴地， 1 表示贴近海平面， 2表示相对于地标，3表示绝对坐标(相对于海平面)
		            geometry.PutViewRange(0, 36000000);
					var rgb = style.strokeColor.replace("#","");
					var argb = Geo.Util.ToArgb(rgb,parseInt(style.strokeOpacity * 255));
					//第一个参数是线的宽度，第二个参数是ARGB值
		            var style = globe.DrawBox.CreateLineSymbolObject(style.strokeWidth, argb);
		            drawBox.AddOrReplaceGeometry(geometry, style);
	                break;
                case 2:
					var geometry = globe.DrawBox.CreateGeometryObject(wkt, "", 3, 1);
		            geometry.Key =  options.featureid;
		            geometry.ZType = 0; //0表示贴地， 1 表示贴近海平面， 2表示相对于地标(相对地面)，3表示绝对坐标(相对于海平面)
		            geometry.PutViewRange(0, 36000000);
					var rgb = style.strokeColor.replace("#","");
					//rgb和透明度转ARGB
					var argb = Geo.Util.ToArgb(rgb,parseInt(style.strokeOpacity * 255));
					//第一个参数是线的宽度，第二个参数是ARGB值
					var sym2 = globe.DrawBox.CreateLineSymbolObject(style.strokeWidth, argb);
					//面的填充色
					var fillrgb = style.fillColor.replace("#","");
					var fillargb = Geo.Util.ToArgb(fillrgb,parseInt(style.fillOpacity * 255));
            		var style = globe.DrawBox.CreateFillSymbolObject(fillargb, sym2);
		            drawBox.AddOrReplaceGeometry(geometry, style);
                    break;
                default:
                    return;            
			}
			
        };
    },
    
    _delGeometryByName: function(geometry,drawBox){
		//根据key删除要素
		drawBox.DeleteGeometry(geometry);
    },
	
	_delBookMark: function(geometry,drawBox){
		drawBox.RemovePOI(geometry);            
	},
            
    //删除矢量图层对象
    _removeVectorLayerData: function(ILayerWrapper){
        var globe = this.activexObj;
        if(globe){
    		globe.GetSceneGroup().RemoveLayer(ILayerWrapper);
        }
    },
    
    //上移图层
	/*
	 * // 图层移动方式的枚举变量
	_enumMoveLayerType: {
		MOVE_TO_TOP:0, //移动图层到顶层显示
		MOVE_TO_BOTTOM:1, //移动图层到底层显示
		MOVE_UP:2, //向上移动一层
		MOVE_DOWN:3 //向下移动一层
	},
	 */
    _moveLayerUp:function(layerData){
        var globe = this.activexObj;
        if (globe) {
            globe.LayerBox.UserGroupLayer.MoveLayer(layerData, this._enumMoveLayerType["MOVE_UP"]);
        }
    },
    
    //下移图层
    _moveLayerDown:function(layerData){
        var globe = this.activexObj;
        if (globe) {
            globe.LayerBox.UserGroupLayer.MoveLayer(layerData, this._enumMoveLayerType["MOVE_DOWN"]);
        }
    },
    
    //跳转到指定图层
    _gotoLayer: function(layerData){
        var globe = this.activexObj;
        if (layerData && globe) {
			var bounds = this._createLayerOperate(this._enumLayerOperateType["layerBounds"], layerData, {});
			this.zoomToExtent(bounds,true);
        };
    },

    //设置图层透明度
    //layer为要调整透明度的图层对象（之所以用图层对象而不用图层名称，是为了在需要时能调整无名图层的透明度）
    //三维插件透明度的值的范围是0-255
    _setLayerOpacity: function(layerData, opacity){
        var globe = this.activexObj;
        if (globe) {
			this._createLayerOperate(this._enumLayerOperateType["opacity"], layerData, {opacity : opacity});
        }
    },
	
	_setLayerVisibility: function(layerData,display) {
		 var globe = this.activexObj;
        if (globe) {
			this._createLayerOperate(this._enumLayerOperateType["visible"], layerData, {visible : display});
        }
	},

	//添加WMTS服务
    _addWMTSService: function(url, layerName){
    
        var globe = this.activexObj;
        if (globe) {
            var wmsObj = globe.GetLayerBox();
            if(null == url || undefined == url){
                url = "";
			}
            var layerBox = wmsObj.GetWmtsInfo(url);//传入服务地址
            var ILayerWrapperArr = [];
            var i = layerBox.GetCount(); //得到图层的个数
            for (var j = 0; j < i; j++) {
                var layerinfo = layerBox.GetResByIndex(j);//得到里面的一个图层
                // 根据图层名称和传进参数的图层名称相同则加载至场景中
                if (!layerName || layerinfo.Name == layerName) {
                    var layerdata = wmsObj.AddOneWmtsLayer(layerinfo, "");//添加一个图层到场景中
                    globe.GetCameraWrapper().GoToLayer(layerdata);//定位到图层
                    ILayerWrapperArr.push(layerdata);
                }
            }
            return ILayerWrapperArr;
        }
    },
    
	//添加WMS服务
    _addWMSService: function(url, layerName){
		var layerArr = layerName.split(",");
        if (!layerName) {
            return;
        };
        var globe = this.activexObj;
        if (globe) {
            var wmsObj = globe.GetOGCBox();//得到IWmsConMng对象
            if(null == url || undefined == url){
                url = "";
			}
            //设置wms服务地址并返回图层信息
            var layerBox = wmsObj.GetWmsLayersInfo(url);
            
            //遍历每一个图层信息  wmsObj.AddWmsInfoData();
			var ILayerWrapperArr = [];
            for (var j = 0,len = layerBox.GetWmsInfoCount(); j < len; j++) {
                var layerinfo = layerBox.GetWmsInfoByIndex(j);
                for(var m = 0;m < layerArr.length; m++) {
					if (layerinfo.Name == layerArr[m]) {
	                    var ILayerWrapper = wmsObj.ConSelecedLayers(false, 200, 1, 20, true, 255, "image/png", layerinfo);
	                    ILayerWrapper.Name = layerinfo.Name;
	                    globe.GetLayerBox().AddLayerData(ILayerWrapper);
						ILayerWrapperArr.push(ILayerWrapper);
                	};
				}
                
            };
			return ILayerWrapperArr;
        };
    },
    
	//添加WCS服务
    _addWCSService: function(url){
        var globe = this.activexObj;
		var ILayerWrapper = null;
        if (globe) {
			if(null == url || undefined == url){
                url = "";
			}
            var ILayerBox = globe.GetOGCBox().ConnectWCS(url);
			ILayerWrapper= ILayerBox.GetLayerByIndex(0);
        };
        return ILayerWrapper;
    },
	
	//添加矢量图层
	_addVectorLayer:function(){
		var activexObj =  this.activexObj;
		//创建矢量图层对象 GeometryLayer = 0; DynamicLayer = 1; ElementLayer = 2
		var geometryLayer = activexObj.ObjectFactory.CreateObject(0);
		//将矢量图层添加到地图
		activexObj.LayerBox.UserGroupLayer.AddLayer(geometryLayer);
		return geometryLayer;
	},
	
	_addDynamicLayer: function() {
		//创建矢量图层对象
		var activexObj = this.activexObj;
		var dynamicLayer = activexObj.ObjectFactory.CreateObject(1);
		//将矢量图层添加到地图
		activexObj.LayerBox.UserGroupLayer.AddLayer(dynamicLayer);
		return dynamicLayer;
	},
	
	//添加自定义图层
	_addCustomLayer: function(strJson){
		//创建自定义图层
		var activexObj = this.activexObj;
		var customLayer = activexObj.DataSourceBox.CreateLayerFromJson(strJson);
		//将自定义图层加到地图
		activexObj.LayerBox.UserGroupLayer.AddLayer(customLayer);
		return customLayer;
	},
	
	//转换颜色字符串为十进制
	_convertColorValue: function(webcolor){
		return new Number("0x00" + webcolor.replace("#",""));
	},
	
	//图层操作枚举
	_enumLayerOperateType: {
		"visible" : 1,
	//	"type" : 3,
		"opacity" : 2,
		"object" : 4,
		"layerBounds" : 3,//获取图层范围
		"wmsLayerinfo" : 6,
		"wmtsLayerinfo" : 7
		
	},
	
	/*
	 * 对图层相关属性进行操作
	 * 
	 */
	_createLayerOperate: function(number,layer,options) {
		var layerOperate = this.activexObj.LayerBox.CreateLayerOperate(layer);
		switch(number) {
			case this._enumLayerOperateType["visible"]:
			//	layerOperate.LayerProperty(number) = options.visible;
				layerOperate.ChangeLayerProperty(number, options.visible);
				break;
			case this._enumLayerOperateType["opacity"]:
//				layerOperate.LayerProperty(number) = parseInt(options.opacity * 255);
				layerOperate.ChangeLayerProperty(number, parseInt(options.opacity * 255));
			break;
			case this._enumLayerOperateType["layerBounds"]:
				var bbox = layerOperate.LayerProperty(number);
				bbox = eval(bbox);
				var bounds = new Geo.Bounds(bbox[2],bbox[1],bbox[3],bbox[0]);
				return bounds;
			break;
		}
		
	},	
	
    /**
     * Method: unloadDestroy
     * 窗口关闭时销毁地图对象的方法
     */	 
	unloadDestroy: function(){
	},
	
	/**
     * APIMethod: isSuspend
     * 设置是否开启球体刷新线程。
     * 
     * Parameters:
     * isSuspend - {Boolean} true开启，false关闭。
     */
	isSuspend: function(isSuspend){
		this.activexObj.Suspend = isSuspend;
	},
	
	/**
     * APIMethod: setFocusAlways
     * 设置是否开启抢占焦点。
     * 
     * Parameters:
     * isOpen - {Boolean}，true开启，false关闭。
     */
	setFocusAlways: function(isOpen){
		this.activexObj.ConfigBox.SaveConfigItem(26,isOpen);
	},

    CLASS_NAME: "Geo.View3D.Map"

});

//缺省海拨高度(米)
Geo.View3D.Map.DEFAULT_ALT = 2500000;

Geo.View3D.Map.getActivex = function(id){
    var version = "";
    var activexObj = null;
    try {
        //初始化插件
        activexObj = document.createElement("object");
        activexObj.classid = "CLSID:535CEBE1-7D19-4203-AA3B-B1B40167BF86";
        activexObj.width = "100%";
        activexObj.height = "100%"; 
        if(id){
            activexObj.id = id;
        }
        version = activexObj.Version;
    } 
    catch (e) {
    }
    return {
        obj:activexObj,
        version:version
    };
};

Geo.View3D.Map.getActivexVersion = function(){
	if(Geo.View3D.Map.activexVersion){
		return Geo.View3D.Map.activexVersion;
	}
	
    var GeoControlVersion;
    try{
        GeoControlVersion = new ActiveXObject("GeoSpace3D.ControlVersion.1");
		Geo.View3D.Map.activexVersion = GeoControlVersion.Version;
    }catch(e){
        return null;
    }
    return Geo.View3D.Map.activexVersion;
};

Geo.View3D.Map.ACTIVEX_DEFAULT_VERSION = "1.3.1.55185";

//图层级别换算成高度
Geo.View3D.Map.zoomMaping = [];
Geo.View3D.Map.zoomMaping[0] = 23000000;
Geo.View3D.Map.zoomMaping[1] = 15000000;
Geo.View3D.Map.zoomMaping[2] = 10000000;
Geo.View3D.Map.zoomMaping[3] = 9000000;
Geo.View3D.Map.zoomMaping[4] = 5916173;
Geo.View3D.Map.zoomMaping[5] = 2958087;
Geo.View3D.Map.zoomMaping[6] = 1479044;
Geo.View3D.Map.zoomMaping[7] = 739522;
Geo.View3D.Map.zoomMaping[8] = 369761;
Geo.View3D.Map.zoomMaping[9] = 184881;
Geo.View3D.Map.zoomMaping[10] = 92441;
Geo.View3D.Map.zoomMaping[11] = 46221;
Geo.View3D.Map.zoomMaping[12] = 23111;
Geo.View3D.Map.zoomMaping[13] = 11556;
Geo.View3D.Map.zoomMaping[14] = 5778;
Geo.View3D.Map.zoomMaping[15] = 2889;
Geo.View3D.Map.zoomMaping[16] = 1445;
Geo.View3D.Map.zoomMaping[17] = 723;
Geo.View3D.Map.zoomMaping[18] = 362;
Geo.View3D.Map.zoomMaping[19] = 181;
Geo.View3D.Map.zoomMaping[20] = 1;

/**
 * APIMethod: getZoomfromAlt
 * 根据高度返回金字塔级别。
 * 
 * Parameters:
 * alt - {Number} 海拔高度
 * Returns:
 * {Number} 金字塔级别 
 */
Geo.View3D.Map.getZoomfromAlt = function(alt){
    for (var i = 0; i < Geo.View3D.Map.zoomMaping.length; i++) {
    	// 如果当前高度大于等于级别为0的高度，则返回0。
    	if (alt >= Geo.View3D.Map.zoomMaping[0]) {
       		return i;
    	}
    	// 如果当前高度大于等于当前级别的高度并且小于前一级别换算的高度，则返回当前级别。
    	if (alt >= Geo.View3D.Map.zoomMaping[i] && i != 0 && alt < Geo.View3D.Map.zoomMaping[i - 1]) {
        	return i;
    	}
    	// 如果当前高度小于等于级别为20的高度，则返回20。
    	if (alt < Geo.View3D.Map.zoomMaping[Geo.View3D.Map.zoomMaping.length - 1]) {
        	return Geo.View3D.Map.zoomMaping.length - 1;
    	}
	}
};

/**
 * APIMethod: getAltfromZoom
 * 根据金字塔级别返回对应的三维海拔高度。
 * 
 * Parameters:
 * zoom - {Number} 金字塔级别
 * Returns:
 * {Number} 海拔高度
 */
Geo.View3D.Map.getAltfromZoom = function(zoom){
    var z = Geo.View3D.Map.zoomMaping[zoom];
    return z ? z : 0;
};

//根据金字塔级别返回对应的三维海拔高度
Geo.View3D.Map.getZfromLevel = Geo.View3D.Map.getAltfromZoom;

/**
 * APIProperty: activexErrorInfo
 * {String} 缺省三维插件错误提示信息。
 */	    
// Geo.View3D.Map.activexErrorInfo = "对不起，您电脑上未安装三维视图所需插件或插件版本不适合本系统，请重新安装适当版本后重新刷新本页面。";
Geo.View3D.Map.activexErrorInfo = "";

//为修复三维定位在某些地点，因海拨高度而撞地，限定到一定级别
Geo.View3D.Map.ZOOMTOEXTENT_MINILEVEL = 17;
/**
 * Class: Geo.View3D.Layer
 * 三维视图下的图层基类。本类不直接使用,需要由子类继承。
 */
Geo.View3D.Layer = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,

    /** 
     * APIProperty: name
     * {String} 图层名称。
     */
    name: null,
	
    /**
     * APIProperty: opacity
     * {Float} 图层的透明度，值在0.0与1.0之间。
     */
    opacity: null,
	
    /**
     * APIProperty: map
     * {Geo.View3D.Map} 图层所在的地图对象。
     */
    map: null,
	
    /** 
     * APIProperty: displayInLayerSwitcher
     * {Boolean} 图层名称是否在图层列表中显示,默认值为true。
     */
    displayInLayerSwitcher: true,
	
	/**
	 * APIProperty: isOnTop
	 * {Boolean} 图层是否在图层列表中置顶，默认值为false。
	 */
	isOnTop: false,
	
	/**
     * APIProperty: events
     * {<Geo.Events>} 事件对象。
     */
    events: null,	

    /**
     * APIProperty: visibility
     * {Boolean} 图层是否在地图中可见，默认值为true。
     */
    visibility: true,

    /**
     * Constant: EVENT_TYPES
     * {Array(String)} 图层对象所支持的事件类型。
     * 
     * 本对象支持以下事件类型：
     * visibilitychanged - 可视状态改变事件。
     */
    EVENT_TYPES: ["visibilitychanged"],
	
	/**
	 * Constructor: Geo.View3D.Layer
	 * Geo.View3D.Layer构造函数。
	 *
	 * Parameters:
	 * name - {String} 图层名称。
	 * options - {Object} 选项。
	 */	 
    initialize: function(name, options) {
		
		this.addOptions(options);
		
        this.name = name;
        
        if (this.id == null) {
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
			
			this.events = new OpenLayers.Events(this, this.div, 
                                                this.EVENT_TYPES);
            if(this.eventListeners instanceof Object) {
                this.events.on(this.eventListeners);
            }
        }
        
        this.opacity = 1.0;

    },

	/**
	 * Method: setMap
	 * 将图层关联到地图对象，如果该图层已经关联到地图对象了则不做任何操作。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>)} 地图对象。
	 */	
    setMap: function(map) {
        if (this.map != null) {
            return;
        }
        this.map = map;
		var activexObj = this.map.activexObj;
		//通过DataSourceBox可以获得图层对象
		this.dataSourceBox = activexObj.DataSourceBox;
		//通过LayerBox可以将图层添加到地图，也可以实现图层的显示隐藏删除等操作
		this.layerBox = activexObj.LayerBox;
    },

	/**
	 * APIMethod: removeMap
	 * 解除图层与地图对象的关联。
	 */	    
    removeMap: function() {
        //此方法由子类覆盖
    },

	/**
	 * APIMethod: getVisibility
	 * 获取图层可视状态。
	 * 
     * Returns:
     * {Boolean} 图层可视状态。
	 */	
    getVisibility: function() {
        return this.visibility;
    },

    /**
     * APIMethod: setVisibility
     * 设置图层是否可视。
     * 
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
     */
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
            this.visibility = visibility;
            this.display(visibility);
        }
    },

    /**
     * Method: display
     * 显示或隐藏图层，此方法由子类覆盖。
     * 
	 * Parameters:
	 * display - {Boolean} 是否可见 。
     */
    display: function(display) {
        //此方法由子类覆盖
    },
	
    /**
     * APIMethod: setOpacity
     * 仅对透明度的值进行判断，如果与当前透明度相同则返回。
     * 
	 * Parameters:
	 * opacity - {Float} 
     */
    setOpacity: function(opacity) {
        if (opacity === this.opacity) {
            return;
        }
    },
	
    /**
     * APIMethod: getOptions
     * 获取图层构造参数。
     * 
     * Returns:
     * {Object} 图层构造参数。
     */
    getOptions: function() {
        var options = {};
        for(var o in this.options) {
            options[o] = this[o];
        }
        return options;
    },
	
    /**
     * APIMethod: addOptions
     * 添加图层构造参数。
     */
    addOptions: function (newOptions) {

        if (this.options == null) {
            this.options = {};
        }

        // update our copy for clone
        OpenLayers.Util.extend(this.options, newOptions);

        // add new options to this
        OpenLayers.Util.extend(this, newOptions);

    },
	
    /**
     * APIMethod: destroy
     * 销毁图层。
     */
	destroy: function(){
        this.map = null;
        this.name = null;
        this.dataSourceBox = null;
		this.layerBox = null;
        this.options = null;

        if (this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
        }
        this.eventListeners = null;
        this.events = null;
	},
	
    CLASS_NAME: "Geo.View3D.Layer"
});
﻿/**
 * Class: Geo.View3D.BaseLayerGroup
 * 三维视图的底图图层组对象，可以将多个图层对象组合在一起，进行统一的加载和卸载操作。该图层组中的图层
 * 将做为地图中的底图置于所有图层的最下方。
 */
Geo.View3D.BaseLayerGroup = Geo.Class({

    /**
     * APIProperty: id
     * ｛String｝唯一标识符。
     */
    id: null,
    
    /**
     * APIProperty: layers
     * {Array} 图层集合。
     */
    layers: null,
    
    /**
     * APIProperty: map
     * 图层所在地图对象的引用。
     */
    map: null,
    
    /**
     * Constructor: Geo.View3D.BaseLayerGroup
     * Geo.View3D.LayerGroup构造函数。
     * 
     * Parameters:
     * options - {Object} 相关选项设置
     * 
     * 示例代码：
     * 
     * (code)
     * var vectorGroup = new Geo.View3D.BaseLayerGroup({
     *      layers: [
     *          new Geo.View3D.Layer.GlobeTile("全球1:100万矢量底图", "http://tile0.tianditu.com/services/A0512_EMap"), 
     *          new Geo.View3D.Layer.GlobeTile("全球1:100万矢量注记", "http://tile0.tianditu.com/services/AB0512_Anno")
     *      ]
     *  });
     * (end)
     */
    initialize: function(options){
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        OpenLayers.Util.extend(this, options);
        if (!this.layers) 
            this.layers = [];
    },
    
    /**
     * APIMethod: setMap
     * 将图层组关联到地图
     *
     * Parameters:
     * map - {OpenLayers.Map} 设置地图对象
     */
    setMap: function(map){
        if (map && !this.map) {
            this.map = map;
            this.map.addLayers(this.layers);
        }
    },
    
    CLASS_NAME: "Geo.View3D.BaseLayerGroup"

});

Geo.View3D.BaseLayerGroup.getTianDiTuGroup = function(type){
    
    var typeMapping = {
        "img":[
            new Geo.View3D.Layer.GlobeTile("全球影像底图(2-10)", "http://tile0.tianditu.com/services/sbsm0210"),
            new Geo.View3D.Layer.GlobeTile("全球影像注记(2-10)", "http://tile0.tianditu.com/services/A0104_ImgAnnoE"),
            new Geo.View3D.Layer.GlobeTile("全国影像(14)", "http://tile0.tianditu.com/services/eastdawnall"),
            new Geo.View3D.Layer.GlobeTile("全球影像(15-18)", "http://tile0.tianditu.com/services/sbsm1518"),
            new Geo.View3D.Layer.GlobeTile("全国影像(13)", "http://tile0.tianditu.com/services/e13"),
            new Geo.View3D.Layer.GlobeTile("全国影像(12)", "http://tile0.tianditu.com/services/e12"),
            new Geo.View3D.Layer.GlobeTile("全国影像(11)", "http://tile0.tianditu.com/services/e11"),
            new Geo.View3D.Layer.GlobeTile("全国影像注记(11-14)", "http://tile0.tianditu.com/services/B0530_eImgAnno"),
            new Geo.View3D.Layer.GlobeTile("全国影像注记(15-18)", "http://tile0.tianditu.com/services/siweiAnno68")
        ],
        "dlg":[
            new Geo.View3D.Layer.GlobeTile("全国矢量(2-10)", "http://tile0.tianditu.com/services/A0512_EMap"),
            new Geo.View3D.Layer.GlobeTile("全国矢量注记(2-10)", "http://tile0.tianditu.com/services/AB0512_Anno"),
            new Geo.View3D.Layer.GlobeTile("全国矢量(11-12)", "http://tile0.tianditu.com/services/B0627_EMap1112"),
            new Geo.View3D.Layer.GlobeTile("全国矢量(13-18)", "http://tile0.tianditu.com/services/siwei0608")
        ]
    };
    
    var layers = typeMapping[type];
    if(layers){
        return new Geo.View3D.BaseLayerGroup({layers: layers});
    }
    return null;
}﻿//此类已被废弃，推荐使用Geo.View3D.BaseLayerGroup代替
Geo.View3D.LayerGroup = Geo.View3D.BaseLayerGroup;﻿/**
 * Class: Geo.View3D.Layer.ArcgisRest
 * 三维视图下的ArcGis REST服务图层对象。在三维视图下，添加ArcGis REST服务，请使用本类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.ArcgisRest = Geo.Class(Geo.View3D.Layer,{
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
	
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
    
    _layerData: null,
    
	/**
     * Constructor: Geo.View3D.Layer.ArcgisRest
     * 构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 选项。
  	 * 例如：
  	 * (code)
	 * 	  var layer = new Geo.View3D.Layer.ArcgisRest("arcgisRest", 
	 * 	  "http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/export",
	 *     {
	 *      	format:"png",//请求的图片格式，默认：jpeg,必填
	 *      	transparent: "TRUE"//请求的瓦片背景区域是否透明,默认：TRUE	
	 *     },
	 *     {	
	 *      	//支持级别，分辨率，比例的用法，任一选择
	 *      	topLevel:0,//顶层级别，默认：0
	 *      	bottomLevel:20,//底层级别，默认：20
	 *       	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *      	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *       	width:"256",//图片宽度，默认：256
	 *       	height:"256",//图片高度，默认：256
	 *       	//图层范围,默认为全球范围：-180,-90,180,90,必填
	 *       	maxExtent:Geo.Bounds.fromString("73.446960,6.318641,135.085830,53.557926")	
	 *		    //支持分辨率
	 *		    //maxResolution :0.000005364418029785156,//最大分辨率
	 *  		//minResolution :0.703125//最小分辨率
	 *   		//支持比例尺
	 *   		//minScale : 2.958293554545656E8,
	 *   		//maxScale : 2256.998866688275
	 *     });。
	 * (end)           
     */	      
    initialize: function(name, url, params, options) {
       //与二维一致的新的三维图层加载方式
    	params = params || {};
    	params.pyramid = params.pyramid ? params.pyramid : new Geo.Pyramid();
//    	if(typeof params.projection == "string") {
//            this.projection = new Geo.Projection(params.projection);
//        }
//        if(this.projection && this.projection.getUnits()) {
//            this.units = this.projection.getUnits();
//        }
		if(options.maxResolution){
			params.bottomLevel = params.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			params.topLevel = params.pyramid.getLevelForResolution(options.minResolution);
		}
		
		if(options.maxScale){
			params.bottomLevel = params.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			params.topLevel = params.pyramid.getLevelForScale(options.minScale);
		}
    	var args = [name, url, options];
    	this.params = params;
        Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, args);
    },

	/**
	 * APIMethod: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    setMap: function(map) {
		this._createLayerFromJson(map);
	},

	//自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      request: "GetTile",
	      styles: "",
	      format: "png"
	     };
	    /**所有的服务的公共参数**/ 
	    //默认为影像：ImageDataType，矢量：VectorDataType，模型数据：ModelDataType， Lod模型数据：LodModelDataType，POI数据：POIDataType
	    var dataType= this.params.dataType ? this.params.dataType : "ImageDataType";    
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.params.opacity >= 0 ? this.params.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.params.topLevel ? this.params.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.params.bottomLevel ? this.params.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的图片格式
	    var format = this.params.format ? this.params.format : DEFAULT_PARAMS.format;
	    //请求的瓦片背景区域是否透明,默认为TURE
	    var transparent = this.params.transparent ? this.params.transparent : "TRUE";
	    //请求的图片宽度
	    var width = this.params.width ? this.params.width : 256;
	    //请求的图片高度
	    var height = this.params.height ? this.params.height : 256;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"Customer",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+ url +
		'?dpi=96&transparent='+transparent+'&format='+format+'&bbox=${TileXMin}%2C${TileYMin}%2C${TileXMax}%2C${TileYMax}' +
		'&size='+width+'%2C'+height+'&f=image';
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;
    },
	
	/**
	 * APIMethod: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */	    
    removeMap: function() {
        var map = this.map;
        if(map){
            map._removeLayerData(this._layerData);
			this._layerData = null;
        }
		this.map = null;
    },


	/**
	 * APIMethod: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见
	 */	
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
            this.visibility = visibility;
            this.display(visibility);
        }
    },

	/**
	 * APIMethod: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
        if(display != this._layerData.LayerData.Visible){
            this._layerData.LayerData.Visible = display;
        }
    },

	/**
	 * APIMethod: setOpacity
	 * 设置图层不透明度，数值在0-1.0之间。
	 *
	 * Parameters:
	 * opacity - {Float} 透明度。
	 */	
    setOpacity: function(opacity) {
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if(map){
            map._setLayerOpacity(this._layerData,opacity);
            this.opacity = opacity;
        }
    },

	/**
	 * APIMethod: gotoCenter
	 * 定位到图层中心点。
	 * 图层定位的方法是通过图层的范围大小，计算一个相机高度，来实现定位的。 
	 * 在实际应用过程中，存在通过范围定位的高度换算成金字塔层级会高于/低于当前瓦片显示的金字塔范围。 
	 * 有可能存在定位准了，但是相机高度不对，有时候需要往下缩小或者往上放大才能看到图层的现象。 
	 */	    
    gotoCenter:function(){
        var map = this.map;
        if(map){
            map._gotoLayer(this._layerData);
        }
    },
	 	
    CLASS_NAME: "Geo.View3D.Layer.ArcgisRest"
});/**
 * Class: Geo.View3D.Layer.GlobeTile
 * 三维视图下的吉奥瓦片服务图层对象。在三维视图下，添加瓦片服务，请使用本类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.GlobeTile = Geo.Class(Geo.View3D.Layer,{
    
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
			
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
	
	//吉奥瓦片图层类型
	_LAYER_TYPE_GLOBETILE:6,
	
    //私有图层对象
    _layerData: null,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	/**
	 * Constructor: Geo.View3D.Layer.GlobeTile
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var globeTile = new Geo.View3D.Layer.GlobeTile("globeTile", "http://192.168.40.69:9010/dlgtile0319/services/tile",
     *       	{
     *       		topLevel:1,//顶层级别，默认:0
	 *				bottomLevel:20,//底层级别，默认:20
	 *				maxExtent:Geo.Bounds.fromString("45,0,180,90"),//图层范围,默认范围:-180,-90,180,90，必填
     *       		opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
     *       		projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
     *       		version:"5.0",//请求的服务版本，默认：2.0.0
	 *				//支持分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//支持比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275      
     *       	});
     * (end)
	 */		      
    initialize: function(name, url, options) {
        //判断用户使用api版本
    	if(arguments.length < 3){
    		this._oldLoad = true;
    		Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
    	options = options || {};
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },

	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
	setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._layerData = map._addGlobeTileService(this.url,"",this._LAYER_TYPE_GLOBETILE);
    },
    
     //自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "2.0.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    /**所有的服务的公共参数**/ 
	    //默认为影像：ImageDataType，矢量：VectorDataType，模型数据：ModelDataType， Lod模型数据：LodModelDataType，POI数据：POIDataType
	    var dataType= this.options.dataType ? this.options.dataType : "ImageDataType";    
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号，version版本为2.1的暂时不支持
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"GeoTile",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+ url+'",' +
		'"Version":"'+ version;
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;	
    },

	/**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */	    
    removeMap: function() {
        var map = this.map;
        if(map){
            map._removeLayerData(this._layerData);
        }
		this.map = null;
    },


	/**
	 * Method: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
	 */	
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
        	this.visibility = visibility;
            this.display(visibility);
        }
    },

	/**
	 * Method: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
		if(!this._layerData){
			return;
		}
        if(display != this._layerData.Visible){
			var map = this.map;
			map._setLayerVisibility(this._layerData,display);
        }
    },

	/**
	 * Method: setOpacity
	 * 设置图层不透明度，数值在0-1.0之间。
	 *
	 * Parameters:
	 * opacity - {Float} 透明度。
	 */	
    setOpacity: function(opacity) {
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if(map){
            if (this._layerData) {
                map._setLayerOpacity(this._layerData,opacity);
            }
            this.opacity = opacity;
        }
    },

	/**
	 * Method: gotoCenter
	 * 定位到图层中心点。
	 * 图层定位的方法是通过图层的范围大小，计算一个相机高度，来实现定位的。 
	 * 在实际应用过程中，存在通过范围定位的高度换算成金字塔层级会高于/低于当前瓦片显示的金字塔范围。 
	 * 有可能存在定位准了，但是相机高度不对，有时候需要往下缩小或者往上放大才能看到图层的现象。 
	 */	    
    gotoCenter:function(){
        var map = this.map;
        if(map){
            if (this._layerData) {
                map._gotoLayer(this._layerData);
            }
        }
    },
	 	
    CLASS_NAME: "Geo.View3D.Layer.GlobeTile"
});/**
 * Class: Geo.View3D.Layer.Shape
 * 本地SHAPE文件图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Shape = Geo.Class(Geo.View3D.Layer, {
	
	_LAYER_TYPE_Shape : 3,	
	
    /**
     * Constructor: Geo.View3D.Layer.Shape
     * 构造函数。
     *
     * Parameters:
     * name - {String} 图层名称。
     * url - {String} 文件地址。
     * options - {Object} 选项。
     */
    initialize: function(name, url, options){
        Geo.View3D.Layer.prototype.initialize.apply(this, [name, options]);
        this.url = url;
    },
	
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {Geo.View3D.Map} 三维视图对象。
	 */	
    setMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
        this._layerData = this._addShpDate(this.url);
    },
    
    //添加本地数据
    _addShpDate: function(path){
		var shapeLayer = this.dataSourceBox.CreateDataLayer(
                            this.url, null,
                          0);
		this.layerBox.UserGroupLayer.AddLayer(shapeLayer);
		this._layerData = shapeLayer;
    },
    
    CLASS_NAME: "Geo.View3D.Layer.Shape"
});
/**
 * Class: Geo.View3D.Layer.Terrain
 * 三维地形图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.Terrain = Geo.Class(Geo.View3D.Layer.GlobeTile, {
	/**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
    
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
	
	//私有图层对象
    _layerData: null,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
	/**
	 * Constructor: Geo.View3D.Layer.Terrain
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var globeTile = new Geo.View3D.Layer.Terrain("Terrain", 
	 * 			"http://192.168.40.69:9010/dlgtile0319/services/tile",
     *       	{
     *       		topLevel:1,//顶层级别，默认:0
	 *				bottomLevel:20,//底层级别，默认:20
	 *				maxExtent:Geo.Bounds(45,0,180,90),//图层范围,默认范围:-180,-90,180,90，必填
	 *              demDataType:"int16" // 地形数据类型，必填
     *       	});
     * (end)
	 */		      
    initialize: function(name, url, options) {
        //判断用户使用api版本
    	if(arguments.length < 3){
    		this._oldLoad = true;
    		Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
    	options = options || {};
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },	
			
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    setMap: function(map) {
		if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
	
	/**
	 * Method: _oldSetMap
	 * 老版本，将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		var TerrainDataset=this.dataSourceBox.CreateTerrainDataset(this.url);
	   	this.dataSourceBox.AddTerrainDataset(TerrainDataset);
		this._layerData = TerrainDataset;
    },	
	
	/**
	 * Method: _createLayerFromJson
	 * 自定义图层方式
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "2.0.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
		var demDataType = this.options.demDataType ? this.options.demDataType : "int16";
	    //服务地址
	    var url = this.url;
	    //拼图层请求串
	    var layerJson = '{'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"DEMDataType":"'+demDataType+'",'+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"ServerUrl":"'+ url;
		layerJson +='"}';
	//	alert(demDataType);
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateTerrainDatasetFromJson(layerJson);
	    this.dataSourceBox.AddTerrainDataset(layer);
	    this._layerData = layer;	
    },	
    
    /**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */
    removeMap: function() {
		if (!this._layerData){
			return;
		}else{
			this._removeMap();
		}
    },
	
    /**
	 * Method: _removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */
    _removeMap: function() {
		if(this._oldLoad){
			//老版本的删除方法
	    	var map = this.map;
	    	if(map){
	    		var globe = map.activexObj;
	    		var camera = globe.Camera;
	    		var terrainAccessor	= camera.TerrainAccessor;
	    		terrainAccessor.remove(this._layerData);
	    	}
	    	this.map = null;
    	}else{
    		//新版本的删除方法
    		this.dataSourceBox.RemoveTerrainDataset(this._layerData);
    	}    	
    },
    
    /**
	 * Method: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
	 */	
    setVisibility: function(visibility) {
        this.visibility = visibility;
        this.display(visibility);   	 
    },    
	
    /**
	 * Method: display
	 * 显示或者隐藏图层
	 * 
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
		if (!this._layerData){
			return;
		}else{
			this._display(display);
		}
    },
	
    /**
	 * Method: _display
	 * 显示或者隐藏图层
	 * 
	 * Parameters:
	 * display - {Boolean} 
	 */	
    _display: function(display) {
		this.map.activexObj.ConfigBox.SaveConfigItem(19, display);
		return;
    },	
	
    CLASS_NAME: "Geo.View3D.Layer.Terrain"
});
/**
 * Class: Geo.View3D.Layer.Vector
 * 三维视图下的矢量图层类。本类主要用于在三维地图上对矢量要素(点,线,面)进行操作。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Vector = Geo.Class(Geo.View3D.Layer,{
    
	//三维插件用的矢量图层。
  	_geometryLayer:null,
	
	//三维插件用的标注图层。
	_dynamicLayer: null,
    
    
    /** 
     * APIProperty: features
     * {Array(<Geo.Feature.Vector>)} 图层上所有要素。
     */	
    features: null,
    
    /** 
     * APIProperty: selectedFeatures
     * {Array(<Geo.Feature.Vector>)}  被选择的要素。
     */	
	selectedFeatures: null,

    /** 
     * APIProperty: style
     * {Object} 图层缺省样式。
     */
    style: null,
	
    /**
     * Property: styleMap
     * {<Geo.StyleMap>}
     */
    styleMap: null,

    /**
     * APIProperty: EVENT_TYPES
     * {Array(String)} 对象所支持的事件类型，使用以下方式可以为特定事件注册一个事件监听器。
     * (code)
     * layer.events.register(type, obj, listener);
     * (end)
     *
     */
    EVENT_TYPES: ["beforefeatureadded", "beforefeaturesadded",
                  "featureadded", "featuresadded", "beforefeatureremoved",
                  "beforefeaturesremoved", "featureremoved", "featuresremoved",
                  "beforefeatureselected", "featureselected", "featureunselected", 
                  "beforefeaturemodified", "featuremodified", "afterfeaturemodified",
                  "vertexmodified", "sketchstarted", "sketchmodified",
                  "sketchcomplete", "refresh"],
	
	/**
     * Constructor: Geo.View3D.Layer.Vector
     * 构造Geo.View3D.Layer.Vector对象实例。
     *
     * Parameters:
     * name - {String}  图层名称。
     * options - {Object} 选项。
     *
     */  			  
    initialize: function(name, options) {
		
        this.EVENT_TYPES =
            Geo.View3D.Layer.Vector.prototype.EVENT_TYPES.concat(
            Geo.View3D.Layer.prototype.EVENT_TYPES
        );
				
        this.features = [];
		this.selectedFeatures = [];
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
    },
 	
	/**
	 * Method: setMap
	 * 将图层对象关联到地图。
	 *
	 * Parameters:
	 * map - {Geo.View3D.Map} 三维地图对象。
	 */	
    setMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._geometryLayer = map._addVectorLayer();
		this._dynamicLayer = map._addDynamicLayer();
		this._layerData = this._geometryLayer;
    },

	/**
	 * APIMethod: addFeatures
	 * 向图层中添加要素。说明：三维中添加的要素的颜色设置只能设置为#开头的样式。
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 要素数组。
	 */	    
    addFeatures: function(features) {
        if (!(Geo.Util.isArray(features))) {
            features = [features];
        }
        
        for (var i=0, len=features.length; i<len; i++) {
            var feature = features[i];
            
            if (!feature.style && this.style) {
                feature.style = OpenLayers.Util.extend({}, this.style);
            }
            this.features.push(feature);
            this.drawFeature(feature);
        }
        
    },
	
	/**
	 * APIMethod: drawFeature
	 * 画要素图层。
	 * 
	 * Parameters:
	 * features - {Object} 要素。
	 */
	drawFeature: function(feature) {
		var map = this.map;
        if (map) {
			map._drawGeometry({
				vectorLayerObj: this,
				featureid: feature.id,
				feature:feature,
				dynamicLayer: this._dynamicLayer,
				drawBox:this._geometryLayer,
				strPoints: this._getGeometryStr(feature.geometry),
				type: this._getGeometryType(feature.geometry),
				style: feature.style
			});
			feature.layer = this;
		}
	},

    /**
     * APIMethod: removeFeatures
     * 移除图层中的要素。
     * 
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。
     */    
    removeFeatures: function(features) {
        if(!features) {
            return;
        }
        if (!(Geo.Util.isArray(features))) {
            features = [features];
        }
        
        for (var i = features.length - 1; i >= 0; i--) {
            var feature = features[i];
            var map = this.map;
            if (map) {
				//如果是点要素，并且样式指定为图片渲染，则删除标注
				if(feature.style && feature.geometry.CLASS_NAME == "OpenLayers.Geometry.Point" 
							&& feature.style.externalGraphic){
					map._delBookMark(feature.id,this._dynamicLayer);
				} else {
					map._delGeometryByName(feature.id,this._geometryLayer);
				}
            }
            this.features = OpenLayers.Util.removeItem(this.features, feature);
        }
    },

    /**
     * APIMethod: destroyFeatures
     * 删除并且销毁图层上的要素。
     *
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 要销毁的要素数组，此项可选，如果无此项则销毁图层上所有要素。
     * options - {Object}
     */
    destroyFeatures: function(features, options) {
        var all = (features == undefined); // evaluates to true if
                                           // features is null
        if(all) {
            features = this.features;
        }
        if(features) {
            this.removeFeatures(features, options);
            for(var i=features.length-1; i>=0; i--) {
                features[i].destroy();
            }
        }
    },

    /**
     * Method: removeMap
     * 移除3D视图。
     *
     * Parameters:
	 * map - {Geo.View3D.Map} 三维视图对象。
     */
    removeMap: function(map) {
		var map = this.map;
        if(map){
			this.destroyFeatures(this.features);
			this._geometryLayer = null;
			this._dynamicLayer = null;
        }
		this.map = null;
    },


    /**
     * Method: setVisibility
     * 设置图层是否可见。
     * 
     * Parameters:
     * visibility - {Boolean} 图层是否可见
     */  
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
            this.visibility = visibility;
            this.display(visibility);
        }
    },

    /**
     * Method: display
     * 
     * Parameters:
     * display - {Boolean} 
     */  
    display: function(display) {
		var map = this.map;
        if(map){
			map._setLayerVisibility(this._layerData, display);
			map._setLayerVisibility(this._dynamicLayer, display);
        }
    },

    //得到几何对象的类型。
    _getGeometryType: function(geometry){
        var maping = {
            "OpenLayers.Geometry.Point": 0,
            "OpenLayers.Geometry.LineString": 1,
            "OpenLayers.Geometry.Polygon": 2
        }
        
        return maping[geometry.CLASS_NAME];
    },
	
    /**
     * APIMethod: getFeatureBy
     * 通过给定的属性和值来查找要素。
     *
     * Parameters:
     * property - {String} 要素对象属性。
     * value - {String} 指定属性的值。
     *
     * Returns:
     * {<Geo.Feature.Vector>} 返回符合给定值的要素，如果无符合则返回null。
     */
    getFeatureBy: function(property, value) {
        var feature = null;
        for(var i=0, len=this.features.length; i<len; ++i) {
            if(this.features[i][property] == value) {
                feature = this.features[i];
                break;
            }
        }
        return feature;
    },

    /**
     * APIMethod: getFeatureById
     * 查找并返回指定id的要素。
     *
     * Parameters:
     * featureId - {String} 要素对象的id属性值。
     *
     * Returns:
     * {<Geo.Feature.Vector>} 
     */
    getFeatureById: function(featureId) {
        return this.getFeatureBy('id', featureId);
    },

     //获取几何对象相应字符串
    _getGeometryStr:function (geometry){
        //替换所有指定字符串
        String.prototype.replaceAll = function(s1, s2){
            return this.replace(new RegExp(s1, "gm"), s2);
        }
        
        var str = geometry.toString();
        var start = str.indexOf("(") + 1;
        var end = str.indexOf(")");
//		if(geometry instanceof OpenLayers.Geometry.Point) {
//			return "POINT("+str.slice(start,end)+" 100000"+")";
//		}
		if(geometry instanceof OpenLayers.Geometry.LineString){
           var lineArr = str.slice(start,end).split(",");
		   for(var i = 0; i < lineArr.length; i++) {
	   	      lineArr[i] = (lineArr[i] + " 100000");
		   }
		   var line = lineArr.join(",");
		   return "LINESTRING("+line+")";
        }
        if(geometry instanceof OpenLayers.Geometry.Polygon){
			 var polygonArr = str.slice(start+1,end).split(",");
		   for(var i = 0; i < polygonArr.length; i++) {
	   	      polygonArr[i] = (polygonArr[i] + " 100000");
		   }
		   var line = polygonArr.join(",");
		   return "Ring("+line+")";
        }
        return str;
    },
	
    /** 
     * APIMethod: getDataExtent
     * 计算图层上所有要素的最大范围。
     * 
     * Returns:
     * {<Geo.Bounds>} 所有要素的范围。
     */
    getDataExtent: function () {
        var maxExtent = null;
        var features = this.features;
        if(features && (features.length > 0)) {
            maxExtent = new Geo.Bounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
    CLASS_NAME: "Geo.View3D.Layer.Vector"
});/**
 * Class: Geo.View3D.Layer.WMS
 * 三维视图中的WMS服务图层对象。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WMS = Geo.Class(Geo.View3D.Layer.GlobeTile,{
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
			
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,    

	_LAYER_TYPE_OGCWMS : 2,		
	/**
     * APIProperty: params
     * {String} WMS服务请求参数。
     */    
    params: null,
	
    //私有图层对象
    _layerData: null,

    //判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
			
	//默认参数
	DEFAULT_PARAMS :
	{
	  service: "WMS",
      version: "1.1.1",
      request: "GetMap",
      styles: "",
      format: "image/jpeg",
      spatialReference: "4326"
     },			
	/**
	 * Constructor: Geo.View3D.Layer.WMS
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * params - {Object} 服务请求参数。
	 * options - {Object} 选项。
     * 例如：
     * (code)
	 * 	  var wmsLayer = new Geo.View3D.Layer.WMS("wms", "http://192.168.40.69:9010/wms0319/wms",
	 *          {
	 *           	version:"1.1.1"//请求的服务版本，默认为：1.1.1
	 *           	layers: "China400w",//请求的图层名称，必填
	 *           	format:"image/jpeg",//请求的图片格式，默认：image/jpeg
	 *           	transparent: "false",//请求的瓦片背景区域是否透明,默认：true		
	 *           },
	 *           {	
	 *           	//级别(级别、分辨率、比例尺的参数设置，任选其一设置即可)
	 *           	topLevel:0,//顶层级别，默认：0
	 *           	bottomLevel:20,//底层级别，默认：20
	 *           	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *           	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *           	tileSize: new Geo.Size(256,256),//瓦片宽度，瓦片高度，默认：256，256
	 *           	//图层范围,默认为全球范围：-180,-90,180,90,必填
	 *           	maxExtent:Geo.Bounds.fromString("73.446960,6.318641,135.085830,53.557926"),	
	 *				//分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275
	 *           });。
	 *  (end)         
	 */	    
    initialize: function(name, url, params, options) {
        this.url = url;
     	//判断用户使用api版本
    	if(arguments.length < 4){
    		this._oldLoad = true;
    		Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this,[name, url, options]);
			if(params && !params.version){
				params.version = "1.3.0";
			}
	        this.params = params;
	        return;
    	}
    	//与二维一致的新的三维图层加载方式
    	params = params || {};
    	params.pyramid = params.pyramid ? params.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = params.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = params.pyramid.getLevelForResolution(options.minResolution);
		}
		
		if(params.maxScale){
			options.bottomLevel = params.pyramid.getLevelForScale(options.maxScale);
		}
		if(params.minScale){
			options.topLevel = params.pyramid.getLevelForScale(options.minScale);
		}
		params.format = params.format ? this.DEFAULT_PARAMS.format : "image/jpeg";
    	var args = [name, url, options];
    	this.params = params;
        Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, args);
		//layer is transparent        
        if (this.params.transparent && 
            this.params.transparent.toString().toLowerCase() == "true") {
            // jpegs can never be transparent, so intelligently switch the 
            //  format, depending on the browser's capabilities
            if (this.params.format == "image/jpeg") {
                this.params.format = OpenLayers.Util.alphaHack() ? "image/gif"
                                                                 : "image/png";
            }
        }
    },

    /**
     * Method: setMap
     * 将图层关联到指定三维视图对象。
     *
     * Parameters:
     * map - {Geo.View3D.Map} 三维视图对象。
     */
    setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
    
	//老版本,参数内部构造
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		var wmsLayer = this.dataSourceBox.CreateDataLayer(this.url, this.params.version, this._LAYER_TYPE_OGCWMS);
		this.layerBox.UserGroupLayer.AddLayer(wmsLayer);
        this._layerData = wmsLayer;
    },
    
	//自定义图层方式
    _createLayerFromJson : function(map){
	    //服务数据类型，有两种类型，影像数据：ImageDataType，矢量数据：VectorDataType，默认：ImageDataType
	    var dataType= this.options.dataType ? this.options.dataType : "ImageDataType";
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号
	    var version = this.params.version ? this.params.version : this.DEFAULT_PARAMS.version;
	    /**私有参数**/
	    //请求的图层名称
	    var layers = encodeURIComponent(this.params.layers ? this.params.layers : "");
	    //请求的图片格式
	    var format = encodeURIComponent(this.params.format ? this.params.format : this.DEFAULT_PARAMS.format);
	    //请求的瓦片背景区域是否透明,默认为TURE
	    var transparent = this.params.transparent ? this.params.transparent : "TRUE";
	    //请求的图层样式
	    var styles = this.options.styles ? this.options.styles : this.DEFAULT_PARAMS.styles;
	    //获取瓦片大小
	    var tileSize =  this.options.tileSize ? this.options.tileSize : new Geo.Size(256,256);
	    //请求的图片宽度
	    var width = tileSize.w ? tileSize.w : 256;
	    //请求的图片高度
	    var height = tileSize.h ? tileSize.h : 256;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = this.params.spatialReference ? this.params.spatialReference : this.DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"Customer",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+url+''+
		'?SERVICE='+this.DEFAULT_PARAMS.service+'&transparent='+transparent+'&Request=GetMap&VERSION='+version+'' +
		'&LAYERS='+layers+'&STYLES='+styles+'&FORMAT='+format+''+
		'&WIDTH='+width+'&HEIGHT='+height;
		//如果请求的服务版本为1.3，请求的投影设置为CRS,否则其它情况时，设置请求投影为SRS
		var srs = projection;
	    var crs = "";
		if(parseFloat(version) >= 1.3){
			layerJson += '&CRS='+srs+'';
			crs = srs;
		}else{
			layerJson += '&SRS='+srs+'';
		}
		//如果CRS不为空，并且开始字答串为EPSG，并且请求服务版本为1.3时，BBOX的请求串为ymin,xmin,ymax,xmax;否则都为xmin,ymin,xmax,ymax.
		if(crs != "" && parseFloat(version) == 1.3){
			layerJson += '&BBox=${TileYMin},${TileXMin},${TileYMax},${TileXMax}';
		}else{
			layerJson += '&BBox=${TileXMin},${TileYMin},${TileXMax},${TileYMax}';
		}
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    //根据拼好的请求字符串调用三维接口进行服务请求
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;
    },
    
	/**
	 * Method: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
    	var map = this.map;
		if(this._layerData && display != this._layerData.Visible){
			map._setLayerVisibility(this._layerData, display);
    	}
    },
	
	/**
	 * Method: setOpacity
	 * 设置图层不透明度，数值在0-1.0之间。
	 *
	 * Parameters:
	 * opacity - {Float} 透明度。
	 */	
    setOpacity: function(opacity) {
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if(map){
			map._setLayerOpacity(this._layerData,opacity);
	    	this.opacity = opacity;
        }
    },
	
	/**
	 * Method: gotoCenter
	 * 定位到图层中心点。
	 *
	 */	    
    gotoCenter:function(){
        var map = this.map;
        if(map){
            map._gotoLayer(this._layerData);
        }
    },
	
	/**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */	    
    removeMap: function() {
        var map = this.map;
        if(map){
			map._removeLayerData(this._layerData);
        }
		this.map = null;
    },
	 	
    CLASS_NAME: "Geo.View3D.Layer.WMS"
});/**
 * Class: Geo.View3D.Layer.WMTS
 * 三维视图OGC-WMTS服务图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WMTS = Geo.Class(Geo.View3D.Layer.GlobeTile, {

    /**
     * APIProperty: layerName
     * {String} 图层名称。
     */
    layerName: null,
	
    //图层类型
	_LAYER_TYPE_OGCWMTS : 4,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
    /**
     * Constructor: Geo.View3D.Layer.WMTS
     * 构造函数。
     *
     * Parameters:
     * options - {Object} 设置图层属性。
     * 
     * 示例：
     * (code)
	 * 	  var wmtsLayer = new Geo.View3D.Layer.WMTS(
	 *          {
	 *           	name:"1-18级WMTS影像底图",//图层名称，必填
	 *           	url:"http://t0.tianditu.com/img_c/wmts",//服务URL地址，必填
	 *           	matrixSet:"c",//瓦片矩阵集，必填
	 *           	style:"default",//请求的样式，默认：""，必填
	 *           	layer: "img",//请求的图层名称，必填
	 *           	attribution:"1-18级WMTS影像底图",//图层信息
	 *           	format:"tiles",//请求的图片格式，默认：image/jpeg，必填
	 *           	//支持级别，分辨率，比例的用法，任一选择
	 *           	topLevel:0,//顶层级别，默认：0
	 *           	bottomLevel:20,//底层级别，默认：20
	 *           	tileFullExtent:Geo.Bounds.fromString("-180.0,-90.0,180.0,90.0"),//图层范围,缺省范围：-180,-90,180,90
	 *           	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *           	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *           	version:"1.1.1"//服务版号，本默认为1.0.0
	 *				//支持分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//支持比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275
	 *           });。
	 * (end)           
     */
    initialize: function(name, url, options){
        //判断用户使用api版本
    	if(typeof(arguments[0]) == "string"){
    		//老的三维图层加载方式传参为Name、URL
    		this._oldLoad = true;
    		Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, [name, url, options]);
	        this.url = url;
	        options = options || {};
	        this.layerName = options.layer;
	        return;
    	}
    	
    	//与二维一致的新的三维图层加载方式
        var required = {
            url: true,
            layer: true,
            style: true,
            matrixSet: true
        };
        options = arguments[0] || {};
		/*
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("Missing property '" + prop + "' in layer configuration.");
            }
        }
        */
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
    	var args = [options.name, options.url, options];
        Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, args);
    },
    
     /**
     * Method: setMap
     * 将图层关联到指定三维视图对象。
     *
     * Parameters:
     * map - {Geo.View3D.Map} 三维视图对象。
     */
    setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
	 	var wmtsLayer = this.dataSourceBox.CreateDataLayer(this.url, "", this._LAYER_TYPE_OGCWMTS);
		//吉奥瓦片图层对象
		this.layerBox.UserGroupLayer.AddLayer(wmtsLayer);
		this._layerData = wmtsLayer;
    },
    
    //自定义图层方式
    _createLayerFromJson : function(map){
    	//默认参数值
    	var DEFAULT_PARAMS =
		{ 
		  service: "WMTS",
	      version: "1.0.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference: "4326",
	      hasTemporal:"false"
	     };
	    //服务数据类型，有两种类型，影像数据：ImageDataType，矢量数据：VectorDataType，默认：ImageDataType
	    var dataType= this.options.dataType ? this.options.dataType : "ImageDataType";
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.tileFullExtent ? this.options.tileFullExtent.left : -180;
	    var yMin = this.options.tileFullExtent ? this.options.tileFullExtent.bottom : -90;
	    var xMax = this.options.tileFullExtent ? this.options.tileFullExtent.right : 180;
	    var yMax = this.options.tileFullExtent ? this.options.tileFullExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //请求的图层名称
	    var layer = this.options.layer ? this.options.layer : "";
	    //请求的图片格式
	    var format = this.options.format ? this.options.format : DEFAULT_PARAMS.format;
	    //请求的图层样式
	    var style = this.options.style ? this.options.style : "";
	    //瓦片矩阵集
	    var matrixSet = this.options.matrixSet ? this.options.matrixSet:"";
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //是否加载多时相服务
	    var hasTemporal = this.options.hasTemporal ? this.options.hasTemporal : DEFAULT_PARAMS.hasTemporal;
	    //拼图层请求串
	    var layerJson = '{'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"WMTS",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"HasTemporal":"'+ hasTemporal +'",'+
		'"ServerUrl":"'+ url+'",'+
		'"Version":"'+ version+'",'+
		'"Layers":"' + layer + '",' +
		'"Styles":"' + style + '",' +
		'"ImageFormat":"' + format + '",' +
		'"TileMatrixSet":"' + matrixSet;
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    //是否启用多时相功能
	    this.layerBox.EnableTemporal=hasTemporal;
	    this._layerData = layer;
    },
    
     /**
     * Method: changeTemporal
     * 通过时间轴显示多时相数据。
     *
     * Parameters:
     * @param {String} varTime。
     */
	changeTemporal : function(varTime) {
		this.layerBox.ChangeTemporal(varTime);
	},
    
    /**
     * Method: removeMap
     * 取消三维视图对象与图层关联。
     *
     */
    removeMap: function(){
        var map = this.map;
        if (map) {
        	map._removeLayerData(this._layerData);
        }
        this.map = null;
    },
    
    /**
     * Method: display
     *
     * Parameters:
     * display - {Boolean}
     */
    display: function(display){
    	var map = this.map;
		if(!this._layerData){
			return;
		}
        if (display != this._layerData.Visible) {
			map._setLayerVisibility(this._layerData, display);
        }
    },
    
    /**
     * Method: gotoCenter
     * 定位到图层中心点。
     *
     */
    gotoCenter: function(){
        var map = this.map;
        if (map) {
			if(this._layerData){
				map._gotoLayer(this._layerData);
			}
        }
    },
    
    /**
     * Method: setOpacity
     * 设置图层不透明度，数值在0-1.0之间。
     *
     * Parameters:
     * opacity - {Float} 透明度。
     */
    setOpacity: function(opacity){
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if (map) {
            if (this._layerData) {
                map._setLayerOpacity(this._layerData, opacity);
                this.opacity = opacity;
            }
        }
    },
	
     /**
     * Method: showHistory
     * 显示多时相时间轴。
     *
     * Parameters:
     * visible - {Boolean} 是否显示时间轴，true为显示，false为不显示。
     * locationX - {Number} 时间轴在球体上的显示的横坐标位置。
     * locationY - {Number} 时间轴在球体上的显示的纵坐标位置。
     */
	showHistory: function(visible,locationX,locationY){
		 var map = this.map;
         if (map) {
		 	var varHis = map.activexObj.SceneBox.TemporalRuler;
			if(locationX)varHis.LocationX = locationX;
            if(locationY)varHis.LocationY = locationY;
		 	varHis.Visible = visible;
		 }
    },
	
    CLASS_NAME: "Geo.View3D.Layer.WMTS"
});
/**
 * Class: Geo.View3D.Layer.WTFS
 * 三维视图下的吉奥三维地名服务图层对象
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WTFS = Geo.Class(Geo.View3D.Layer.GlobeTile, {
	/**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
    
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
	
	//吉奥瓦片图层类型
	_LAYER_TYPE_GLOBETILE:6,
    
	//私有图层对象
    _layerData: null,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
	/**
	 * Constructor: Geo.View3D.Layer.WTFS
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var wtfsLayer = new Geo.View3D.Layer.WTFS("wtfs", "http://192.168.40.69:9010/wtfs0319/wtfs",
	 *          {
	 *           	maxExtent:Geo.Bounds.fromString("-180,-90,180,90"),//图层范围,默认范围：-180,-90,180,90,必填
	 *           	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *           	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *           	version:"1.1.1"//服务版号，本默认为1.1.1
	 *           	//支持级别，分辨率，比例的用法，任一选择
	 *           	topLevel:0,//顶层级别，默认：0
	 *				bottomLevel:20//底层级别，默认：20
	 *				//支持分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//支持比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275
	 *           });。
	 *  (end)
	 */		      
    initialize: function(name, url, options) {
    	//判断用户使用api版本
    	if(arguments.length < 3){
    		this._oldLoad = true;
    		Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
    	options = options || {};
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },

	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
	setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map) {
       Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._layerData = map._addGlobeTileService(this.url,"",this._LAYER_TYPE_GLOBETILE);
    },
    
     //自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "1.1.1",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    /**所有的服务的公共参数**/ 
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号，version版本为2.1的暂时不支持
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"DataType":"POIDataType",'+
		'"DataSourceType":"GeoTile",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+ url+'",' +
		'"Version":"'+ version;
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;	
    },
    
    CLASS_NAME: "Geo.View3D.Layer.WTFS"
});
/**
 * Class: Geo.View3D.Layer.Solid
 * 立方体图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Solid = Geo.Class(Geo.View3D.Layer, {

    /**
     * APIProperty: geometry
     * {Object} 当前绘制的几何对象。
     */
    geometry: null,
    
    /**
     * APIProperty: height
     * {String} 当前绘制的几何对象的高度。
     */
    height: null,
    
    /**
     * APIProperty: faceColor
     * {Object}当前绘制的几何对象的颜色属性。
     */
    faceColor: null,
    
    _localDataBox: null,
    
    _layerData: null,
    
    /**
     * Constructor: Geo.View3D.Layer.Solid
     * Geo.View3D.Layer.Solid的构造函数。
     *
     * Parameters:
     * name - {String} 图层名称。
     * geometry - {Geo.Geometry} 绘制的集合对象。
     * height - {String} 海拔高度。
     * options - {Object} 选项。
     *
     * 示例:
     * (code)
     *
     *   solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  
     *   //设置正方体中心点
     *     1.WKT字符串 2.暂时不用 3.//第三个参数1表示point ,2表示lineString,3表示Ring,4表示Model，5表示 Box
            a2 = GlobeCtrl.DrawBox.CreateGeometryObject("POINT(110 35 100)", "", 1, 1);
            //设置符号
            var b = GlobeCtrl.DrawBox.CreateSymbolObject(1);
            b.Color = -13660459;
            //设置正方体棱长
            b.Box = GlobeCtrl.DrawBox.CreateGeometryObject("", "", 5, 1);
            b.Size=200;
            GlobeCtrl.DrawBox.AddDrawObject(a2, b);
     *
     *  (end)
     */
    initialize: function(name, geometry, height, options){
//        this.faceColor = {
//            top: 0x7fffffff,
//            bottom: 0x7fffffff,
//            round: 0x7fffffff
//        };
		this.faceColor = {
            Color: -13660459,
            Size: 200
        };
        
        this.geometry = geometry;
        this.height = height;
        Geo.View3D.Layer.prototype.initialize.apply(this, [name, options]);
    },
	
	_getSolidSymbol: function() {
		//设置符号
        this._localDataBox = this._drawBox.CreateSymbolObject(1);
        this._localDataBox.Color = this.faceColor.Color;
        //设置正方体棱长
        this._localDataBox.Box = this._drawBox.CreateGeometryObject("", "", 5, 1);
        this._localDataBox.Size = this.faceColor.Size;
		return this._localDataBox;
	},
	
    /**
     * Method: setMap
     * 将图层关联到指定三维视图对象。
     *
     * Parameters:
     * map - {Geo.View3D.Map} 三维视图对象。
     *
     * 示例:
     * (code)
     *  var map = new Geo.View3D.Map("simpleMap");
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setMap(map);
     *  (end)
     */
    setMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
		this._drawBox = this.map.activexObj.DrawBox;
        this._layerData = this._createBoxLayer(this.geometry, this.height);
    },
    
    /**
     * Method: removeMap
     * 取消三维视图对象与图层关联。
     *
     * 示例:
     * (code)
     *  var map = new Geo.View3D.Map("simpleMap");
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setMap(map);
     *  solidLayer.removeMap();
     *  (end)
     */
    removeMap: function(){
        var map = this.map;
        if (map) {
            this._clearBoxLayer();
        }
        this.map = null;
    },
    
    /**
     * APIMethod: setHeight
     * 设置盒子高度。
     *
     * Parameters:
     * height - {Number} 海拔高度。
     *
     * 示例:
     * (code)
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setHeight(3000);
     *  (end)
     */
    setHeight: function(height){
		if (this._localDataBox && height) {
	        this._localDataBox.Box.Width = height;
	    }
//        if (this._localDataBox) {
//            this._localDataBox.setPolyGonHeight(this._layerData.Name, height);
//        }
    },
    
    /**
     * APIMethod: setFaceColor
     * 设置盒子颜色。
     *
     * Parameters:
     * colorParams - {Object} 颜色参数。
     * 
     * 示例:
     * (code)
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setFaceColor({
     *  top: 0x7f1760bf,
     *  bottom: 0x7f1760bf,
     *  round: 0x7f1760bf
     *  });
     *  (end)
     */
    setFaceColor: function(colorParams){
        this.faceColor = OpenLayers.Util.extend(this.faceColor, colorParams);
//        if (this._localDataBox) {
//            var boxLayerId = this._layerData.Name;
//            this._localDataBox.SetBoxFaceColor(boxLayerId, this.faceColor.top, this.faceColor.bottom, this.faceColor.round);
//        }
		//目前只支持设置立方体的一种颜色，不支持立方体的上面，下面和周边颜色的设置
		
		if(this.faceColor.top) {
			this._localDataBox.Color = Geo.Util.ToArgb(this.faceColor.top,255);
		}else if(this.faceColor.bottom) {
			this._localDataBox.Color = Geo.Util.ToArgb(this.faceColor.bottom,255);
		}else if(this.faceColor.round) {
			this._localDataBox.Color = Geo.Util.ToArgb(this.faceColor.round,255);
		}
    },
    
    
    // 画盒子图层
    _createBoxLayer: function(polygonGeometry, height){
		var centerPoint = polygonGeometry.getBounds().getCenterLonLat();
		var pointGeometry  = new Geo.Geometry.Point(centerPoint.lon, centerPoint.lat);
		var str = pointGeometry.toString();
        var start = str.indexOf("(") + 1;
        var end = str.indexOf(")");
		var point = str.slice(start,end);
		var pointWkt = "POINT(" + point + " " + height + ")";
    	this._layerData = this._drawBox.CreateGeometryObject(pointWkt, "", 1, 1);
		var symbol = this._getSolidSymbol();
		this._drawBox.AddDrawObject(this._layerData, symbol);
		this.map.activexObj.SceneBox.ParabolaFlyTo(centerPoint.lon, centerPoint.lat, 1000);
		return this._layerData;
//        var Globe = this.map.activexObj;
//        
//        // 画盒子用接口
//        if (!this._localDataBox) {
//            this._localDataBox = Globe.CreateAddLocalDataObj();
//        }
//        
//        var pointstr = this._getPointsThreeDegreeSpaceSplitStr(polygonGeometry, 0);
//        
//        
//        var boxLayerId = this.id + "_boxLayer";
//        
//        var layerdata = this._localDataBox.AddPolyGon(boxLayerId, pointstr);
//        layerdata.Name = boxLayerId;
//        this._localDataBox.setPolyGonHeight(boxLayerId, height);
//        this._localDataBox.SetBoxFaceColor(boxLayerId, this.faceColor.top, this.faceColor.bottom, this.faceColor.round);
        
    },
    
    // 删除盒子图层
    _clearBoxLayer: function(){
		this._drawBox.RemoveObject(this._layerData);
		this._layerData = null;
//        var Globe = this.map.activexObj;
//        var layer = Globe.GetSceneGroup().GetLayerByName(this.id + "_boxLayer");
//        if (layer != null) {
//            Globe.GetSceneGroup().RemoveLayer(layer);
//        }
    },
    
    //将二维点数组，加上指高度形成三维点数组转换成空格分隔的字符串
    _getPointsThreeDegreeSpaceSplitStr: function(polygonGeometry, height){
        var linearRing = polygonGeometry.components[0];
        var allPoints = linearRing.components;
        
        var points = [];
        for (var i = 0; i < allPoints.length; i++) {
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
            points.push(height);
        }
        return points.join(" ");
    },
    
    CLASS_NAME: "Geo.View3D.Layer.Solid"
});
/**
 * Class: Geo.View3D.Layer.WCS
 * 三维视图OGC-WCS服务图层对象。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WCS = Geo.Class(Geo.View3D.Layer.GlobeTile, {

    setMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
        this._layerData = map._addWCSService(this.url);
		this.display(this.visibility);
    },
    
    CLASS_NAME: "Geo.View3D.Layer.WCS"
});
/**
 * Class: Geo.View3D.Layer.Grid
 * 三维下的自定义图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Grid = Geo.Class(Geo.View3D.Layer,{
	/**
	 * APIProperty: id
	 * {String} 唯一标识符。
	 */
	id:null,
	/**
	 * APIProperty: topLevel
	 * {Number} 顶层级别 默认为0。
	 */
	topLevel:0,
	/**
	 * APIProperty: buttomLevel
	 * {Number} 底层级别 默认为0。
	 */
	buttomLevel:0,
	/**
	 *  APIProperty: maxExtent
	 * {Object} 图层范围，缺省范围是-180,-90,180,90。
	 */
	maxExtent:null,
	/**
	 * APIProperty: dataType
	 * {String} 默认值为"ImageDataType"。
	 */
	dataType:"ImageDataType",
	/**
	 * APIProperty: url
	 * {String} 用户自定义服务，必须填写。
	 */
	url:null,
	/**
	* APIProperty: pyramid
	* {String} 默认为360°金字塔信息，一个xml字符串。
	*/
	pyramid:null,
	/**
	* APIProperty: spatialReference
	* {String} 默认为"4326"，字符串。
	*/
	spatialReference:"4326",
	/**
	 * APIProperty: dataSourceType
	 * {String} 当此值为"Customer"时，最好填写范围和层级，字符串。
	 */
	dataSourceType:"Customer",
	/**
	 * APIProperty: height
	 * {Number} 距离地面高度
	 */
	height:300,
	//私有图层对象
	_layerData:null,
	/**
	 * Constructor: Geo.View3D.Layer.Grid
	 * 构造函数。
	 * 
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 */
	initialize:function(name, url, options){
		Geo.View3D.Layer.prototype.initialize.apply(this,[name,options]);
		this.url = url;
		var options = options || {};
		this.topLevel = options.topLevel?options.topLevel:this.topLevel;
		this.buttomLevel = options.buttomLevel?options.buttomLevel:this.buttomLevel;
		this.maxExtent = options.maxExtent?options.maxExtent:new Geo.Bounds(-180,-90,180,90);
		this.dataType = options.dataType?options.dataType:this.dataType;
		this.pyramid = options.pyramid?options.pyramid:"";
		this.spatialReference = options.spatialReference?options.spatialReference:this.spatialReference;
		this.dataSourceType = options.dataSourceType?options.dataSourceType:this.dataSourceType;
		this.height = options.height?options.height:this.height;
	},
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */
	setMap:function(map){
		Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		var layerJson = '{'+
		'"DataType":"'+this.dataType+'",'+
		'"DataSourceType":"'+this.dataSourceType+'",'+
		'"StartLevel":'+this.topLevel+','+
		'"EndLevel":'+this.buttomLevel+','+
		'"XMin":'+this.maxExtent.left+','+
		'"YMin":'+this.maxExtent.bottom+','+
		'"XMax":'+this.maxExtent.right+','+
		'"YMax":'+this.maxExtent.top+','+
		'"SpatialReference":"'+this.spatialReference+'",'+
		'"ServerUrl":"'+this.url + '"}';
        this._layerData = this.map.activexObj.DataSourceBox.CreateLayerFromJson(layerJson);
		this.map.activexObj.LayerBox.UserGroupLayer.AddLayer(this._layerData);
		this.display(this.visibility);
	},
	/**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 */
	removeMap:function(){
		var map =  this.map;
		if(map){
			map._removeLayerData(this._layerData);
			this._layerData = null;
		}
		this.map = null;
	},
	/**
	 * Method: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
	 */	
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
        	this.visibility = visibility;
            this.display(visibility);
        }
    },
	/**
	 * Method: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
		if(!this._layerData){
			return;
		}
        if(display != this._layerData.Visible){
			var map = this.map;
			map._setLayerVisibility(this._layerData,display);
        }
    },
	/**
	 * Method: setOpacity
	 * 设置透明度。
	 * 
	 * Parameters:
	 * opacity - {Number} 透明度。
	 */
	setOpacity:function(opacity){
		Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
		var map = this.map;
		if(map){
			map._setLayerOpacity(this._layerData,opacity);
			this.opacity = opacity;
		}
	},
	/**
	 * Method: gotoCenter
	 * 定位到图层中心点。
	 */
	gotoCenter:function(){
		var map = this.map;
		if(map){
			map._gotoLayer(this._layerData);
		}
	},
	
	CLASS_NAME:"Geo.View3D.Layer.Grid"
});/**
 * Class: Geo.View3D.Layer.Model
 * 三维视图模型图层对象
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.Grid>
 */
Geo.View3D.Layer.Model = Geo.Class(Geo.View3D.Layer.Grid, {
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
	/**
     * APIProperty: enumLayerPropertyName
     * <Object>} 图层属性对象。
     */
	enumLayerPropertyName :
	{
		layerName : 0,
		layerVisible : 1,
		layerTransparency : 2,
		layerFullEnvelope : 3,
		wmslayerInfo : 4,
		wmtslayerInfo : 5,
		EnableSelection : 6,
		lodDistanceFactor : 7,
	    stereoModelColor : 8,
	    modelHeightOffset : 9
	},
	
	/**
	 * Constructor: Geo.View3D.Layer.Model
	 * 构造函数。
	 * 
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var modelLayer = new Geo.View3D.Layer.Model("model", "http://192.168.42.56:9010/model/services/tile",
     *    {
     *       topLevel:1,//顶层级别，默认:0
	 *		 bottomLevel:20,//底层级别，默认:20
	 *       //图层范围,默认范围:-180,-90,180,90，必填
	 *		 maxExtent:Geo.Bounds.fromString("117.1966552734375,34.1839599609375,117.2845458984375,34.2828369140625"),
     *       layerType : "model",  //可选，图层类型值为model，设置此参数值表示让三维插件用新方式创建模型图层
     *       opacity : 1,//图层透明度设置,// 可以设置：0-1，默认：1
     *       projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
     *       version:"5.0",//请求的服务版本，默认：1.1.1
	 *		 //支持分辨率
	 *		 //maxResolution :0.000005364418029785156,//最大分辨率
     *       //minResolution :0.703125//最小分辨率
     *       //支持比例尺
     *       //minScale : 2.958293554545656E8,
     *       //maxScale : 2256.998866688275      
     *    });
	 * (end) 
	 */
	initialize:function(name, url, options){
		options = options || {};
		//通过读取用户创建模型时传入的layerType参数，判断接口的创建方式
		// oldFlag为true代表老方式创建，false代表新方式创建
		var oldFlag = typeof(options.layerType) == "undefined" ? true : false;
    	if(oldFlag){
    		this._oldLoad = true;
    		Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this,[name,url, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
	},
	
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
	setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._layerData = map._addGlobeTileService(this.url,"",this._LAYER_TYPE_GLOBETILE);
    },
    
     //自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "5.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    /**所有的服务的公共参数**/ 
	    //默认为影像：ImageDataType，矢量：VectorDataType，模型数据：ModelDataType， Lod模型数据：LodModelDataType，POI数据：POIDataType
	    var dataType= "LodModelDataType";    
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号，version版本为2.1的暂时不支持
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
//	    var layerJson = '{'+
//		'"DataType":"'+dataType+'",'+
//		'"DataSourceType":"GeoTile",'+
//		'"StartLevel":'+dataSetStartLevel+','+
//		'"EndLevel":'+dataSetEndLevel+','+
//		'"XMin":'+xMin+','+
//		'"YMin":'+yMin+','+
//		'"XMax":'+xMax+','+
//		'"YMax":'+yMax+','+
//		'"SpatialReference":"'+spatialReference+'",' +
//		'"RenderTransparency":'+renderTransparency+',' +
//		'"ServerUrl":"'+ url+'",' +
//		'"Version":"'+ version;
//		layerJson +='"}';

		var layerJson = '{'+
			'"Layer" : "ModelLayer",'+
			'"LayerDataType" : "Model",'+
			'"LayerName" : "JIYUDOUBLE",'+
			'"DataSet" : "CommonTileDataSet",'+
			'"SpatialReference" : "'+spatialReference+'",'+
			'"Render" : "LODModelRender",'+
			'"TileSource" : "TMSTileSource",'+
			'"Priority" : 1,'+
			'"UriRules" : "GeoTileUriRules",'+
			'"RenderTransparency" : '+renderTransparency+','+
			'"DataSetStartLevel" : '+dataSetStartLevel+','+
			'"DataSetEndLevel" : '+dataSetEndLevel+','+
			'"Pyramid" : "",'+
			'"XMin" : '+xMin+','+
			'"YMin" : '+yMin+','+
			'"XMax" : '+xMax+','+
			'"YMax" : '+yMax+','+
			'"Uris" : [{'+
				'"ServerUrl" : "'+url+'",'+
				'"StartLevel" : '+dataSetStartLevel+','+
				'"EndLevel" : '+dataSetEndLevel+','+
				'"Version" : "'+version+'",'+
				'"TimeStamp" : "",'+
				'"XMin" : '+xMin+','+
				'"YMin" : '+yMin+','+
				'"XMax" : '+xMax+','+
				'"YMax" : '+yMax+','+
				'"Layers" : null,'+
				'"Styles" : null,'+
				'"ImageFormat" : null,'+
				'"TileMatrixSet" : null,'+
				'"CRS" : null,'+
				'"RelativeLevel" : false,'+
				'"Pyramid" : null,'+
				'"HasTemporal" : false'+
			'}]'+
		'}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;	
    },
	
	/**
	 * APIMethod: modelHeightOffset
	 * 设置模型抬高高度。
	 *
	 * Parameters:
	 * height - {Number} 高度 。
	 */	
	modelHeightOffset:function(height){
		var layerOp = map.activexObj.LayerBox.CreateLayerOperate(this._layerData);
		layerOp.ChangeLayerProperty(this.enumLayerPropertyName.modelHeightOffset, height);
	},
	
	/**
	 * APIMethod: lodDistanceFactor
	 * 设置模型数据的显示范围。
	 *
	 * Parameters:
	 * factor - {Number} 范围值。 0,较小 1,普通 2,较大
	 */
	lodDistanceFactor : function(factor){
		var layerOp = map.activexObj.LayerBox.CreateLayerOperate(this._layerData);
		switch (factor) {
			case 0:
				layerOp.ChangeLayerProperty(this.enumLayerPropertyName.lodDistanceFactor, 0.6);
				break;
			case 1:
				layerOp.ChangeLayerProperty(this.enumLayerPropertyName.lodDistanceFactor, 1);
				break;
			case 2:
				layerOp.ChangeLayerProperty(this.enumLayerPropertyName.lodDistanceFactor, 1.5);
				break;
			default:
				return;			
		}
	},
    
    CLASS_NAME: "Geo.View3D.Layer.Model"
});
/**
 * Namespace: Geo.View3D.Event.KeyEvent
 * 三维键盘事件对象。
 */
Geo.View3D.Event.KeyEvent = {

    /**
     * Constant: KEY_SPACE
     * {Number} 空格键代码。
     */
    KEY_SPACE: 32,
    
    /** 
     * Constant: KEY_LEFT
     * {Number} 左方向键代码。
     */
    KEY_LEFT: 37,
    
    /** 
     * Constant: KEY_UP
     * {Number} 上方向键代码。
     */
    KEY_UP: 38,
    
    /** 
     * Constant: KEY_RIGHT
     * {Number} 右方向键代码。
     */
    KEY_RIGHT: 39,
    
    /** 
     * Constant: KEY_DOWN
     * {Number} 下方向键代码。
     */
    KEY_DOWN: 40,
    
    /** 
     * Constant: KEY_PLUS
     * {Number} 加号键代码。
     */
    KEY_PLUS: 187,
    
    /** 
     * Constant: KEY_MINUS
     * {Number} 减号键代码。
     */
    KEY_MINUS: 189,
    
     /** 
     * Constant: KEY_MINUS
     * {Number} 小键盘加号键代码。
     */
    KEY_NUM_PLUS: 107,
    /** 
     * Constant: KEY_MINUS
     * {Number} 小键盘减号键代码。
     */
    KEY_NUM_MINUS: 109,
    
     /**
     * APIMethod: isKeyDown
     * 判断是否键盘按键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyDown: function(e){
        if (e.EventType === 6) {
            return true;
        }
     },
			
	/**
     * APIMethod: isKeyUp
     * 判断是否键盘按键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyUp: function(e){
        if (e.EventType === 7) {
            return true;
        }
    },
    
    /**
     * APIMethod: isKeyboardDown
     * 判断是否键盘按键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyboardDown: function(e){
        if (e.keyState === 0) {
            return true;
        }
     },
			
	/**
     * APIMethod: isKeyboardUp
     * 判断是否键盘按键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyboardUp: function(e){
        if (e.keyState === 1) {
            return true;
        }
    },
    
    CLASS_NAME: "Geo.View3D.Event.KeyEvent"
};
/**
 * Namespace: Geo.View3D.Event.MouseEvent
 * 三维鼠标事件对象。本事件对象用于判断三维视图下鼠标是否触发了鼠标动作，包括鼠标左键点击，鼠标移动，鼠标
 * 右键点击等动作，以及鼠标所在的像素位置，经纬度和海拔高度信息。
 */
Geo.View3D.Event.MouseEvent = {

    /**
     * APIMethod: isMousemove
     * 判断是否鼠标移动。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMousemove: function(e){
		//if (e.MouseButton === -1 && e.MouseState === 1) 
        if (e.MouseButton === 0 && e.MouseState === 3) {
            return true;
        }
    },
    
    /**
     * APIMethod: isMouseDown
     * 判断是否鼠标左键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseDown: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 0) {
		if (e.MouseButton === 1 && e.MouseState === 0) {
            return true;
        }
	},
    
    /**
     * APIMethod: isLeftClick
     * 判断是否鼠标点击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isLeftClick: function(e){
//        if (e.MouseButton === 0 && e.MouseState === 0) {
//		if (e.MouseButton === 1 && e.MouseState === 1) {
//            return true;
//        }
    	if (e.MouseButton !== 1 || e.MouseState !== 1) {
            return false;
        };
        if(Geo.View3D.Event.MouseEvent._mouseDownPos){
            var xOffset = Math.abs(Geo.View3D.Event.MouseEvent._mouseDownPos.x - e.ScreenX);
            var yOffset = Math.abs(Geo.View3D.Event.MouseEvent._mouseDownPos.y - e.ScreenY);
            var pixelTolerance = Geo.View3D.Event.MouseEvent.pixelTolerance;

            if(xOffset > pixelTolerance || yOffset > pixelTolerance){
                return false;
            };
        };
        return true;
	},
    
    /**
     * APIMethod: isMouseUp
     * 判断是否鼠标左键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseUp: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 2) {
		if (e.MouseButton === 1 && e.MouseState === 1) {
            return true;
        }
	},
    
	/**
     * APIMethod: isMouseDownMove
     * 判断是否鼠标左键按住移动。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseDownMove: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 0) {
		if (e.MouseButton === 1 && e.MouseState === 3) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseLeftDoubleClick
     * 判断是否鼠标左键双击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseLeftDoubleClick: function(e){
		if (e.MouseButton === 1 && e.MouseState === 4) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseRightDown
     * 判断是否鼠标右键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightDown: function(e){
		if (e.MouseButton === 2 && e.MouseState === 0) {
            return true;
        }
	},
	
    /**
     * APIMethod: isRightClick
     * 判断是否鼠标右键点击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isRightClick: function(e){
        //if (e.MouseButton === 2 && e.MouseState === 2) {
        if (e.MouseButton === 2 && e.MouseState === 1) {
            return true;
        }
	},
    
	/**
     * APIMethod: isMouseRightUp
     * 判断是否鼠标右键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightUp: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 2) {
		if (e.MouseButton === 2 && e.MouseState === 1) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseRightDownMove
     * 判断是否鼠标右键按住移动。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightDownMove: function(e){
		if (e.MouseButton === 2 && e.MouseState === 3) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseRightDoubleClick
     * 判断是否鼠标右键双击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightDoubleClick: function(e){
		if (e.MouseButton === 2 && e.MouseState === 4) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseWheel
     * 判断是否鼠标滚轮。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseWheel: function(e){
		if (e.MouseButton === 0 && e.MouseState === 5) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseOut
     * 判断是否鼠标离开三维球体区域。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseOut: function(e){
        if (e.MouseButton === 0 && e.MouseState === 6) {
            return true;
        }
    },
    
    /**
     * APIMethod: isMouseOver
     * 判断是否鼠标进入三维球体区域。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseOver: function(e){
        if (e.MouseButton === 0 && e.MouseState === 7) {
            return true;
        }
    },
	
    /**
     * APIMethod: isMouseRightUp
     * 判断是否鼠标右键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightUp: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 2) {
		if (e.MouseButton === 2 && e.MouseState === 1) {
            return true;
        }
	},
	
    /**
     * APIMethod: getMouseScreen
     * 获取屏幕坐标。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    getMouseScreen: function(e){
        return {
            x: e.ScreenX,
            y: e.ScreenY
        };
    },
    
    /**
     * APIMethod: getMouseLocation
     * 获取地理位置包括经纬度、海拨高度。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    getMouseLocation: function(e){
        return {
            lon: e.X,//e.Longitude,
            lat: e.Y,//e.Latitude,
            alt: e.Altitude
        };
    },
	
	/**
     * APIMethod: isMoveStart
     * 判断是否鼠标移动开始。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMoveStart: function(e){
		if (e.MouseButton === 1 && e.MouseState === 0) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMove
     * 判断是否鼠标移动中。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMove: function(e){
		if (e.MouseButton === 1 && e.MouseState === 3) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMoveEnd
     * 判断是否鼠标移动结束。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMoveEnd: function(e){
		if (e.MouseButton === 1 && e.MouseState === 1) {
            return true;
        }
	},
	
	/**
     * APIMethod: isZoomEnd
     * 判断是否鼠标缩放地图。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isZoomEnd: function(e){
		if (e.MouseButton === 0 && e.MouseState === 5) {
            return true;
        }
	},
//    /**
//     * APIMethod: isKeyDown
//     * 判断是否键盘按键按下。
//     *
//     * Paramters:
//     * e - {Object} 事件对象。
//     */
//    isKeyDown: function(e){
//        if (e.EventType === 6) {
//            return true;
//        }
//     },
//			
//	/**
//     * APIMethod: isKeyUp
//     * 判断是否键盘按键弹起。
//     *
//     * Paramters:
//     * e - {Object} 事件对象。
//     */
//    isKeyUp: function(e){
//        if (e.EventType === 7) {
//            return true;
//        }
//    },
					
    /**
     * Constant: KEY_SPACE
     * {int} 空格键代码。
     */
    KEY_SPACE: 32,
    
    /** 
     * Constant: KEY_LEFT
     * {int} 左方向键代码。
     */
    KEY_LEFT: 37,
    
    /** 
     * Constant: KEY_UP
     * {int} 上方向键代码。
     */
    KEY_UP: 38,
    
    /** 
     * Constant: KEY_RIGHT
     * {int} 右方向键代码。
     */
    KEY_RIGHT: 39,
    
    /** 
     * Constant: KEY_DOWN
     * {int} 下方向键代码。
     */
    KEY_DOWN: 40,
    
    /** 
     * Constant: KEY_PLUS
     * {int} 加号键代码。
     */
    KEY_PLUS: 187,
    
    /** 
     * Constant: KEY_MINUS
     * {int} 减号键代码。
     */
    KEY_MINUS: 189,
    
    CLASS_NAME: "Geo.View3D.Event.MouseEvent"
};
/**
 * Class: Geo.View3D.Handler
 * 三维视图事件监听对象。
 */
Geo.View3D.Handler = Geo.Class({

    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */  
    id: null,

    /**
     * APIProperty: active
     * {String} 是否激活。
     */      
    active: false,

    /**
     * APIProperty: control
     * {String} 所属控件。
     */      
    control: null,

    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 所属地图对象。
     */    
    map: null,

	 
	/**
	 * Constructor: Geo.View3D.Handler
	 * Geo.View3D.Handler构造函数。
	 *
	 * Parameters:
	 * control - {<Geo.View3D.Control>} 监听器所属的控件。
	 * options - {Object} 选项。
	 */	    
    initialize: function(control, callbacks, options){
        
        OpenLayers.Util.extend(this, options);
        this.control = control;
		this.callbacks = callbacks;
		
		var map = this.map || control.map;
        if (map) {
            this.setMap(map); 
        }
		
		this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
    },
 	
	/**
	 * Method: setMap
	 * 将监听器关联到三维地图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维地图对象。
	 */	    
    setMap: function (map) {
        if(map){
            this.map = map;
            this.map.handlers.push(this);
        }
    },
 	
   /**
    * Method: callback
    * 触发控件指定的回调方法。
    *
    * Parameters:
    * name - {String}
    * args - {Array(*)}
    */
    callback: function (name, args) {
        if (name && this.callbacks[name]) {
            this.callbacks[name].apply(this.control, args);
        }
    },

	/**
	 * Method: listener
	 * 监听鼠标事件。
	 *
	 * Parameters:
	 * e - {Object} 三维对象鼠标事件对象。
	 */	     
    listener:function(e){
        
    },

	/**
	 * APIMethod: activate
	 * 激活事件监听器，如果当前监听器已处于激活状态，则返回false。
	 *
	 * Return:
	 * {Boolean} 监听器是否被激活。
	 */	    
    activate: function() {
        if(this.active) {
            return false;
        }
        this.active = true;
        return true;
    },

	/**
	 * APIMethod: deactivate
	 * 关闭事件监听器，如果当前监听器已处于关闭状态，则返回false。
	 *
	 * Return:
	 * {Boolean} 监听器是否被关闭。
	 */    
    deactivate: function() {
        if(!this.active) {
            return false;
        }
        this.active = false;
        return true;
    },

    /**
     * APIMethod: destroy
     * 监听器销毁。
     */
    destroy: function () {
        this.deactivate();
		if(this.map){
			OpenLayers.Util.removeItem(this.map.handlers,this);
		}
        this.control = this.map = null;        
    },
	
    CLASS_NAME: "Geo.View3D.Handler"
});/**
 * Class: Geo.View3D.Handler.Box
 * 三维拉框动作监听类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Box = Geo.Class(Geo.View3D.Handler,{
	
	/**
     * Property: bbox
     * {String} 表示用户拉框的范围。例如： "5,42,10,45"。
     */
	bbox: null,
	
	/**
	 * Constructor: Geo.View3D.Handler.Box
	 * Geo.View3D.Handler.Box构造函数。
	 * 
	 * Parameters:
	 * control - {Geo.View3D.Control}关联的控件。
	 * callbacks - {Object} 回调方法。
	 * options - {Object} 参数选项。
	 */  
    initialize: function(control, callbacks, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
		
    },
	
	/**
     * APIMethod: listener
     * 监听鼠标拉框动作。
     *
     * Parameters:
     * mouseEvent - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(mouseEvent) {
		//鼠标按下时执行
		if(mouseEvent.MouseState == 0 || Geo.View3D.Event.MouseEvent.isRightClick(mouseEvent)){
			this.bbox = mouseEvent.Longitude + "," + mouseEvent.Latitude;
			return;
		}
		//鼠标弹起时执行
		if (mouseEvent.MouseState == 2){
			this.bbox = this.bbox + "," + mouseEvent.Longitude + "," + mouseEvent.Latitude;
		}
		var arr = this.bbox.split(",");
		//排序为左下右上
		var bbox = arr[0] + "," + arr[3] + "," + arr[2] + "," + arr[1];
		this.callback("emitMouseHandler", [bbox]);
		
    },
	
	 /**
     * APIMethod: activate
     * 打开绘制点监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
		//CurrentOpState的值为2时表示拉框
		this.map.activexObj.CurrentOpState = 2;
        return true;
    },
	
	/**
     * APIMethod: deactivate
     * 关闭监听。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
		//恢复CurrentOpState的默认值
		this.map.activexObj.CurrentOpState = 0;
        return true;
    },
	
    CLASS_NAME: "Geo.View3D.Handler.Box"
});/**
 * Class: Geo.View3D.Handler.KeybordDefaults
 * 三维视图的键盘事件监听器。本类负责监听键盘的空格键，上下左右键以及加号减号键。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.KeybordDefaults = Geo.Class(Geo.View3D.Handler, {

    /**
     * APIMethod: listener
     * 键盘事件监听器。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    listener: function(e){
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_SPACE) {
				this.onKeySpace(e);
			} 
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_LEFT) {
				this.onKeyLeft(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_UP) {
				this.onKeyUp(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_RIGHT) {
				this.onKeyRight(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_DOWN) {
				this.onKeyDown(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_PLUS) {
				this.onKeyPlus(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_MINUS) {
				this.onKeyMinus(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_NUM_PLUS) {
				this.onKeyPlus(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_NUM_MINUS) {
				this.onKeyMinus(e);
			}
    },
    
    /**
     * APIMethod: onKeySpace
     * 空格键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeySpace: function(e){
    },
    
    /**
     * APIMethod: onKeyLeft
     * 向左方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyLeft: function(e){
    },
    
    /**
     * APIMethod: onKeyUp
     * 向上方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyUp: function(e){
    },
    
    /**
     * APIMethod: onKeyRight
     * 向右方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyRight: function(e){
    },
    
    /**
     * APIMethod: onKeyDown
     * 向下方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyDown: function(e){
    },
    
    /**
     * APIMethod: onKeyPlus
     * 加号键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyPlus: function(e){
    },
    
    /**
     * APIMethod: onKeyMinus
     * 减号键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyMinus: function(e){
    },
    
    CLASS_NAME: "Geo.View3D.Handler.KeybordDefaults"
});
/**
 * Class: Geo.View3D.Handler.Mouse
 * 三维视图的鼠标事件监听器。本类负责监听鼠标的左键右键和鼠标经过动作。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Mouse = Geo.Class(Geo.View3D.Handler, {

	/**
	 * Constructor: Geo.View3D.Handler.Mouse
	 * Geo.View3D.Handler.Mouse构造函数。
	 * 
	 * Parameters:
	 * control - {Geo.View3D.Control}关联的控件。
	 * callbacks - {Object} 回调方法。
	 * options - {Object} 参数选项。
	 */  
    initialize: function(control, callbacks, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: listener
     * 鼠标事件监听器。
     *
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(e){
		if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
            this.callback("click", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            this.callback("mouseMove", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isMouseOut(e)) {
            this.callback("mouseOut", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isMouseOver(e)) {
            this.callback("mouseOver", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isRightClick(e)) {
            this.callback("rightClick", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isMouseLeftDoubleClick(e)) {
            this.callback("dblclick", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseUp(e)) {
        	this.callback("mouseUp", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseDown(e)) {
        	this.callback("mouseDown", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseWheel(e)) {
        	this.callback("mouseWheel", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseRightUp(e)) {
        	this.callback("mouseRightUp", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMoveStart(e)) {
        	this.callback("movestart", [e]);
        }
		if(Geo.View3D.Event.MouseEvent.isMove(e)) {
        	this.callback("move", [e]);
        }
		if(Geo.View3D.Event.MouseEvent.isMoveEnd(e)) {
        	this.callback("moveend", [e]);
        }
		if(Geo.View3D.Event.MouseEvent.isZoomEnd(e)) {
        	this.callback("zoomend", [e]);
        }
		
    },
    
    CLASS_NAME: "Geo.View3D.Handler.Mouse"
});
/**
 * Class: Geo.View3D.Handler.ModelChoose
 * 三维视图的模型选择事件监听器。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.ModelChoose = Geo.Class(Geo.View3D.Handler, {

    /**
     * Constructor: Geo.View3D.Control.ModelChoose
     * Geo.View3D.Control.ModelChoose构造函数。
     */
    initialize: function(control, callbacks, options){
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: listener
     * 模型点击监听动作。
     *
     * Parameters:
     * mouseEvent - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(mouseEvent){
        var isSelected = false;
        if (this.map && this.map.activexObj) {
            if (mouseEvent.MouseButton == 1 && mouseEvent.MouseState == 1) {
                var modelLayer = null;
                
                var layers = this.map.layers;
                for (var i = 0; i < layers.length; i++) {
                    if (layers[i] instanceof Geo.View3D.Layer.Model) {
                        modelLayer = layers[i];
                    }
                }
                /**
                var x = mouseEvent.ScreenX;
                var y = mouseEvent.ScreenY;
                var pBSTR;
                isSelected = this.map.activexObj.SceneGroup.PerformSelection(modelLayer._layerData, x, y, pBSTR);
                */
				if(null != modelLayer && undefined != modelLayer){
					var layerOP = this.map.activexObj.LayerBox.CreateLayerOperate(modelLayer._layerData);
	            	layerOP.ChangeLayerProperty(6, true);
	                this.map.activexObj.SelectionBox.EnableSelection = true;
				}
				
                var x = mouseEvent.ScreenX;
        	    var y = mouseEvent.ScreenY;
                this.map.activexObj.SelectionBox.SelectByScreenPoint(x, y);
			    isSelected = true;
                this.callback("chooseModel", [mouseEvent, isSelected]);
            }
        }
    },
    
    /**
     * APIMethod: activate
     * 打开模型点击监听器。
     */
    activate: function(){
        if (!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        return true;
    },
    
    /**
     * APIMethod: deactivate
     * 关闭监听动作。
     */
    deactivate: function(){
        if (!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        return true;
    },
    
    CLASS_NAME: "Geo.View3D.Handler.ModelChoose"
});
/**
 * Class: Geo.View3D.Handler.Point
 * 三维视图点几何对象绘制操作事件监听器。该对象激活后，将在三维视图上监听绘制点的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Point = Geo.Class(Geo.View3D.Handler,{
	
	    
    /**
     * APIProperty: point
     * {<Geo.Feature.Vector>} 当前绘制的点要素。
     */
    point: null,

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 用于显示绘制要素的临时三维矢量图层。
     */
    layer: null,

    /**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,


    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,

    /** 
     * Constructor: Geo.View3D.Handler.Point
     * Geo.View3D.Handler.Point构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	           
    listener:function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyDown(e) || Geo.View3D.Event.KeyEvent.isKeyUp(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            return;
        }
		
		var lon = e.X;//e.Longitude;
        var lat = e.Y;//e.Latitude;
				
        if (Geo.View3D.Event.MouseEvent.isMouseDown(e)) {
	        this.createFeature(new Geo.LonLat(lon,lat));
		}
		if (Geo.View3D.Event.MouseEvent.isMouseUp(e)) {
			if(this.persist){
				this.layer.destroyFeatures();
			}

			this.callback("done", [this.point.geometry.clone()]);
		}
		
    },
	
    /**
     * APIMethod: activate
     * 打开绘制点监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		//this._setGeoRaster();
		
        return true;
    },	
				
    /**
     * APIMethod: createFeature
     * 向临时矢量图层添加绘制要素。
     *
     * Parameters:
     * lonlat - {Object} 经纬度信息。
     */
    createFeature: function(lonlat) {
        this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {silent: true});
    },

    /**
     * APIMethod: deactivate
     * 关闭绘制点监听器。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
        if (this.layer.map != null) {
            this.layer.destroy(false);
        }
        this.layer = null;
		
		//this.map.activexObj.SetPickedState(false);
		
        return true;
    },
    
    /**
     * APIMethod: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            this.layer.destroyFeatures();
        }
        this.point = null;
    },

	/**
     * 设置GeoRaster。
     */
    _setGeoRaster:function(){
        var GeoRaster = this.map._geoRaster;
        GeoRaster.GeoRasterType = 1;
        
        //设置精确拾取 开,漫游状态要还原为FALSE
    	this.map.activexObj.SetPickedState(true);  
    },
	
    CLASS_NAME: "Geo.View3D.Handler.Point"
});/**
 * Class: Geo.View3D.Handler.Path
 * 三维视图线几何对象绘制操作事件监听器。该对象激活后，将在三维视图上监听绘制线的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Path = Geo.Class(Geo.View3D.Handler,{

    /**
     * APIProperty: point
     * {<Geo.Feature.Vector>}当前绘制的点要素。
     */
    point: null,	
	
    /**
     * APIProperty: line
     * {<Geo.Feature.Vector>}当前绘制的线要素。
     */
    line: null,	    

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 用于显示绘制要素的临时三维矢量图层。
     */
    layer: null,

    /**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,


    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,
	
	//标记线是否点击右键绘制完成
	_isDone: false,

    /** 
     * Constructor: Geo.View3D.Handler.Path
     * Geo.View3D.Handler.Path构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	           
    listener:function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyDown(e) || Geo.View3D.Event.KeyEvent.isKeyUp(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
			//alert(e.MouseButton +"   "+ e.MouseState);
			//结束当前线绘制后，再次点击清除前次绘制
			if(this._isDone){
				//this.layer.removeFeatures(this.line);
				this.line = null;
				this._isDone = false;
			}
			var GeoRaster = this.map._geoRaster;
	        var lon = e.X;//e.Longitude;
	        var lat = e.Y;//e.Latitude;
			this.addPoint(new Geo.LonLat(lon,lat));
			this.callback("point", [this.point.geometry, this.line.geometry]);
		}
//		if(Geo.View3D.Event.MouseEvent.isRightClick(e)){
//			//alert(e.MouseButton +"   "+ e.MouseState);
//			this._isDone = true;
//            if(this.persist){
//				this.layer.destroyFeatures();
//			}
//            if (this.line) {
//                this.callback("done", [this.line.geometry.clone()]);
//                //var GeoRaster = this.map._geoRaster;
//                //this.map.activexObj.SetPickedState(false);
//            }
//		}
		if(Geo.View3D.Event.MouseEvent.isMouseLeftDoubleClick(e)){
			this.handleDouble();
		}
    },
	
    /**
     * APIMethod: activate
     * 打开绘制线监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		//this._setGeoRaster();
		
        return true;
    },	
	
	/**
	 * APIMethod: addPoint
	 * 添加点的方法。
	 * 
     * Parameters:
     * lonlat - {Object} 经纬度信息。
	 */	 
	addPoint:function(lonlat){
		this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        this.point.geometry.clearBounds();
		
		var lineGeometry;
		if(!this.line){
			lineGeometry = new Geo.Geometry.LineString([this.point.geometry]);
		} else {
			var points = this.line.geometry.components;
			points.push(this.point.geometry);
			lineGeometry = new Geo.Geometry.LineString(points);
		}
		this.layer.removeFeatures(this.line);
		this.line = new Geo.Feature.Vector(lineGeometry);
		this.layer.addFeatures([this.line], {silent: true});
	},
				
    /**
     * APIMethod: createFeature
     * 向临时矢量图层添加绘制要素。
     *
     * Parameters:
     * lonlat - {Object} 经纬度信息。
     */
    createFeature: function(lonlat) {
        this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        //this.callback("create", [this.point.geometry, this.point]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {silent: true});
    },

    /**
     * APIMethod: deactivate
     * 关闭绘制线监听器。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
        if (this.layer.map != null) {
            this.layer.destroy(false);
        }
        this.layer = null;
		
		//this.map.activexObj.SetPickedState(false);
		
        return true;
    },
    
    /**
     * APIMethod: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            this.layer.destroyFeatures();
        }
        this.point = null;
		this.line = null;
    },
	
    /**
     * 设置GeoRaster。
     */
    _setGeoRaster:function(){
        var GeoRaster = this.map._geoRaster;
        GeoRaster.GeoRasterType = 1;
        
        //设置精确拾取 开,漫游状态要还原为FALSE
    	this.map.activexObj.SetPickedState(true);  
    },
	
	/**
     * Method: handleDouble
     * 处理双击
     */
	handleDouble: function() {
        if (this.timerId) {
            window.clearTimeout(this.timerId);
            this.timerId = null;
        }
        this.timerId = window.setTimeout(
            OpenLayers.Function.bind(function() {
                this.timerId = null;
				this.finishGeometry();
            }, this), 300);
    },
	
	/**
     * Method: finishGeometry
     * 完成要素绘制
     */
	finishGeometry:function(){
		this._isDone = true;
        if(this.persist){
			this.layer.destroyFeatures();
		}
        if (this.line) {
            this.callback("done", [this.line.geometry.clone()]);
        }
	},
	
    CLASS_NAME: "Geo.View3D.Handler.Path"
});/**
 * Class: Geo.View3D.Handler.Polygon
 * 三维视图面几何对象绘制操作事件监听器。该对象激活后，将在三维视图上监听绘制面的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Polygon = Geo.Class(Geo.View3D.Handler,{

	_points: [],

    /**
     * APIProperty: point
     * {<Geo.Feature.Vector>}当前绘制的点要素。
     */
    point: null,	
	
    /**
     * APIProperty: polygon
     * {<Geo.Feature.Vector>}当前绘制的线要素。
     */
    polygon: null,	    

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 用于显示绘制要素的临时三维矢量图层。
     */
    layer: null,

    /**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,
	
    /**
     * APIProperty: checkSelfCross
     * {Boolean} 是否允许多边形自相交。
     */
	checkSelfCross: true,

	//标记线是否点击右键绘制完成
	_isDone: false,

    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,
    
    /** 
     * Constructor: Geo.View3D.Handler.Polygon
     * Geo.View3D.Handler.Polygon构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	           
    listener:function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyDown(e) || Geo.View3D.Event.KeyEvent.isKeyUp(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
			//alert(e.MouseButton +" L  "+ e.MouseState);
			//结束当前线绘制后，再次点击清除前次绘制
			if(this._isDone){
//				this.layer.removeFeatures(this.polygon);
				this.polygon = null;
				this._isDone = false;
			}
			
	        var lon = e.X;//e.Longitude;
	        var lat = e.Y;//e.Latitude;
			
			//临时保存点击的点供自相交检查
			this._points.push(new Geo.Geometry.Point(lon, lat));
			var linearRingGeometry = new Geo.Geometry.LinearRing(this._points);
			var polygonGeometry = new Geo.Geometry.Polygon([linearRingGeometry]);
		
            //做自相交检查，如果要求做相交检查而且自相交则不添加点
//            if(this.checkSelfCross && this._checkSelfCross(polygonGeometry)){
//                return;
//            }

			this.addPoint(new Geo.LonLat(lon,lat));
			this.callback("point", [this.point.geometry, this.polygon.geometry]);
		}
//		if(Geo.View3D.Event.MouseEvent.isRightClick(e)){
//			//alert(e.MouseButton +" R  "+ e.MouseState);
//			this._isDone = true;
//			this._points = [];
//            if(this.persist){
//				this.layer.destroyFeatures();
//			}
//            if (this.polygon) {
//                this.callback("done", [this.polygon.geometry.clone()]);
//                //this.map.activexObj.SetPickedState(false);
//            }
//		}
		//处理鼠标左键双击
		if(Geo.View3D.Event.MouseEvent.isMouseLeftDoubleClick(e)){
			this.handleDouble();
		}
    },
	
    /**
     * APIMethod: activate
     * 打开绘制面监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		//this._setGeoRaster();
		
        return true;
    },	
	
	/**
	 * APIMethod: addPoint
	 * 添加点的方法。
	 * 
     * Parameters:
     * lonlat - {Object} 经纬度信息。
	 */	   
	addPoint:function(lonlat){
		this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        this.point.geometry.clearBounds();
		
		var polygonGeometry;
		var linearRingGeometry;
		if(!this.polygon){
			linearRingGeometry = new Geo.Geometry.LinearRing([this.point.geometry]);
		} else {
			var points = this.polygon.geometry.components[0].components;
			points.push(this.point.geometry);
			linearRingGeometry = new Geo.Geometry.LinearRing(points);
		}
		polygonGeometry = new Geo.Geometry.Polygon([linearRingGeometry]);
		this.layer.removeFeatures(this.polygon);
		this.polygon = new Geo.Feature.Vector(polygonGeometry);
		this.layer.addFeatures([this.polygon], {silent: true});
	},
				
    /**
     * APIMethod: createFeature
     * 向临时矢量图层添加绘制要素。
     *
     * Parameters:
     * lonlat - {Object} 经纬度信息。
     */
    createFeature: function(lonlat) {
        this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        //this.callback("create", [this.point.geometry, this.point]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {silent: true});
    },

    /**
     * APIMethod: deactivate
     * 关闭绘制面监听器。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
        if (this.layer.map != null) {
            this.layer.destroy(false);
        }
        this.layer = null;
		
		//this.map.activexObj.SetPickedState(false);
		
        return true;
    },
    
    /**
     * APIMethod: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            this.layer.destroyFeatures();
        }
        this.point = null;
        this.polygon = null;
    },
    
	//设置GeoRaster
    _setGeoRaster:function(){
        var GeoRaster = this.map._geoRaster;
        GeoRaster.GeoRasterType = 1;
        
        //设置精确拾取 开,漫游状态要还原为FALSE
    	this.map.activexObj.SetPickedState(true);  
    },
    
    //检查传入的点串有没有自交叉
    _checkSelfCross:function(allPoints){
        var checkPoints = this._getPointsSpaceSplitStr(allPoints);
        var Globe = this.map.activexObj;
        return Globe.SetTerrainAnalysisParam(checkPoints, 0, -1);
    },
	
    //将点数组转换成空格分隔的字符串
    _getPointsSpaceSplitStr:function(polygonGeometry){
		var linearRing = polygonGeometry.components[0];
		var allPoints = linearRing.components;
		
        var points = [];
        for(var i=0; i<allPoints.length; i++){
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
        }
        return points.join(" ");
    },	
	
	/**
     * Method: handleDouble
     * 双击处理
     */
	handleDouble: function() {
        if (this.timerId) {
            window.clearTimeout(this.timerId);
            this.timerId = null;
        }
        this.timerId = window.setTimeout(
            OpenLayers.Function.bind(function() {
                this.timerId = null;
				this.finishGeometry();
            }, this), 300);
    },
	
	/**
     * Method: finishGeometry
     * 完成要素绘制
     */
	finishGeometry:function(){
		this._isDone = true;
		this._points = [];
        if(this.persist){
			this.layer.destroyFeatures();
		}
        if (this.polygon) {
            this.callback("done", [this.polygon.geometry.clone()]);
            //this.map.activexObj.SetPickedState(false);
        }
	},
	
    CLASS_NAME: "Geo.View3D.Handler.Polygon"
});/**
 * Class: Geo.View3D.Handler.Feature
 * 三维视图要素选择对象操作事件监听器。该对象激活后，将在三维视图上监听要素选择的操作。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Feature = Geo.Class(Geo.View3D.Handler,{

    //保存鼠标最后移入的要素id
    _feature: null,
	
    //是否启用图层选择功能
    _isEnableLayerSelect: false,

    /** 
     * Constructor: Geo.View3D.Handler.Feature
     * Geo.View3D.Handler.Feature构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
        this.control = control;
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	
    listener:function(e){
        var control = this.control;
        var globe = control.map.activexObj;
        var vectorLayer = control.layer;
        this._enableLayerSelect();
        var featureId = this._getFeatureIdFromScreen(e.ScreenX, e.ScreenY);
        var feature = control._getFeatureFromId(featureId);
        if (control.hover && Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            if(featureId && this._feature !== featureId){
                control.select(feature);
                this._feature = featureId;
            }
            if(!featureId && this._feature){
                control.unselect(feature);
                this._feature = null;
            }
        }
        //监听鼠标左键点击下
        if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
        	 if(featureId){
                control.select(feature);
                this._feature = featureId;
            }
        }
        //监听鼠标移动下，取消选择要素
		if(control.moveMapPopupClose == true && Geo.View3D.Event.MouseEvent.isMouseDownMove(e)){
        	if(!featureId && this._feature){
                control.unselect(feature);
                this._feature = null;
            }
        }
        //监听鼠标左击，取消选择要素
        if(control.moveMapPopupClose == false &&  Geo.View3D.Event.MouseEvent.isLeftClick(e)){
        	if(!featureId && this._feature){
                control.unselect(feature);
                this._feature = null;
            }
        }
    },

    //打开底层矢量图层选择功能
    _enableLayerSelect: function(){
        if(this._isEnableLayerSelect){
            return;
        }
        var control = this.control;
        var globe = control.map.activexObj;
        var vectorLayer = control.layer;
        //打开SelectionBox的选择功能，打开图层的选择功能
        globe.SelectionBox.EnableSelection = true;
        //针对标注
        var layerOp = globe.LayerBox.CreateLayerOperate(vectorLayer._dynamicLayer);
        layerOp.ChangeLayerProperty(6, true);
        //针对线面
        var layerOp2 = globe.LayerBox.CreateLayerOperate(vectorLayer._layerData);
        layerOp2.ChangeLayerProperty(6, true);
        this._isEnableLayerSelect = true;
    },

    //根据屏幕坐标查询对应要素id
    _getFeatureIdFromScreen: function(screenX,screenY){
        var control = this.control;
        var featureId = false;
        var globe = control.map.activexObj;
        globe.SelectionBox.SelectByScreenPoint(screenX, screenY);

        if(globe.SelectionBox.Count == 0){
            return featureId;
        }
        var box = globe.SelectionBox.QuerySelectedObject(0);
		if(box){
	        if( null == box.POIID || undefined == box.POIID){
	            featureId = box.Key;
	        } else {
	            featureId = box.POIGUID;
	        }			
		}
        return featureId;
    },

    CLASS_NAME: "Geo.View3D.Handler.Feature"
});/**
 * Class: Geo.View3D.Handler.Keyboard
 * 三维视图的键盘事件监听器。本类负责监听键盘的按下和抬起事件。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Keyboard = Geo.Class(Geo.View3D.Handler, {

	/**
	 * Constructor: Geo.View3D.Handler.Keyboard
	 * Geo.View3D.Handler.Keyboard构造函数。
	 * 
	 * Parameters:
	 * control - {Geo.View3D.Control}关联的控件。
	 * callbacks - {Object} 回调方法。
	 * options - {Object} 参数选项。
	 */  
    initialize: function(control, callbacks, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: listener
     * 鼠标事件监听器。
     *
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyboardDown(e)) {
            this.callback("keyboardDown", [e]);
        }
        if (Geo.View3D.Event.KeyEvent.isKeyboardUp(e)) {
            this.callback("keyboardUp", [e]);
        }
    },
    
    CLASS_NAME: "Geo.View3D.Handler.Keyboard"
});
/**
 * Class: Geo.View3D.Control
 * 三维视图控件基类。本类不直接使用,需要由子类继承。
 */
Geo.View3D.Control = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */      
    id: null,

    /**
     * APIProperty: autoActivate
     * {Boolean} 控件加入地图后是否自动激活。
     */      
    autoActivate: false,

    /**
     * APIProperty: active
     * {Boolean} 控件当前激活状态。
     */    
    active: false,

    /**
     * APIProperty: handler
     * {Object} 三维视图事件监听对象。
     */      
    handler: null,
	
    /**
     * APIProperty: eventListeners
     * {Object} 三维视图事件监听器。
     */      
    eventListeners: null,
	
    /**
     * APIProperty: events
     * {Object} 三维视图事件。
     */      
    events: null,
	
    /**
     * APIProperty: EVENT_TYPES
     * {Array} 控件基类所支持的事件类型。
     */     
    EVENT_TYPES: ["activate", "deactivate"],

    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 控件所属地图对象。
     */
    map: null,

	/**
	 * Constructor: Geo.View3D.Control
	 * Geo.View3D.Control构造函数。
	 *
	 * Parameters:
	 * options - {Object} 相关参数选项。
	 */    
    initialize: function(options){
        OpenLayers.Util.extend(this, options);
        
        this.events = new OpenLayers.Events(this, null, this.EVENT_TYPES);
        if(this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
        if (this.id == null) {
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }
    },

	/**
	 * APIMethod: setMap
	 * 将控件关联到地图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维地图对象。
	 */	    
    setMap: function(map) {
        this.map = map;
        if (this.handler) {
            this.handler.setMap(map);
        }
    },
    
    //控件绘制，由子类实现
    draw: function(px){
        
    },

	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 *
	 * Parameters:
	 * e - {Object} 三维地图鼠标事件对象。
	 */	     
    listener:function(e){
        
    },

	/**
	 * APIMethod: activate
	 * 激活控件。如果当前控件已经处于激活状态则返回false，否则激活该控件的事件监听器handler，并且触发该控件的"activate"事件，返回true。
	 */	     
    activate: function () {
        if (this.active) {
            return false;
        }
        if (this.handler) {
            this.handler.activate();
        }
        this.active = true;
        this.events.triggerEvent("activate");
        return true;
    },

	/**
	 * APIMethod: deactivate
	 * 关闭控件。如果当前控件已经处于关闭状态则返回false，否则关闭该控件的事件监听器handler，并且触发该控件的"deactivate"事件，返回true。
	 */	    
    deactivate: function () {
        if (this.active) {
            if (this.handler) {
                this.handler.deactivate();
            }
            this.active = false;
            this.events.triggerEvent("deactivate");
            return true;
        }
        return false;
    },
    
	/**
	 * APIMethod: destroy
	 * 销毁控件。
	 */	  
    destroy: function () {
        if(this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
            this.events = null;
        }
        this.eventListeners = null;

        // eliminate circular references
        if (this.handler) {
            this.handler.destroy();
            this.handler = null;
        }
        if(this.handlers) {
            for(var key in this.handlers) {
                if(this.handlers.hasOwnProperty(key) &&
                   typeof this.handlers[key].destroy == "function") {
                    this.handlers[key].destroy();
                }
            }
            this.handlers = null;
        }
        if (this.map) {
            this.map.removeControl(this);
            this.map = null;
        }
    },
	  
    CLASS_NAME: "Geo.View3D.Control"
});/**
 * Class: Geo.View3D.Control.KeyboardDefaults
 * 三维视图键盘控制控件类。使用本控件可以实现用键盘进行三维视图的平移以及缩小放大功能。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.KeyboardDefaults = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: autoActivate
     * 设置控件为加入地图中自动激活。
     */
    autoActivate: true,
    
    /**
     * APIProperty: delta
     * 按下方向键时平移增量。
     */
    delta: 0,
    
    /**
     * Constructor: Geo.View3D.Control.KeyboardDefaults
     * Geo.View3D.Control.KeyboardDefaults构造函数。
     */
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
        this.handler = new Geo.View3D.Handler.KeybordDefaults(this, null, {
            onKeySpace: OpenLayers.Function.bind(this.resetNorth, this),
            onKeyLeft: OpenLayers.Function.bind(this.panLeft, this),
            onKeyUp: OpenLayers.Function.bind(this.panUp, this),
            onKeyRight: OpenLayers.Function.bind(this.panRight, this),
            onKeyDown: OpenLayers.Function.bind(this.panDown, this),
            onKeyPlus: OpenLayers.Function.bind(this.zoomIn, this),
            onKeyMinus: OpenLayers.Function.bind(this.zoomOut, this)
        });
    },
    
    /**
     * APIMethod: resetNorth
     * 重新设置指北方向。
     */
    resetNorth: function(){
        if (this.map) {
            this.map.resetNorth();
        }
    },
    
    /**
     * APIMethod: panLeft
     * 三维视图向左平移。
     */
    panLeft: function(){
        this.pan("left");
    },
    
    /**
     * APIMethod: panUp
     * 三维视图向上平移。
     */
    panUp: function(){
        this.pan("up");
    },
    
    /**
     * APIMethod: panRight
     * 三维视图向右平移。
     */
    panRight: function(){
        this.pan("right");
    },
    
    /**
     * APIMethod: panDown
     * 三维视图向下平移。
     */
    panDown: function(){
        this.pan("down");
    },
    
    /**
     * APIMethod: pan
     * 三维视图平移。
     *
     * Paramters:
     * type - {String} 方向类型，其值可为："left"、"up"、"right"、"down"。
     */
    pan: function(type){
        var globe = this.map.activexObj;
        var delta = this.delta;//15;//globe.GetCamera().ViewRange;
        var camera = globe.Camera;
        switch (type) {
            case "left":
                camera.Pan(-delta, 0);
                break;
            case "up":
                camera.Pan(0, delta);
                break;
            case "right":
                camera.Pan(delta, 0);
                break;
            case "down":
                camera.Pan(0, -delta);
                break;
        }
    },
    
    /**
     * APIMethod: zoomIn
     * 地图放大。
     */
    zoomIn: function(){
        var map = this.map;
        if (map) {
            map.zoomIn();
        }
    },
    
    /**
     * APIMethod: zoomOut
     * 地图缩小。
     */
    zoomOut: function(){
        var map = this.map;
        if (map) {
            map.zoomOut();
        }
    },
	
    CLASS_NAME: "Geo.View3D.Control.KeyboardDefaults"
});
/**
 * Class: Geo.View3D.Control.Measure
 * 量算类。
 * (code)
 * 使用方法：
 * 1.构造一个实例与地图关联，将自己的事件分派器与地图量算响应方法相关联。
 * 2.添加针对不同的量算类型添加绘制不同类型几何体的HANDLER。
 * 3.捕获到绘点线面的动作后调用响应方法。
 * (end)
 * Inherits from:
 *  - <Geo.View3D.Control>
 *
 */
Geo.View3D.Control.Measure = Geo.Class(Geo.View3D.Control, {

    /**
     * 量算服务地址。
     */
    serviceUrl: null,
    
    /**
     * 图层等级
     */
    layerLevel: null,
    
    /**
     * 图层名称
     */
    layerName: null,
    
    /**
     * 失败回调函数
     */
    failFn: null,
    
    /**
     * 地形分析服务对象。
     */
    _terrainAnalysisService: null,
    
    /**
     * 监听器类型由量算子类设置。
     */
    handlerType: null,
    
    /**
     * 监听器构造参数。
     */
    handlerOptions: null,
    
    /**
     * 点。
     */
    _points: null,
    
    /**
     * 临时保存量算结果。
     */
    _result: null,
    
    /**
     * {Object} The functions that are sent to the handler for callback
     */
    callbacks: null,
    
    /**
     * 构造函数。生成一个Geo.View3D.Control.Measure的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.serviceUrl = serviceUrl;
        this._terrainAnalysisService = new Geo.Service.TAS(this.id + "_service", serviceUrl);
        this.callbacks = OpenLayers.Util.extend({
            done: this._onComplete,
            point: this._onAddPoint
        }, this.callbacks);
        this.handlerOptions = this.handlerOptions || {};
        if (this.handlerType) {
            this.handler = new this.handlerType(this, this.callbacks, this.handlerOptions);
        }
        
    },
    
    /**
     * 量算完成。
     */
    _isComplete: false,
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     */
    onAddPoint: function(){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     */
    onComplete: function(result){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     */
    _onComplete: function(geometry){
    },
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     */
    _onAddPoint: function(){
    },
    
    /**
     * 量算监听器
     */
    _measureHandler: function(mouseEvent){
    },
    
    /**
     * 设置量算服务地址
     */
    setMeasureService: function(url){
        if (url && this._terrainAnalysisService) {
            this._terrainAnalysisService.url = url;
        }
    },
    
    /**
     * 获取量算结果
     */
    _getMeasureResult: function(type, options, successFn){
        var defaultOptions = {
            pointCount: this._terrainAnalysisService._countCoord(options.coordinates),
            layerLevel: this.layerLevel,
            layerName: this.layerName,
            subjoin: 0
        };
        options = OpenLayers.Util.applyDefaults(options, defaultOptions);
        
        var serivce = this._terrainAnalysisService;
        if (serivce) {
            serivce[type](options, successFn, this.failFn);
        }
    },
    
    /**
     * 激活量算控件
     */
    activate: function(){
        if (Geo.View3D.Control.prototype.activate.apply(this, arguments)) {
            this.map._measureHandler = OpenLayers.Function.bind(this._measureHandler, this);
            this.setMeasureService(this.serviceUrl);
        }
        return true;
    },
    
    /**
     * 将二维点数组，加上指高度形成三维点数组转换成空格分隔的字符串
     */
    _getPointsThreeDegreeSpaceSplitStr: function(polygonGeometry, height){
        var linearRing = polygonGeometry.components[0];
        var allPoints = linearRing.components;
        
        var points = [];
        for (var i = 0; i < allPoints.length; i++) {
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
            points.push(height);
        }
        return points.join(" ");
    },
    
    /**
     * 将点数组转换成空格分隔的字符串
     */
    _getPointsSpaceSplitStr: function(polygonGeometry){
        var linearRing = polygonGeometry.components[0];
        var allPoints = linearRing.components;
        
        var points = [];
        for (var i = 0; i < allPoints.length; i++) {
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
        }
        return points.join(" ");
    },
    
    /**
     * 设置量算分析服务参数
     */
    _setMeasureParams: function(type, pointsString, boxHeight){
        var Globe = this.map.activexObj;
        if (type !== undefined) {
            Globe.SetTerrainAnalysisParam(pointsString, boxHeight, type);
        }
    },
    
    /**
     * 删除盒子图层
     */
    _clearBoxLayer: function(){
        var Globe = this.map.activexObj;
        var layer = Globe.GetSceneGroup().GetLayerByName(this.id + "_boxLayer");
        if (layer != null) {
            Globe.GetSceneGroup().RemoveLayer(layer);
        }
    },
    
    /**
     * 画盒子图层
     */
    _createBoxLayer: function(mousePoints){
    
        var Globe = this.map.activexObj;
        
        // 画盒子用接口
        var LocalDataBox = Globe.CreateAddLocalDataObj();
        
        var pointstr = this._getPointsThreeDegreeSpaceSplitStr(mousePoints, 0);
        
        
        var boxLayerId = this.id + "_boxLayer";
        var layerdata = LocalDataBox.AddPolyGon(boxLayerId, pointstr);
        
        layerdata.name = boxLayerId;
        LocalDataBox.setPolyGonHeight(boxLayerId, this.height);
        LocalDataBox.SetBoxFaceColor(boxLayerId, 0x7fffffff, 0x7fffffff, 0x7fffffff)
        
    },
    
    CLASS_NAME: "Geo.View3D.Control.Measure"
});
/**
 * Class: Geo.View3D.Control.DrawPath
 * 几何线绘制控件类。使用本控件可以在三维地图上画线。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawPath = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: type
     * 控件类型。 
     */  
    type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
    
	/**
	 * Constructor: Geo.View3D.Control.DrawPath
	 * Geo.View3D.Control.DrawPath构造函数。
	 */    
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                "done": this.done
            },
            this.callbacks
        );
        this.handlerOptions = this.handlerOptions || {};        
        this.handler = new Geo.View3D.Handler.Path(this, this.callbacks, this.handlerOptions);
    },

    /**
     * APIMethod: done
     * 几何对象绘制完成回调函数，用户可以使用自己的方法来覆盖它。
     * 
     * Paramters:
     * geometry - 绘制的几何对象。
     */   	
    done: function(geometry){
        
    }
    
});
/**
 * Class: Geo.View3D.Control.DrawPoint
 * 几何点绘制控件类。使用本控件可以在三维地图上画点。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawPoint = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: type
     * 控件类型。
     */
    type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
       
 	/**
	 * Constructor: Geo.View3D.Control.DrawPoint
	 * Geo.View3D.Control.DrawPoint构造函数。
	 */     
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                "done": this.done
            },
            this.callbacks
        );
        this.handlerOptions = this.handlerOptions || {};
        this.handler = new Geo.View3D.Handler.Point(this, this.callbacks, this.handlerOptions);
    },
	
    /**
     * APIMethod: done
     * 几何对象绘制完成回调函数，用户可以使用自己的方法来覆盖它。
     * 
     * Paramters:
     * geometry - 绘制的几何对象。
     */   	
    done: function(geometry){
        
    }
    
});
/**
 * Class: Geo.View3D.Control.DrawPolygon
 * 几何多边形绘制控件类。使用本控件可以在三维地图上画面。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawPolygon = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: type
     * 控件类型。 
     */
    type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
     
 	/**
	 * Constructor: Geo.View3D.Control.DrawPolygon
	 * Geo.View3D.Control.DrawPolygon构造函数。
	 */   
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                "done": this.done
            },
            this.callbacks
        );
        this.handlerOptions = this.handlerOptions || {};
        this.handler = new Geo.View3D.Handler.Polygon(this, this.callbacks, this.handlerOptions);
    },
	
    /**
     * APIMethod: done
     * 几何对象绘制完成回调函数，用户可以使用自己的方法来覆盖它。
     * Paramters:
     * geometry - 绘制的几何对象。
     */       
    done: function(geometry){
        
    }
    
});
/**
 * Class: Geo.View3D.Control.DrawFeature
 * 要素绘制控件可以在三维矢量图层上通过鼠标绘制点、线、面要素。
 *
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawFeature = Geo.Class(Geo.View3D.Control, {
    
    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 矢量图层对象。
     */
    layer: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */
    callbacks: null,
    
    /**
     * APIProperty: EVENT_TYPES
     * 触发的事件类型。
     */
    EVENT_TYPES: ["featureadded"],

	/**
     * APIMethod: featureAdded
     * 当在地图上绘画一个要素的时候会触发本方法。
     */
    featureAdded: function() {},

    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,
    
    /**
     * Constructor: Geo.View3D.Control.DrawFeature
     * Geo.View3D.Control.DrawFeature构造函数。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer.Vector>} 
     * handler - {<Geo.View3D.Handler>} 
     * options - {Object} 
     */
    initialize: function(layer, handler, options) {
        
        // concatenate events specific to vector with those from the base
        this.EVENT_TYPES =
            Geo.View3D.Control.DrawFeature.prototype.EVENT_TYPES.concat(
            Geo.View3D.Control.prototype.EVENT_TYPES
        );
        
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                done: this.drawFeature
            },
            this.callbacks
        );
        this.layer = layer;
        this.handlerOptions = this.handlerOptions || {};

        var sketchStyle = this.layer.styleMap && this.layer.styleMap.styles.temporary;
        if(sketchStyle) {
            this.handlerOptions.layerOptions = OpenLayers.Util.applyDefaults(
                this.handlerOptions.layerOptions,
                {styleMap: new Geo.StyleMap({"default": sketchStyle})}
            );
        }
        this.handler = new handler(this, this.callbacks, this.handlerOptions);
    },

	/**
     * APIMethod: drawFeature
     * 在三维视图上绘制要素图层。
	 * 
	 * Paramters:
	 * geometry - {Object} 绘制的几何对象。
     */
    drawFeature: function(geometry) {
        var feature = new Geo.Feature.Vector(geometry);
        this.layer.addFeatures([feature]);
        this.featureAdded(feature);
        this.events.triggerEvent("featureadded",{feature : feature});
    },
	
    CLASS_NAME: "Geo.View3D.Control.DrawFeature"
});/**
 * Class: Geo.View3D.Control.SelectFeature
 * 三维视图下要素选择控件，该控件实现在指定的的图层上通过鼠标单击和悬浮选择矢量要素。
 *
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.SelectFeature = Geo.Class(Geo.View3D.Control, {

    clickout: true,

    multiple: false,

    EVENT_TYPES: ["beforefeaturehighlighted", "featurehighlighted", "featureunhighlighted"],
	
   /**
    * APIProperty: hover
    * {boolean} 在鼠标悬浮在要素上时，选中要素；移出要素时，取消选中。若设置为true，鼠标点击将不起作用。默认为false。
    */
    hover: false,	
	
	/**
	 * APIProperty: moveMapPopupClose
     * {boolean} 默认在鼠标拖动地图时，弹出的浮云框不会自动关闭。若设置为true，鼠标拖动地图时，浮云框会自动关闭。默认为false。
	 */
	moveMapPopupClose:false,

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 要素选择控件所对应的矢量图层
     */
    layer: null,
	
    /**
     * APIProperty: scope
     * {Object} onBeforeSelect, onSelect, onUnselect等回调方法的上下文，即this的指向。如果为null值，则指向要素选择控件本身。
     * 
     */
    scope: null,

    /**
     * APIProperty: onBeforeSelect
     * {Function} 要素被选中之前可以调用该方法，完成用户指定的任务。要求用户定义具体方法，该方法接收当前选中要素作为参数。
     */
    onBeforeSelect: function() {},

    /**
     * APIProperty: onSelect
     * {Function} 要素被选中后可以调用该方法，完成用户指定的任务。要求用户定义具体方法，该方法接收当前选中要素作为参数。
     */
    onSelect: function() {},

    /**
     * APIProperty: onUnselect
     * {Function} 要素取消选择后可以调用该方法，完成用户指定的任务。要求用户定义具体方法，该方法接收当前选中要素作为参数。
     */
    onUnselect: function() {},	

    /**
     * Constructor: Geo.View3D.Control.SelectFeature
     * Geo.View3D.Control.SelectFeature构造函数
     *
     * Parameters:
     * layer - {<Geo.View3D.Layer.Vector>} 要素选择控件所对应的矢量图层
     * options - {Object} 构造参数
     */
    initialize: function(layer, options) {
        this.EVENT_TYPES =
            Geo.View3D.Control.SelectFeature.prototype.EVENT_TYPES.concat(
            Geo.View3D.Control.prototype.EVENT_TYPES
        );
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.handler = new Geo.View3D.Handler.Feature(this);
        this.layer = layer;
    },

    highlight: function(feature) {
        var layer = feature.layer;
    },


    unhighlight: function(feature) {
        var layer = feature.layer;
    },

    onSelect: function(feature){

    },
	
    /**
     * APIMethod: destroy
     * 销毁方法
     */
    destroy: function() {
    },	
	
    /**
     * APIMethod: setMap
     * 将控件关联到地图
     *
     * Parameters:
     * map - {<OpenLayers.Map>}
     */
    setMap: function(map) {
        Geo.View3D.Control.prototype.setMap.apply(this, arguments);
    },	

    /**
     * APIMethod: select
     * 选择要素，将指定要素添加到矢量图层的selectedFeatures数组中，重新以被选中样式绘制要素，
     * 并且调用onSelect方法。
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>}
     */
    select: function(feature) {
        //var feature = this._getFeatureFromId(featureId);
		if(null == feature || undefined == feature) return;
		var cont = this.onBeforeSelect.call(this.scope, feature);
        var layer = feature.layer;
        if(cont !== false) {
            cont = layer.events.triggerEvent("beforefeatureselected", {
                feature: feature
            });
            if(cont !== false) {
                if(this.multiple){
                    layer.selectedFeatures.push(feature);
                } else {
                    layer.selectedFeatures = [feature];
                }
                this.highlight(feature);
                layer.events.triggerEvent("featureselected", {feature: feature});
                this.onSelect.call(this.scope, feature);
            }
        }
    },

    _getFeatureFromId: function(featureId){
        var features = this.layer.features;
        for(var i=0; i<features.length; i++){
            var f = features[i];
            if(f.id === featureId){
                return f;
            };
        }
    },

    /**
     * APIMethod: unselect
     * 取消选择要素
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>}
     */
    unselect: function(feature) {
        //var feature = this._getFeatureFromId(featureId);
        if(null == feature || undefined == feature) return;
        var layer = feature.layer;
        this.unhighlight(feature);
        OpenLayers.Util.removeItem(layer.selectedFeatures, feature);
        this.onUnselect.call(this.scope, feature);
    },
	
    /**
     * APIMethod: unselectAll
     * 取消所有被选择要素
     *
     */
    unselectAll: function() {
        var layer = this.layer, feature;
        for(var i=layer.selectedFeatures.length-1; i>=0; --i) {
            feature = layer.selectedFeatures[i];
        }
    },	

    /**
     * APIProperty: CLASS_NAME
     * {String} 类名标识 - "Geo.View3D.Control.SelectFeature"
     * 
     */
    CLASS_NAME: "Geo.View3D.Control.SelectFeature"
});/**
 * Class: Geo.View3D.Control.Attribution
 * 图层属性信息控件。
 *
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Attribution = 
  Geo.Class(Geo.View3D.Control, {
    
    /**
     * APIProperty: seperator
     * {String} 分隔符，用于分隔单个图层信息。不可以为HTML，可以加入转义符，例如："layer1\nlayer2"。
     */
    separator: ",",
	
	/**
	 * APIProperty: style
	 * {Object} 控件信息显示的样式。
	 * Symbolizer properties:
	 * startX - {Number} 以视图左上角为原点（0,0），文字框的左上点距离三维视图左边框的像素点。
	 * startY - {Number} 文字框的左上点距离三维视图上边框的像素点。
	 * endX - {Number} 文字框的右下点距离三维视图左边框的像素点。
	 * endY - {Number} 文字框的右下点距离三维视图上边框的像素点。
	 * fontSize - {Number} 字体大小。
	 * fontFamily - {String} 字体系列。
	 * opacity - {Number} 透明度。
	 * colorR - {Number} 颜色：红色的值。
	 * colorG - {Number} 颜色：绿色的值。
	 * colorB - {Number} 颜色：蓝色的值。
	 */
	style: {
		startX: 10,
		startY: 10,
		endX: 300,
		endY: 300,
		fontSize: 20,
		fontFamily: "雅黑",
		opacity: 255,
		colorR: 255,
		colorG: 255,
		colorB: 0
	},
    
    /**
     * Constructor: Geo.View3D.Control.Attribution 
     * 构造函数。
     * 
     * Parameters:
     * options - {Object} 选项参数。
     */
    initialize: function(options) {
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
    },

	/**
     * Method: updateAttribution
     * 控件销毁，私有。
     */
    destroy: function() {
		this.deactivate();
		this.removeTextElement();
        Geo.View3D.Control.prototype.destroy.apply(this, arguments);
    },    
     
	/**
     * Method: updateAttribution
     * 关联地图，私有。
     */
    setMap: function(map) {
        Geo.View3D.Control.prototype.setMap.apply(this, arguments);
    },

	/**
     * Method: updateAttribution
     * 控件绘制，私有。
     */
    draw: function(px){
        Geo.View3D.Control.prototype.draw.apply(this, arguments);
        this.map.events.on({
            'loadlayergroup': this.updateAttribution,
            scope: this
        });
        this.updateAttribution();
    },
	
    /**
     * Method: removeTextElement
     * 删除图层信息。
     */
    removeTextElement: function(){
        var globe = null;
        if (this.map) {
            globe = this.map.activexObj
            if (globe) {
                //globe.ScreenBox.ClearTextElement();
                globe.ScreenBox.RemoveTextElement(this.id);
            }
        }
    },
	
    /**
     * Method: updateAttribution
     * 更新图层信息。
     */
    updateAttribution: function() {
        if(this.map && this.map.activexObj){
            var globe = this.map.activexObj;
            var attributions = [];
            if (this.map.layers) {
                for(var i=0, len=this.map.layers.length; i<len; i++) {
                    var layer = this.map.layers[i];
                    if (layer.attribution && layer.getVisibility()) {
                        // add attribution only if attribution text is unique
                        if (OpenLayers.Util.indexOf(
                                        attributions, layer.attribution) === -1) {
                            attributions.push( layer.attribution );
                        }
                    }
                } 
				
                var outstr = attributions.join(this.separator);
                //globe.AddText(1, outstr, this.style.startX, this.style.startY, this.style.endX, this.style.endY, this.style.fontSize, this.style.fontFamily, this.style.opacity, this.style.colorR, this.style.colorG, this.style.colorB);
				globe.ScreenBox.AppendTextElement(this.id, 
				outstr, 
				this.style.fontFamily, 
				this.style.fontSize, 
				this.style.colorR+","+this.style.colorG+","+this.style.colorB, 
				this.style.startX, 
				this.style.startY, 
				this.style.endX, //width
				this.style.endY);//height
			}
        }
    },
	
    CLASS_NAME: "Geo.View3D.Control.Attribution"
});
/**
 * Class: Geo.View3D.Control.Box
 * 三维视图鼠标拉框类。本控件能够实现在三维视图下，用户使用鼠标进行拉框，来获得所拉框的bbox范围。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Box = Geo.Class(Geo.View3D.Control,{
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
	
    /**
     * Constructor: Geo.View3D.Control.PullBoxControl
     * Geo.View3D.Control.PullBoxControl构造函数。
     */
    initialize: function(options){
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "emitMouseHandler": this.emitMouseHandler
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.Box( this,
                            this.callbacks, this.handlerOptions);
    },	
	
	/**
	 * APIMethod: emitMouseHandler
	 * 拉框后的回调方法，由用户覆盖。
	 * 
	 * Parameters:
     * bbox - {String} bounds的字符串表示方式,值的顺序为左下右上。
	 */
	emitMouseHandler: function(bbox) {

	},
	
	CLASS_NAME: "Geo.View3D.Control.Box"
});/**
 * Class: Geo.View3D.Control.ModelChoose
 * 三维视图模型选择控件类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.ModelChoose = Geo.Class(Geo.View3D.Control, {
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: {},
	
    /**
     * Constructor: Geo.View3D.Control.ModelChoose
     * Geo.View3D.Control.ModelChoose构造函数。
     */
    initialize: function(options) {
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "chooseModel": this.chooseModel
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.ModelChoose(this,
                            this.callbacks, this.handlerOptions);
    },	
	
	chooseModel: function(mouseEvent, isSelected) {
		
	},
	
	CLASS_NAME: "Geo.View3D.Control.ModelChoose"
});/**
 * Class: Geo.View3D.Control.Mouse
 * 三维视图鼠标动作类。使用本控件可以实现通过鼠标左键，右键以及鼠标移动动作来捕捉到三维地图的鼠标事件对象。
 * 说明：本类与鼠标拉框动作功能是分开的。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Mouse = Geo.Class(Geo.View3D.Control,{
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
	
    /**
     * Constructor: Geo.View3D.Control.Mouse
     * Geo.View3D.Control.Mouse构造函数。
     */
    initialize: function(options){
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "click": this.onClick,
				"rightClick": this.onRightClick,
				"mouseMove": this.onMouseMove,
				"dblclick": this.onDblclick,
				"mouseUp": this.onMouseUp,
				"mouseRightUp":this.onMouseRightUp,
				"mouseDown": this.onMouseDown,
				"mouseWheel": this.onMouseWheel,
				"mouseOut": this.onMouseOut,
				"mouseOver": this.onMouseOver,
				"movestart": this.onMoveStart,
				"move": this.onMove,
				"moveend": this.onMoveEnd,
				"zoomend": this.onZoomEnd
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.Mouse( this,
                            this.callbacks, this.handlerOptions);
    },
	
   	/**
	 * APIMethod: onDblclick
	 * 鼠标左键双击动作，由用户覆盖
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象
	 */
	onDblclick: function(e) {

	},
	
	/**
	 * APIMethod: onClick
	 * 鼠标左键点击动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onClick: function(e) {

	},
	
	/**
	 * APIMethod: onRightClick
	 * 鼠标右键点击动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onRightClick: function(e) {
	
	},
	
	/**
	 * APIMethod: onMouseMove
	 * 鼠标移动动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseMove: function(e) {

	},
	
	/**
	 * APIMethod: onMouseUp
	 * 鼠标左键抬起动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseUp: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseDown
	 * 鼠标按下动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseDown: function(e) {
	
	},
	/**
	 * APIMethod: onMouseWheel
	 * 鼠标滚轮动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseWheel: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseOut
	 * 当鼠标移出元素时，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseOut: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseOver
	 * 当鼠标移动到元素上时，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseOver: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseRightUp
	 * 鼠标右键抬起动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseRightUp: function() {
	
	},
	
	/**
	 * APIMethod: onMoveStart
	 * 鼠标移动开始，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMoveStart: function() {
	
	},
	
	/**
	 * APIMethod: onMove
	 * 鼠标移动中，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMove: function() {
	
	},
	
	/**
	 * APIMethod: onMoveEnd
	 * 鼠标移动结束，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMoveEnd: function() {
	
	},
	
	/**
	 * APIMethod: onZoomEnd
	 * 鼠标缩放地图，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onZoomEnd: function() {
	
	},
	
	CLASS_NAME: "Geo.View3D.Control.Mouse"
});/**
* Class: Geo.View3D.Control.Analysis
* 测量与分析。
*
* Inherits from:
*  - <Geo.View3D.Control.Analysis>
*/
Geo.View3D.Control.Analysis = Geo.Class(Geo.View3D.Control, {
    //定义数组对象
    keyEventHandlers: [],
    trackerIds: [],
    elementsKeys: [],
    analysisResult: [],
    //分析结果对象
    m_surfaceArea_result: null, //面积 result
    m_aspectAnalysis_Result: null, //坡向分析 result
    m_slopeAnalysis_Result: null, //坡度分析 result
    m_cutFillAnalysis_result: null, //填挖方分析 result
    m_nosSourceFlood_Result: null, //洪水淹没 result
    m_sectionPlane_Result: null, //剖面分析 result
    m_oObserverPoints_Result: null, //单点可视 result
    m_lineOfSight_Result: null, //两点通视 result
    m_mulitiPointLineOfSight_Result: null, //多点通视 result
    m_viewshedAnalysis_Result: null, //相机可视域分析

    m_surfaceArea3D_result: null, //空间面积分析 result
    m_movePoint: null,


    m_pTracker: null,

    //三维Tracker操作类型枚举
    enumTrackerType:
	{
	    eTrackerEmpty: 0,
	    eTrackerPolyline: 1,
	    eTrackerPolygon: 2,
	    eTrackerCircleSurface: 3,
	    eTrackerCircleLine: 4,
	    eTrackerVerticalLine: 5,
	    eTrackerPolyline3D: 6,
	    eScreenEnvelopeTracker: 7,
	    eScreenPolylineTracker: 8,
	    eTrackerPolygon3D: 9
	},
    //量算类型
    enumAnalysisType: {
        measureLength: 0,
        surfaceArea: 1,
        elevationAnalysis: 2,
        aspectAnalysis: 3,
        slopeAnalysis: 4,
        cutFillAnalysis: 5,
        noSourceFloodAnalysis: 6,
        spatialLength: 7,
        spatialArea: 8,
        opserverPoints: 9,
        lineOfSight: 10,
        multiPointLineOfSight: 11,
        viewshedAnalysis: 12
    },
    /**
    * APIProperty: 填挖方目标高度
    * {Number} 
    */
    cutFillAnalysisHeight: 100,
    /**
    * APIProperty: 淹没高度
    * {Number} 
    */
    floodAnalysisHeight: 100,
    /**
    * APIProperty: autoActivate
    * {Boolean} 控件加入地图后是否自动激活。
    */
    autoActivate: true,


    /**
    * APIProperty: 相机可视域分析 水平视角
    * {double} 
    */
    viewshedAnalysisVerticalFOVAngle: 45.0,

    /**
    * APIProperty: 相机可视域分析 竖直视角
    * {double} 
    */
    viewshedAnalysisHorizontalFOVAngle: 45.0,

    /**
    * APIProperty: 相机可视域分析 可视距离
    * {double} 
    */
    viewshedAnalysisViewDistance: 100,

    /**
    * APIProperty: 相机可视域分析 方向角
    * {double} 
    */
    viewshedAnalysisHeadingAngle: 0,

    /**
    * APIProperty: 相机可视域分析 俯仰角
    * {double} 
    */
    viewshedAnalysisTiltAngle: -15,

    /**
    * APIProperty: 相机可视域分析 结果表现形式，0表示用线方式显示，其他值表示用填充方式显示
    * {double} 
    */
    viewshedAnalysisResultPresentatio: 1,

    /**
    * Constructor: Geo.View3D.Control.Analysis
    * 构造函数。生成一个Geo.View3D.Control.Analysis的实例。
    */
    initialize: function(options) {
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
    },

	 /**
     * APIMethod: measureLengthAnalysis
     * 量算距离。
     * 
     */  
    measureLengthAnalysis: function() {
        var id = OpenLayers.Util.createUniqueID();
        var globe = this.map.activexObj;
        if (globe) {
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolyline);
            this.lengthHandler = OpenLayers.Function.bind(function(eventObj) {
                this._lengthHandler(eventObj);
            }, this);

            //     globe.attachEvent("OnGeometryTracked", this.lengthHandler);
            if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.lengthHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.lengthHandler);
            }
            this.keyEventHandlers.push(this.lengthHandler);
            this.trackerIds.push(id);
        }
    },

    _lengthHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        var result = globe.AnalysisBox.SectionPlane(vObjGeo, 1000);
        // alert(result.InterpolationTotalLength);
        this.onComplete(this.enumAnalysisType.measureLength, result.InterpolationTotalLength);
        //   globe.detachEvent("OnGeometryTracked", this.lengthHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.lengthHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.lengthHandler);
        }
    },

	 /**
     * APIMethod: onComplete
     * 完成量算和分析的回调函数。
     * 
     * Parameters:
     * type - {String} 操作类型。
     * result - {Object} 返回结果。
     * 
     */
    onComplete: function(type, result) {
    },
	
     /**
     * APIMethod: measureLengthAnalysis
     * 量算面积。
     * 
     */
    surfaceAreaAnalysis: function() {
        var id = OpenLayers.Util.createUniqueID();
        var globe = this.map.activexObj;
        if (globe) {
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.surfaceAreaHandler = OpenLayers.Function.bind(function(eventObj) {
                this._surfaceAreaHandler(eventObj);
            }, this);
            this.surfaceAreaFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._surfaceAreaFinishedHandler(eventObj);
            }, this);
            //		globe.attachEvent("OnTrackerFinished", this.surfaceAreaHandler);
            if (globe.addEventListener) {
                globe.addEventListener("TrackerFinished", this.surfaceAreaHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnTrackerFinished", this.surfaceAreaHandler);
            }
            //			globe.attachEvent("OnGeometryTracked", this.surfaceAreaHandler);
            //         globe.attachEvent("OnAnalysisFinished", this.surfaceAreaFinishedHandler);
            if (globe.addEventListener) {
                globe.addEventListener("AnalysisFinished", this.surfaceAreaFinishedHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnAnalysisFinished", this.surfaceAreaFinishedHandler);
            }

            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.surfaceAreaHandler);
            this.keyEventHandlers.push(this.surfaceAreaFinishedHandler);
        }
    },
    _surfaceAreaHandler: function(vObjGeo, type) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnTrackerFinished", this.surfaceAreaHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("TrackerFinished", this.surfaceAreaHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnTrackerFinished", this.surfaceAreaHandler);
        }
        var globe = this.map.activexObj;
        this.m_surfaceArea_result = globe.AnalysisBox.AreaAsynchronous(vObjGeo.Result, 10);
        globe.ScreenBox.AppendElement(this.m_surfaceArea_result.ProgressElement);
        this.m_surfaceArea_result.DoAnalysis();
        this.elementsKeys.push(this.m_surfaceArea_result.ProgressElement.Key);
    },
    _surfaceAreaFinishedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnAnalysisFinished", this.surfaceAreaFinishedHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("AnalysisFinished", this.surfaceAreaFinishedHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnAnalysisFinished", this.surfaceAreaFinishedHandler);
        }
        //alert(this.m_surfaceArea_result.Area);
        this.onComplete(this.enumAnalysisType.surfaceArea, this.m_surfaceArea_result.Area);
    },
	
     /**
     * APIMethod: measureHeightAnalysis
     * 高度量算。
     * 
     */
    measureHeightAnalysis: function() {
        var id = OpenLayers.Util.createUniqueID();
        var globe = this.map.activexObj;
        if (globe) {
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerVerticalLine);
            this.trackerIds.push(id);
        }
    },

	 /**
     * APIMethod: queryElevationAnalysis
     * 高程信息查询。
     * 
     */
    queryElevationAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            this.queryElevationHandler = OpenLayers.Function.bind(function(eventObj) {
                this._queryElevationHandler(eventObj);
            }, this);
            //	globe.attachEvent("OnMouseEvent", this.queryElevationHandler);
            if (globe.addEventListener) {
                globe.addEventListener("MouseEvent", this.queryElevationHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnMouseEvent", this.queryElevationHandler);
            }
            this.keyEventHandlers.push(this.queryElevationHandler);
        }
    },
	
	 /**
     * APIMethod: removeElevationAnalysis
     * 删除高程信息查询监听。
     * 
     */
    removeElevationAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            if (this.queryElevationHandler) {
                //	globe.detachEvent("OnMouseEvent", this.queryElevationHandler);
                if (globe.removeEventListener) {
                    globe.removeEventListener("MouseEvent", this.queryElevationHandler, false);
                } else if (globe.detachEvent) {
                    globe.detachEvent("OnMouseEvent", this.queryElevationHandler);
                }
            }
        }
    },
    _queryElevationHandler: function(e) {
        //监听鼠标单击事件
        if (e.MouseButton === 1 && e.MouseState === 0) {
            var finalResult = {
                longitude: null,
                latitude: null,
                altitude: null,
                slope: null,
                aspect: null
            };
            finalResult.longitude = e.X.toFixed(2);
            finalResult.latitude = e.Y.toFixed(2);
            finalResult.altitude = e.Altitude.toFixed(2);
            //调用回调函数
            this.onComplete(this.enumAnalysisType.elevationAnalysis, finalResult);
        }
    },

	/**
     * APIMethod: aspectAnalysis
     * 坡向分析。
     * 
     */
    aspectAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.aspectTrackedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._aspectTrackedHandler(eventObj);
            }, this);
            this.aspectFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._aspectFinishedHandler(eventObj);
            }, this);
            //		globe.attachEvent("OnGeometryTracked", this.aspectTrackedHandler);
            if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.aspectTrackedHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.aspectTrackedHandler);
            }
            //		globe.attachEvent("OnAnalysisFinished", this.aspectFinishedHandler);
            if (globe.addEventListener) {
                globe.addEventListener("AnalysisFinished", this.aspectFinishedHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnAnalysisFinished", this.aspectFinishedHandler);
            }
            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.aspectTrackedHandler);
            this.keyEventHandlers.push(this.aspectFinishedHandler);
        }
    },
    _aspectTrackedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnGeometryTracked", this.aspectTrackedHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.aspectTrackedHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.aspectTrackedHandler);
        }
        this.m_aspectAnalysis_Result = globe.AnalysisBox.RangeAspect(vObjGeo, 10);
        globe.ScreenBox.AppendElement(this.m_aspectAnalysis_Result.ProgressDisplayElement);
        this.elementsKeys.push(this.m_aspectAnalysis_Result.ProgressDisplayElement.Key);
        //开始分析
        this.m_aspectAnalysis_Result.DoAnalysis(null);
    },
    _aspectFinishedHandler: function(varResultObject, resultType) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnAnalysisFinished", this.aspectFinishedHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("AnalysisFinished", this.aspectFinishedHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnAnalysisFinished", this.aspectFinishedHandler);
        }
        globe.ScreenBox.RemoveElement(this.m_aspectAnalysis_Result.ProgressDisplayElement);
        globe.ScreenBox.AppendElement(this.m_aspectAnalysis_Result.ResultDisplayElement);
        this.elementsKeys.push(this.m_aspectAnalysis_Result.ResultDisplayElement.Key);
        this.onComplete(this.enumAnalysisType.aspectAnalysis, "");
    },


	/**
     * APIMethod: slopeAnalysis
     * 坡度分析。
     * 
     */
    slopeAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.slopeTrackedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._slopeTrackedHandler(eventObj);
            }, this);
            this.slopeFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._slopeFinishedHandler(eventObj);
            }, this);
            //		globe.attachEvent("OnGeometryTracked", this.slopeTrackedHandler); 
            if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.slopeTrackedHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.slopeTrackedHandler);
            }
            //		globe.attachEvent("OnAnalysisFinished", this.slopeFinishedHandler); 
            if (globe.addEventListener) {
                globe.addEventListener("AnalysisFinished", this.slopeFinishedHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnAnalysisFinished", this.slopeFinishedHandler);
            }
            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.slopeTrackedHandler);
            this.keyEventHandlers.push(this.slopeFinishedHandler);
        }
    },
    _slopeTrackedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnGeometryTracked", this.slopeTrackedHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.slopeTrackedHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.slopeTrackedHandler);
        }
        this.m_slopeAnalysis_Result = globe.AnalysisBox.RangeSlope(vObjGeo, 10);
        globe.ScreenBox.AppendElement(this.m_slopeAnalysis_Result.ProgressDisplayElement);
        this.elementsKeys.push(this.m_slopeAnalysis_Result.ProgressDisplayElement.Key);
        //开始分析
        this.m_slopeAnalysis_Result.DoAnalysis(null);
    },
    _slopeFinishedHandler: function(varResultObject, resultType) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnAnalysisFinished", this.slopeFinishedHandler); 
        if (globe.removeEventListener) {
            globe.removeEventListener("AnalysisFinished", this.slopeFinishedHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnAnalysisFinished", this.slopeFinishedHandler);
        }
        globe.ScreenBox.RemoveElement(this.m_slopeAnalysis_Result.ProgressDisplayElement);
        globe.ScreenBox.AppendElement(this.m_slopeAnalysis_Result.ResultDisplayElement);
        this.elementsKeys.push(this.m_slopeAnalysis_Result.ResultDisplayElement.Key);
        this.onComplete(this.enumAnalysisType.slopeAnalysis, "");
    },

	/**
     * APIMethod: cutFillAnalysis
     * 填挖方分析。
     * 
     */
    cutFillAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.cutFillTrackedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._cutFillTrackedHandler(eventObj);
            }, this);
            //	globe.attachEvent("OnGeometryTracked", this.cutFillTrackedHandler);
            if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.cutFillTrackedHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.cutFillTrackedHandler);
            }
            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.cutFillTrackedHandler);
        }
    },
    _cutFillTrackedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnGeometryTracked", this.cutFillTrackedHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.cutFillTrackedHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.cutFillTrackedHandler);
        }
        this.m_cutFillAnalysis_result = globe.AnalysisBox.CutFill(vObjGeo);
        globe.ScreenBox.AppendElement(this.m_cutFillAnalysis_result.ResultDisplayElement);
        this.elementsKeys.push(this.m_cutFillAnalysis_result.ResultDisplayElement.Key);
        //分析
        this.m_cutFillAnalysis_result.CutFillTo(this.cutFillAnalysisHeight);
        this.onComplete(this.enumAnalysisType.cutFillAnalysis, this.m_cutFillAnalysis_result);
    },


	/**
     * APIMethod: nosSourceFloodAnalysis
     * 洪水淹没。
     * 
     */
    nosSourceFloodAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.nosSourceFloodTrackedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._nosSourceFloodTrackedHandler(eventObj);
            }, this);
            //	globe.attachEvent("OnGeometryTracked", this.nosSourceFloodTrackedHandler);
            if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.nosSourceFloodTrackedHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.nosSourceFloodTrackedHandler);
            }
            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.nosSourceFloodTrackedHandler);
        }
    },
    _nosSourceFloodTrackedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnGeometryTracked", this.nosSourceFloodTrackedHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.nosSourceFloodTrackedHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.nosSourceFloodTrackedHandler);
        }
        this.m_nosSourceFlood_Result = globe.AnalysisBox.NoSourceFlood(vObjGeo);
        globe.ScreenBox.AppendElement(this.m_nosSourceFlood_Result.ResultDisplayElement);
        this.elementsKeys.push(this.m_nosSourceFlood_Result.ResultDisplayElement.Key);
        this.m_nosSourceFlood_Result.FloodTo(this.floodAnalysisHeight);
        this.onComplete(this.enumAnalysisType.noSourceFloodAnalysis, this.m_nosSourceFlood_Result);
    },

	/**
     * APIMethod: sectionPlaneAnalysis
     * 剖面分析。
     * 
     */
    sectionPlaneAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolyline);
            this.sectionPlaneTrackedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._sectionPlaneTrackedHandler(eventObj);
            }, this);
            //	globe.attachEvent("OnGeometryTracked", this.sectionPlaneTrackedHandler);
            if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.sectionPlaneTrackedHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.sectionPlaneTrackedHandler);
            }
            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.sectionPlaneTrackedHandler);
        }
    },
    _sectionPlaneTrackedHandler: function(vObjGeo) {
        //	globe.detachEvent("OnGeometryTracked", this.sectionPlaneTrackedHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.sectionPlaneTrackedHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.sectionPlaneTrackedHandler);
        }
        var globe = this.map.activexObj;
        this.m_sectionPlane_Result = globe.AnalysisBox.SectionPlane(vObjGeo, 50);
        var line = this.m_sectionPlane_Result.InterpolationGeometry;
        var drawBox = globe.DrawBox;
        var str = "";
        var wkt = line.ExportToData(1, str);
        //定义数组对象
        var resultData = [];
        /**
        for (var i = 0; i < line.PointCount; i++)
        {
        //var x, y, z;
        //line.GetPoint(i, x, y, z);
        var x, y, z;
        line.ExportToData(i, 'out'+ 'x', out y, out z);
        //resultData.Add(z);
        resultData.push(z);
        }*/
        //				 m_ResultView.Result = resultData;
        alert(resultData);
    },


	/**
     * APIMethod: spatialLengthAnalysis
     * 空间距离量算。
     * 
     */
    spatialLengthAnalysis: function() {
        var id = OpenLayers.Util.createUniqueID();
        var globe = this.map.activexObj;
        if (globe) {
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolyline3D);
            this.length3DHandler = OpenLayers.Function.bind(function(eventObj) {
                this._length3DHandler(eventObj);
            }, this);

            //     globe.attachEvent("OnGeometryTracked", this.length3DHandler);
            if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.length3DHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.length3DHandler);
            }
            this.keyEventHandlers.push(this.length3DHandler);
            this.trackerIds.push(id);
        }
    },

    _length3DHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
		var result = globe.AnalysisBox.Length(vObjGeo, 2);
        this.onComplete(this.enumAnalysisType.spatialLength, result);
        //   globe.detachEvent("OnGeometryTracked", this.length3DHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.length3DHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.length3DHandler);
        }
    },

	/**
     * APIMethod: spatialAreaAnalysis
     * 空间面积量算。
     * 
     */
    spatialAreaAnalysis: function() {
        var id = OpenLayers.Util.createUniqueID();
        var globe = this.map.activexObj;
        if (globe) {
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon3D);
            this.surfaceArea3DHandler = OpenLayers.Function.bind(function(eventObj) {
                this._surfaceArea3DHandler(eventObj);
            }, this);
            this.surfaceArea3DFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._surfaceArea3DFinishedHandler(eventObj);
            }, this);
            //		globe.attachEvent("OnTrackerFinished", this.surfaceArea3DHandler);
            if (globe.addEventListener) {
                globe.addEventListener("TrackerFinished", this.surfaceArea3DHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnTrackerFinished", this.surfaceArea3DHandler);
            }
            //			globe.attachEvent("OnGeometryTracked", this.surfaceArea3DHandler);
            //         globe.attachEvent("OnAnalysisFinished", this.surfaceArea3DFinishedHandler);
            if (globe.addEventListener) {
                globe.addEventListener("AnalysisFinished", this.surfaceArea3DFinishedHandler, false);
            } else if (globe.attachEvent) {
                globe.attachEvent("OnAnalysisFinished", this.surfaceArea3DFinishedHandler);
            }

            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.surfaceArea3DHandler);
            this.keyEventHandlers.push(this.surfaceArea3DFinishedHandler);
        }
    },
    _surfaceArea3DHandler: function(vObjGeo, type) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnTrackerFinished", this.surfaceAreaHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("TrackerFinished", this.surfaceArea3DHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnTrackerFinished", this.surfaceArea3DHandler);
        }
        var globe = this.map.activexObj;
        this.m_surfaceArea3D_result = globe.AnalysisBox.AreaAsynchronous(vObjGeo.Result, 10);
        globe.ScreenBox.AppendElement(this.m_surfaceArea3D_result.ProgressElement);
        this.m_surfaceArea3D_result.DoAnalysis();
        this.elementsKeys.push(this.m_surfaceArea3D_result.ProgressElement.Key);
    },
    _surfaceArea3DFinishedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnAnalysisFinished", this.surfaceAreaFinishedHandler);
        if (globe.removeEventListener) {
            globe.removeEventListener("AnalysisFinished", this.surfaceArea3DFinishedHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnAnalysisFinished", this.surfaceArea3DFinishedHandler);
        }
        //alert(this.m_surfaceArea3D_result.Area);
        this.onComplete(this.enumAnalysisType.spatialArea, this.m_surfaceArea3D_result);
    },

	/**
     * APIMethod: observerPointsRangeAnalysis
     * 单点可视。
     * 
     */
    observerPointsRangeAnalysis: function() {//开始单点可视功能
        var globe = this.map.activexObj;

        //监听GeometryTrackered事件    
        this.observerPointsGeometryTrackeredHandler = OpenLayers.Function.bind(function(eventObj) {
            this._observerPointsGeometryTrackeredHandler(eventObj);
        }, this);
        if (globe.addEventListener) {
            globe.addEventListener("GeometryTracked", this.observerPointsGeometryTrackeredHandler, false);
        } else if (globe.attachEvent) {
            globe.attachEvent("OnGeometryTracked", this.observerPointsGeometryTrackeredHandler);
        }

        //开始进行画面
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.trackerIds.push(id);
        }
    },


    _observerPointsGeometryTrackeredHandler: function(vObjGeo) { //单点可视的范围设置
        //取消订阅GeometryTracked事件
        var globe = this.map.activexObj;
        if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.observerPointsGeometryTrackeredHandler, false);
        } else if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.observerPointsGeometryTrackeredHandler);
        }

        //设置观察范围
        this.m_Range = vObjGeo;

        //开始画观察点
        var id = OpenLayers.Util.createUniqueID();
        m_pTracker = globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerVerticalLine);
        this.trackerIds.push(id);


        //开始监听TrackerFinished事件
        this.observerPointsTrackerFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
            this._observerPointsTrackerFinishedHandler(eventObj);
        }, this);
        if (globe.addEventListener) {
            globe.addEventListener("TrackerFinished", this.observerPointsTrackerFinishedHandler, false);
        } else if (globe.attachEvent) {
            globe.attachEvent("OnTrackerFinished", this.observerPointsTrackerFinishedHandler);
        }

    },

    _observerPointsTrackerFinishedHandler: function(varTrackerObject, eType) {//Tracker结束事件
        var globe = this.map.activexObj;
        if (typeof (varTrackerObject.Location) != "undefined") {

            //监听分析结束事件
            this.observerPointsAnalysisFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._observerPointsAnalysisFinishedHandler(eventObj);
            }, this);
            if (globe.addEventListener) {
                globe.addEventListener("AnalysisFinished", this.observerPointsAnalysisFinishedHandler, false);
            }
            else if (globe.attachEvent) {
                globe.attachEvent("OnAnalysisFinished", this.observerPointsAnalysisFinishedHandler);
            }


            //开始分析
            var pt3D = varTrackerObject.Location;
            pt3D.Z += m_pTracker.Length;

            this.m_oObserverPoints_Result = globe.AnalysisBox.ObserverPointsInRange(this.m_Range, pt3D);
            globe.ScreenBox.AppendElement(this.m_oObserverPoints_Result.ShowProcessElement);
            this.elementsKeys.push(this.m_oObserverPoints_Result.ShowProcessElement.Key);
            this.m_oObserverPoints_Result.StartAnalysisProcess();

            //取消监听TrackerFinished事件
            if (globe.removeEventListener) {
                globe.removeEventListener("TrackerFinished", this.observerPointsTrackerFinishedHandler, false);
            }
            else if (globe.detachEvent) {
                globe.detachEvent("OnTrackerFinished", this.observerPointsTrackerFinishedHandler);
            }
        }

    },

    //分析结束事件
    _observerPointsAnalysisFinishedHandler: function(varTrackerObject, enumAnalysisType) {
		var globe = this.map.activexObj;
        //结束监听分析结束事件
        if (globe.removeEventListener) {
            globe.removeEventListener("AnalysisFinished", this.observerPointsAnalysisFinishedHandler, false);
        }
        else if (globe.attachEvent) {
            globe.detachEvent("OnAnalysisFinished", this.observerPointsAnalysisFinishedHandler);
        }
        this.onComplete(this.enumAnalysisType.opserverPoints, this.m_oObserverPoints_Result);
    },

	/**
     * APIMethod: lineOfSightAnalysis
     * 两点通视。
     * 
     */
    lineOfSightAnalysis: function() {
        var globe = this.map.activexObj;
        this.LineOfSightClickCount = 0;
        this.LineOfSightMovePoint = null;
        this.LineOfSightStartTracker = null;
        this.LineOfSightEndTracker = null;
        //监听鼠标事件
        this.lineOfSightMouseEventHandler = OpenLayers.Function.bind(function(eventObj) {
            this._lineOfSightMouseEventHandler(eventObj);
        }, this);
        if (globe.addEventListener) {
            globe.addEventListener("MouseEvent", this.lineOfSightMouseEventHandler, false);
        }
        else if (globe.attachEvent) {
            globe.attachEvent("OnMouseEvent", this.lineOfSightMouseEventHandler);
        }
    },

    _lineOfSightMouseEventHandler: function(e) {
        var geoSpace3D = this.map.activexObj;
        switch (e.MouseState) {
            case 3:
                {
                    //改变橡皮条效果
                    if (this.LineOfSightMovePoint == null) {
                        this.LineOfSightMovePoint = geoSpace3D.ObjectFactory.CreateObject(100);
                    }
                    this.LineOfSightMovePoint.PutCoords(e.X, e.Y, e.Altitude);
                    if (null != this.m_lineOfSight_Result) {
                        if (null == this.LineOfSightEndTracker) {
                            this.m_lineOfSight_Result.EndPoint = this.LineOfSightMovePoint;
                        }
                        else {
                            this.m_lineOfSight_Result.EndPointHeight = this.LineOfSightEndTracker.Length;
                        }
                    }

                    break;
                }
            case 1:
                {
                    if (e.MouseButton != 1)
                        return;
                    //获取当前点
                    var pt = geoSpace3D.ObjectFactory.CreateObject(100);
                    pt.PutCoords(e.X, e.Y, e.Altitude);
                    //控制通视操作
                    this.LineOfSightMouseDown(pt);
                }
                break;
        }

        if (this.m_lineOfSight_Result == null)
            return;

    },

    LineOfSightMouseDown: function(point) {
        var geoSpace3D = this.map.activexObj;
        switch (this.LineOfSightClickCount) {
            case 0: //设置首点起点
                {
                    var id = OpenLayers.Util.createUniqueID();
                    this.LineOfSightStartTracker = geoSpace3D.DrawBox.StartTracker(id, 5);
                    this.LineOfSightStartTracker.Location = point;
                    this.trackerIds.push(id);

                }
                break;
            case 1: //设置首点结束位置
                {
                    //获取通视点
                    this.m_lineOfSight_Result = geoSpace3D.AnalysisBox.StartLineOfSight();
                    this.m_lineOfSight_Result.EnableTracker = false;
                    //添加屏幕显示
                    geoSpace3D.ScreenBox.AppendElement(this.m_lineOfSight_Result);
                    this.elementsKeys.push(this.m_lineOfSight_Result);

                    //设置通视起点
                    var pt = this.LineOfSightStartTracker.Location;
                    this.m_lineOfSight_Result.StartPoint = pt;
                    this.m_lineOfSight_Result.StartPointHeight = this.LineOfSightStartTracker.Length;
                }
                break;
            case 2: //设置尾点起点
                {
                    var id = OpenLayers.Util.createUniqueID();
                    this.LineOfSightEndTracker = geoSpace3D.DrawBox.StartTracker(id, 5);
                    this.LineOfSightEndTracker.Location = point;
                    this.trackerIds.push(id);

                    this.m_lineOfSight_Result.EndPoint = point;  //设置终点的位置
                }
                break;
            case 3: //修改通视结束点高度
                {
                    //修改终点的高度
                    this.m_lineOfSight_Result.EndPointHeight = this.LineOfSightEndTracker.Length;

                    //解绑定鼠标事件
                    if (geoSpace3D.removeEventListener) {
                        geoSpace3D.removeEventListener("MouseEvent", this.lineOfSightMouseEventHandler, false);
                    }
                    else if (geoSpace3D.detachEvent) {
                        geoSpace3D.detachEvent("OnMouseEvent", this.lineOfSightMouseEventHandler);
                    }
                }
                break;
        }
        //计数加1
        this.LineOfSightClickCount++;
    },

	/**
     * APIMethod: mulitiPointLineOfSightAnalysis
     * 多点通视。
     * 
     */
    mulitiPointLineOfSightAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            this.m_movePoint = null;
            this.m_nClickCount = 0;
            //监听OnMouseEvent事件
            this.mulitiPointLineOfSightMouseEventHandler = OpenLayers.Function.bind(function(eventObj) {
                this._mulitiPointLineOfSightMouseEventHandler(eventObj);
            }, this);
            if (globe.addEventListener) {
                globe.addEventListener("MouseEvent", this.mulitiPointLineOfSightMouseEventHandler, false);
            }
            else if (globe.attachEvent) {
                globe.attachEvent("OnMouseEvent", this.mulitiPointLineOfSightMouseEventHandler);
            }
        }
    },

    _mulitiPointLineOfSightMouseEventHandler: function(e) {
        var geoSpace3D = this.map.activexObj;
        switch (e.MouseState) {
            case 3:
                //改变橡皮条效果
                if (this.m_movePoint == null) {
                    this.m_movePoint = geoSpace3D.ObjectFactory.CreateObject(100);
                }
                this.m_movePoint.PutCoords(e.X, e.Y, e.Altitude);
                if (null != this.m_mulitiPointLineOfSight_Result) {
                    if (this.m_nClickCount > 1) {
                        this.m_mulitiPointLineOfSight_Result.EndPoint = this.m_movePoint;
                    }
                }
                break;
            case 1:
                {
                    if (e.MouseButton != 1)
                        return;
                    //获取当前点
                    var pt = geoSpace3D.ObjectFactory.CreateObject(100);
                    pt.PutCoords(e.X, e.Y, e.Altitude);
                    //控制通视操作
                    if (this.m_nClickCount == 2) {
                        this.m_mulitiPointLineOfSight_Result.EndPoint = pt;
                        this.m_nClickCount = 1;
                    }
                    this.MouseDown(pt);
                }
                break;
            case 4:
                {

                    //解绑定鼠标事件

                    if (geoSpace3D.removeEventListener) {
                        geoSpace3D.removeEventListener("MouseEvent", this.mulitiPointLineOfSightMouseEventHandler, false);
                    }
                    else if (geoSpace3D.detachEvent) {
                        geoSpace3D.detachEvent("OnMouseEvent", this.mulitiPointLineOfSightMouseEventHandler);
                    }
                    break;
                }
        }
    },

    MouseDown: function(point) {
        var geoSpace3D = this.map.activexObj;
        switch (this.m_nClickCount) {
            case 0: //设置首点起点
                {
                    //开始绘制垂直Tracker
                    var id = OpenLayers.Util.createUniqueID();
                    this.pTracker = geoSpace3D.DrawBox.StartTracker(id, 5);
                    this.pTracker.Location = point;
                    this.trackerIds.push(id);
                }
                break;
            case 1: //设置首点结束位置
                {
                    //获取通视点
                    this.m_mulitiPointLineOfSight_Result = geoSpace3D.AnalysisBox.StartLineOfSight3D();
                    this.m_mulitiPointLineOfSight_Result.EnableTracker = false;
                    //添加屏幕显示
                    geoSpace3D.ScreenBox.AppendElement(this.m_mulitiPointLineOfSight_Result);
                    this.elementsKeys.push(this.m_mulitiPointLineOfSight_Result);
                    //设置通视起点
                    var pt = this.pTracker.Location;
                    this.m_mulitiPointLineOfSight_Result.StartPoint = pt;
                    this.m_mulitiPointLineOfSight_Result.StartPointHeight = this.pTracker.Length;

                }
                break;
            default:
                {
                    //解绑定鼠标事件
                    if (geoSpace3D.removeEventListener) {
                        geoSpace3D.removeEventListener("MouseEvent", this.mulitiPointLineOfSightMouseEventHandler, false);
                    }
                    else if (geoSpace3D.detachEvent) {
                        geoSpace3D.detachEvent("OnMouseEvent", this.mulitiPointLineOfSightMouseEventHandler);
                    }
                }
                break;
        }
        //计数加1
        this.m_nClickCount++;
    },

	/**
     * APIMethod: viewshedAnalysis
     * 相机可视域分析。
     * 
     */
    viewshedAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            //监听OnMouseEvent事件
            this.viewshedTrackerFinishedHandler = OpenLayers.Function.bind(function(eventObj, eType) {
                this._viewshedTrackerFinishedHandler(eventObj, eType);
            }, this);
            if (globe.addEventListener) {
                globe.addEventListener("TrackerFinished", this.viewshedTrackerFinishedHandler, false);
            }
            else if (globe.attachEvent) {
                globe.attachEvent("OnTrackerFinished", this.viewshedTrackerFinishedHandler);
            }
            var id = OpenLayers.Util.createUniqueID();
            //开始第一个点
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerVerticalLine);
            this.trackerIds.push(id);
        }
    },

    _viewshedTrackerFinishedHandler: function(eventObj, eType) {
        var geoSpace3D = this.map.activexObj;
        //取消监听TrackerFinished事件
        if (geoSpace3D.removeEventListener) {
            geoSpace3D.removeEventListener("TrackerFinished", this.viewshedTrackerFinishedHandler, false);
        }
        else if (geoSpace3D.detachEvent) {
            geoSpace3D.detachEvent("OnTrackerFinished", this.viewshedTrackerFinishedHandler);
        }
        var endPt = eventObj.Location;
        var endPtLength = eventObj.Length;
        //开始分析，监听分析结束事件
        this.viewshedAnalysisFinishedHandler = OpenLayers.Function.bind(function(eventAnalyseObj, eAnalyseType) {
            this._viewshedAnalysisFinishedHandler(eventAnalyseObj, eAnalyseType);
        }, this);
        if (geoSpace3D.addEventListener) {
            geoSpace3D.addEventListener("AnalysisFinished", this.viewshedAnalysisFinishedHandler, false);
        }
        else if (geoSpace3D.attachEvent) {
            geoSpace3D.attachEvent("OnAnalysisFinished", this.viewshedAnalysisFinishedHandler);
        }

        //分析
        this.m_viewshedAnalysis_Result = geoSpace3D.AnalysisBox.StartObserverCamera3D();

        geoSpace3D.ScreenBox.AppendElement(this.m_viewshedAnalysis_Result);
        this.elementsKeys.push(this.m_viewshedAnalysis_Result);

        //设置参数
        this.m_viewshedAnalysis_Result.VerticalFOVAngle = this.viewshedAnalysisVerticalFOVAngle;
        this.m_viewshedAnalysis_Result.HorizontalFOVAngle = this.viewshedAnalysisHorizontalFOVAngle;
        this.m_viewshedAnalysis_Result.ViewDistance = this.viewshedAnalysisViewDistance;
        endPt.Z = endPt.Z + endPtLength;
        this.m_viewshedAnalysis_Result.Location = endPt;
        this.m_viewshedAnalysis_Result.HeadingAngle = this.viewshedAnalysisHeadingAngle * 0.3;
        this.m_viewshedAnalysis_Result.TiltAngle = this.viewshedAnalysisTiltAngle *0.3 ;
        if (this.viewshedAnalysisResultPresentatio == 0) {
            this.m_viewshedAnalysis_Result.ResultPresentation = 0;
        }
        else {
            this.m_viewshedAnalysis_Result.ResultPresentation = 1;
        }
        this.m_viewshedAnalysis_Result.VerticalLineCount = this.viewshedAnalysisVerticalFOVAngle;
        this.m_viewshedAnalysis_Result.HorizontalLineCount = this.viewshedAnalysisHorizontalFOVAngle;
        this.m_viewshedAnalysis_Result.DoAnalysis();

    },

    _viewshedAnalysisFinishedHandler: function(eventAnalyseObj, eAnalyseType) {
        var geoSpace3D = this.map.activexObj;
        //取消监听AnalysisFinished事件
        if (geoSpace3D.removeEventListener) {
            geoSpace3D.removeEventListener("AnalysisFinished", this.viewshedAnalysisFinishedHandler, false);
        }
        else if (geoSpace3D.detachEvent) {
            geoSpace3D.detachEvent("OnAnalysisFinished", this.viewshedAnalysisFinishedHandler);
        }
        this.onComplete(this.enumAnalysisType.viewshedAnalysis, null);
    },

	/**
     * APIMethod: clearAnalysisResult
     * 清除分析结果。
     * 
     */
    clearAnalysisResult: function() {
        var globe = this.map.activexObj;
        if (globe) {
            for (var i = 0, len = this.trackerIds.length; i < len; i++) {
                globe.DrawBox.RemoveTracker(this.trackerIds[i]);
            }
            for (var i = 0, len = this.elementsKeys.length; i < len; i++) {
                globe.ScreenBox.RemoveElement(this.elementsKeys[i]);
            }
            //		map.activexObj.DrawBox.RemoveAllTracker();
            for (var i = 0, len = this.keyEventHandlers.length; i < len; i++) {
                //		globe.detachEvent("OnGeometryTracked", this.keyEventHandlers[i]);
                if (globe.removeEventListener) {
                    globe.removeEventListener("GeometryTracked", this.keyEventHandlers[i], false);
                } else if (globe.detachEvent) {
                    globe.detachEvent("OnGeometryTracked", this.keyEventHandlers[i]);
                }
                //		globe.detachEvent("OnAnalysisFinished", this.keyEventHandlers[i]);
                if (globe.removeEventListener) {
                    globe.removeEventListener("AnalysisFinished", this.keyEventHandlers[i], false);
                } else if (globe.detachEvent) {
                    globe.detachEvent("OnAnalysisFinished", this.keyEventHandlers[i]);
                }
                //		globe.detachEvent("OnTrackerFinished", this.keyEventHandlers[i]);
                if (globe.removeEventListener) {
                    globe.removeEventListener("TrackerFinished", this.keyEventHandlers[i], false);
                } else if (globe.detachEvent) {
                    globe.detachEvent("OnTrackerFinished", this.keyEventHandlers[i]);
                }
                //		globe.detachEvent("OnMouseEvent", this.keyEventHandlers[i]);
                if (globe.removeEventListener) {
                    globe.removeEventListener("MouseEvent", this.keyEventHandlers[i], false);
                } else if (globe.detachEvent) {
                    globe.detachEvent("OnMouseEvent", this.keyEventHandlers[i]);
                }
            }
        }
    },

	/**
     * APIMethod: activate
     * 激活控件。
     * 
     */
    activate: function() {
        if (Geo.View3D.Control.prototype.activate.apply(this, arguments)) {
            return true;
        }
        return false;
    },
	
	/**
     * APIMethod: deactivate
     * 禁用控件。
     * 
     */
    deactivate: function() {
        //清除结果
        this.clearAnalysisResult();
        //清除全局变量
        this.keyEventHandlers = [];
        this.trackerIds = [];
        this.elementsKeys = [];
        this.analysisResult = [];
        this.m_surfaceArea_result = null;
        this.m_surfaceArea3D_result = null;
        this.m_aspectAnalysis_Result = null;
        this.m_slopeAnalysis_Result = null;
        this.m_cutFillAnalysis_result = null;
        this.m_nosSourceFlood_Result = null;
        this.m_sectionPlane_Result = null;
        this.m_oObserverPoints_Result = null;
        this.m_lineOfSight_Result = null;
        if (Geo.View3D.Control.prototype.deactivate.apply(this, arguments)) {
            return true;
        }
        return false;
    },

    /**
    * Method: destroy
    */
    destroy: function() {
        this.deactivate();
        Geo.View3D.Control.prototype.destroy.apply(this, arguments);
    },
	
    /**
    * Method: updateAttribution
    * 关联地图，私有。
    */
    setMap: function(map) {
        Geo.View3D.Control.prototype.setMap.apply(this, arguments);
    },

    CLASS_NAME: "Geo.View3D.Control.Analysis"
});

/**
 * Class: Geo.View3D.Control.Keyboard
 * 三维视图键盘动作类。使用本控件可以实现通过键盘上下左右键动作来捕捉到三维地图的键盘事件对象。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Keyboard = Geo.Class(Geo.View3D.Control,{
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
	
    /**
     * Constructor: Geo.View3D.Control.Keyboard
     * Geo.View3D.Control.Keyboard构造函数。
     */
    initialize: function(options){
       Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "keyboardDown": this.onKeyboardDown,
				"keyboardUp": this.onKeyboardUp
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.Keyboard(this,this.callbacks, this.handlerOptions);
    },
    
    /**
     * APIMethod: onKeyboardDown
     * 键盘按下。
     */
    onKeyboardDown: function(e){
    },
    
    /**
     * APIMethod: onKeyboardUp
     * 键盘抬起。
     */
    onKeyboardUp: function(e){
    },
	
	CLASS_NAME: "Geo.View3D.Control.Keyboard"
});/**
 * Class: Geo.View3D.Fly
 * 三维视图飞行控制对象。
 */
Geo.View3D.Fly = Geo.Class({
    
    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 供飞行路径及路径节点显示的矢量图层。
     */
    layer: null,
	
    /**
     * APIProperty: layerOptions
	 * {Object} 路径绘制矢量图层构造参数。
     */
	layerOptions: null,
	
    /**
     * APIProperty: map
	 * {Geo.View3D.Map} 三维视图对象。
     */
	map: null,
	
    /**
     * APIProperty: drawPathControl
     * {<Geo.View3D.Control.DrawFeature>} 用于飞行路径及路径节点的矢量绘制控件。
     */	
	drawPathControl:null,
	
	
	drawPointControl:null,
    /**
     * APIProperty: defaultFlyParams
     * {Object} 默认飞行路径节点相关设置参数。一条飞行路径是由一系列路径节点组成的，如果没有特别指定，
     * 添加路径节点时会应用默认设置参数。
     * 
     */	
	defaultFlyParams:{
		//默认飞行高度（米）
		height: 0,
		//默认飞行速度(千米/秒)，一般情况下为了取得比较好的视觉效果，飞行速度宜设置为：高度/10000
		speed: 0,
		//俯仰角
		tilt: 0,
		//侧倾角
		heading: 0
	},

    /**
     * APIProperty: model
     * {Object} 飞行当前中心点模型相关设置选项，有如下选项：
     * path - {String} 模型路径，默认值为空字符串。
     * visible - {Boolean} 该模型是否可见，默认值为false。
     */		
	model: null,
	
    /**
     * APIProperty: points
     * {Array(<Geo.Geometry.Point>)} 所有飞行途经点，包含点坐标、高度、俯仰角、侧倾角参数设置。
     */	
	points:null,

    /**
     * APIProperty: pathVisible
     * {Boolean} 飞行路径是否可见。
     */	
	pathVisible: true,
	
	/**
	 * APIProperty: pathVisible
	 * {Number} 飞行路径模式。0、贴地。1、恒高。
	 */
	pathFlyMode: 0,
	
	/**
     * APIProperty: eventListeners
     * {Object} 三维视图事件监听器。
     */      
    eventListeners: null, 
    
 	/**
 	 * APIProperty: EVENT_TYPES
 	 * {Array} 支持的事件类型。
 	 */
    EVENT_TYPES: ["OnFlyFinished"],
    
    /**
     * APIProperty: events
     * {Object} 三维飞行事件对象。
     */      
    events: null,
	/**
     * APIProperty: modelPath  
     * {String} 飞机模型地址（绝对路径）。
     */
    modelPath:"C:\\airplane\\airplane.x",
    /**
     * APIProperty: modelScale  
     * {String} 飞机模型缩小到原来的0.3倍，不能为负数。
     */
	modelScale:0.3,
	/**
     * APIProperty: modelDisToScreen  
     * {String} 飞机模型距相机的距离,不能为负数。
     */
	modelDisToScreen:5.0,
    /** 
     * Constructor: Geo.View3D.Fly
     * Geo.View3D.Fly 构造函数。
     *
     * Parameters:
     * options - {Object} 选项。
     *
     */	
	initialize: function(options){
		
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
		
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        
        this.events = new OpenLayers.Events(this, null, this.EVENT_TYPES);
        if(this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
        
		this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME + "_layer", options);
		
        this.drawPathControl = new Geo.View3D.Control.DrawFeature(this.layer, Geo.View3D.Handler.Path, {
            featureAdded: OpenLayers.Function.bind(function(feature){
            	//停止飞行（避免多次绘制飞行路径的时候无法飞行）
            	this.controlFly(Geo.View3D.FLY_STOP);
				//设置飞行路径模式。0、贴地。1、恒高。
				this.setPathFlyMode(this.pathFlyMode);
				//绘制飞行线路完成后，设置飞行高度，速度，俯仰角，航仰角
//				this.setFlyCameraHeight(this.defaultFlyParams.height);
//                this.setFlySpeed(this.defaultFlyParams.speed);
//                this.setTilt(this.defaultFlyParams.tilt);
//                this.setHeading(this.defaultFlyParams.heading);
                //添加绘制要素到飞行点数组后进行飞行
                this.addFeatureToPoints(feature);
                this.drawPathControl.deactivate();
            }, this),
            //定义样式 
            handlerOptions: {   
                layerOptions: {   
	                style : {   
	                    fillOpacity : 0.8,   
	                    strokeWidth : 5,   
	                    pointRadius:20   
	                }   
	            }  
            }
        });
        this.drawPointControl = new Geo.View3D.Control.DrawFeature(this.layer, Geo.View3D.Handler.Point, {
            featureAdded: OpenLayers.Function.bind(function(feature){
				if(!feature)
					return;
        		//先停止飞行
	        	this.controlFly(Geo.View3D.FLY_STOP);
	        	//飞行的起点
	            var starPoint = new Geo.LonLat(feature.geometry.x, feature.geometry.y);
				//设置飞行参数
				this.setFlyFreePath(starPoint);
				//设置飞行高度
//				this.setFlyCameraHeight(2000);
				//设置飞行速度
//	            this.setFlySpeed(2000);
				//开始飞行,参数:Geo.View3D.FLY_START = 1;Geo.View3D.FLY_PASUE = 2;Geo.View3D.FLY_CONTINUE = 3;Geo.View3D.FLY_STOP = 4;
				this.controlFly(Geo.View3D.FLY_START);
				//设置飞行俯仰角
			//	this.setTilt(80);
                this.drawPointControl.deactivate();
            }, this)
        });
		this.points = [];
		this.model = {
			path: "",
			visible: false
		};
    },
     /**
     * APIMethod: showFlyModel
     * 显示隐藏飞机模型。
     * 
     */
    showFlyModel: function(){
    	var cross = this.map.activexObj.ScreenBox.QueryScreenElement(5);
        //如果已经显示，则隐藏
        if (cross.ModelVisible) {
            cross.ModelVisible = false;
        }
        else {
            //如果没有显示，则显示飞机模型；由于飞模型在建模时
            cross.ModelPath = this.modelPath;
            cross.ModelVisible = true;
            cross.ModelScale = this.modelScale; //模型的缩小到原来的0.3倍，不能为负数
            cross.ModelYaw = 0.0;   //绕Y轴旋转
            cross.ModelPitch = 90.0;//绕X轴旋转90度
            cross.ModelRoll = 180.0;//绕Z轴旋转180度
            cross.ModelDisToScreen = this.modelDisToScreen;//距相机的距离,不能为负数
        }
    },
    /**
     * APIMethod: initFlySet
     * 飞行参数初始化设置。
     * 
     * Parameters:
     * height - {Number} 飞行高度。
     * speed - {Number} 飞行速度。
     * tilt - {Number} 飞行俯仰角。
     * heading - {Number} 飞行侧倾角。
     */	
    initFlySet: function(height,speed,tilt,heading){
    	this.defaultFlyParams.height = height;
    	this.defaultFlyParams.speed = speed;
    	this.defaultFlyParams.tilt = tilt;
    	this.defaultFlyParams.heading = heading;
    },
	
	/**
	 * APIMethod: onFlyFinished
	 * 飞行完成时执行此函数，用户可覆写此函数，自定义飞行完成后的操作。
	 * 
	 * Parameters:
	 * event - {Object} 事件对象
	 */
	onFlyFinished:function(event){
	},
		
    /**
     * Method: setMap
     * 将飞行控件对象关联到指定三维视图对象。
     * 
     * Parameters:
     * map - {<Geo.View3D.Map>} 三维视图对象。
     */		
	setMap: function(map){
		if(this.map){
			return;
		}
		this.map = map;
        //绑定飞行完成事件
        this._onFlyFinished = OpenLayers.Function.bind(function(eventObj){
            this.onFlyFinished(eventObj);
        }, this);
   //     this.map.activexObj.attachEvent("OnFlyFinished", this._onFlyFinished);
		if (this.map.activexObj.addEventListener){
			this.map.activexObj.addEventListener("FlyFinished",this._onFlyFinished,false);      
		}else if (this.map.activexObj.attachEvent){
			this.map.activexObj.attachEvent("OnFlyFinished",this._onFlyFinished);        
		}		
        
		this._initFlyOption();
		map.addLayers([this.layer]);
		map.addControls([this.drawPathControl,this.drawPointControl]);
	},
	
	/**
	 * 解除地图关联
	 */
	removeMap: function(){
		if(this.map){
		//	this.map.activexObj.detachEvent("OnFlyFinished", this._onFlyFinished);
		if (this.map.activexObj.removeEventListener){
			this.map.activexObj.removeEventListener("FlyFinished",this._onFlyFinished,false);      
		}else if (this.map.activexObj.detachEvent){
			this.map.activexObj.detachEvent("OnFlyFinished",this._onFlyFinished);        
		}			
			this.layer && this.map.removeLayer(this.layer);
			this.drawPathControl && this.map.removeControl(this.drawPathControl);
			this.drawPointControl && this.map.removeControl(this.drawPointControl);
		};
		this.map = null;
	},

	/**
	 * APIMethod: destroy
	 * 销毁。
	 */	  
    destroy: function () {
    	this.removeMap();
        if (this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
        }
        this.eventListeners = null;
        this.events = null;
    },
    
    /**
     * APIMethod: setPathVisible
     * 设置当前飞行路径是否可见。
     * 
     * Parameters:
     * isVisible - {Boolean} 路径是否可见的标识。
     */			
	setPathVisible: function(isVisible){
		this.drawPathControl.deactivate();
		this.layer.setVisibility(isVisible);
		this.pathVisible = isVisible;
	},
	
    /**
     * APIMethod: clearFlyPath
     * 清除本次设置的飞行路径。调用本方法后会停止当前飞行，移除飞行路径绘制图层上所有要素，并且清空所有飞行路径点。
     * 
     */		
	clearFlyPath: function(){
		this.controlFly(Geo.View3D.FLY_STOP);
		this.layer.removeFeatures(this.layer.features);
		this.points = [];
		this._clearAllFlyPoint();
		this.drawPathControl.deactivate();
	},
	
    /**
     * APIMethod: activate
     * 激活飞行控件。
     */	
	activate: function(){
		Geo.View3D.Control.prototype.activate.apply(this, arguments);
		this._initFlyOption();
	},
	
	onComplete: function(geometry){},
	
	onAddPoint: function(point,time,allPoints){},
	
	addPoints: function(){
		
	},
	
	/**
	 * APIMethod: addFeatureToPoints
	 * 添加飞行路径的点要素到飞行路径点要素数组。
	 *
	 * Parameters:
	 * feature - {<Geo.Feature.Vector>} 要素。
	 */	
	addFeatureToPoints:function(feature){
		this.points = [];
		var _points = feature.geometry.components;
		for(var i=0; i<_points.length; i++){
			this.points.push({
				longitude: _points[i].x,
				latitude: _points[i].y 
			});
		}
		this.setFlyPath();
//		this.controlFly(Geo.View3D.FLY_START);		
	},
	
    /**
     * APIMethod: setTilt
     * 在飞行过程中实时调整俯仰角，有效值在0～90之间。
     * 
     * Parameters:
     * tilt - {Float} 俯仰角角度。
     */	
    setTilt: function(tilt){
		tilt = (tilt <= 0) ? 1 : tilt;
		tilt = (tilt >= 90) ? 89 : tilt;
		
//		this.defaultFlyParams.tilt = tilt;
//		this._flyMotion.FlyTilt = tilt;
//		this._flyMotion.IsRealtimeAdjust = true;
		this._camera.Tilt = tilt;
	},

    /**
     * APIMethod: setHeading
     * 在飞行过程中实时调整航向角，有效值在180～-180之间。
     * 
     * Parameters:
     * heading - {Float} 航向角角度。
     */		
	setHeading: function(heading){
//		this._flyMotion.FlyHeading = heading;
//		this._flyMotion.IsRealtimeAdjust = true;
		//自动恢复航向角 
		this._flyBox.ChangeAutoAdjustAttitude(0, false);
		this._camera.Heading = heading;
//		this.defaultFlyParams.heading = heading;
	},

    /**
     * APIMethod: setFlyPath
     * 设置描述飞行路径的几何对象。
     */		
    setFlyPath: function(){
		this._clearAllFlyPoint();
		
        for (var i = 0; i < this.points.length - 1; i++) {
            var pointStart = OpenLayers.Util.extend({}, this.points[i]);
            var pointEnd = OpenLayers.Util.extend({}, this.points[i + 1]);
            //创建一个飞行片段
            var flySegment = this._flyBox.CreateFlySegment(0);
            // 设置起点，相机所处高度默认为2000，暂时设置无效果，会被飞机高度取代
            flySegment.SetStartCoord(pointStart.longitude, pointStart.latitude, 2000);
            // 设置终点，相机所处高度默认为2000，暂时设置无效果，会被飞机高度取代
            flySegment.SetEndCoord(pointEnd.longitude, pointEnd.latitude, 2000);
            this._flyBox.AddFlySegment(flySegment);
        }
    },

    /**
     * APIMethod: getFlyPath
     * 获取飞行路径。
     */
	getFlyPath: function(){
		return this.points;
	},
	
    /**
     * APIMethod: setFlyCirclePath
     * 创建绕点飞行的路径。
     * 
     * Parameters:
     * starPoint - {<Geo.LonLat>} 起点坐标。
     * centerPoint - {<Geo.LonLat>} 绕点的中心坐标。
     * flyAngle - {Number} 设置飞行路径围绕中心点的角度。
     */
    setFlyCirclePath: function(starPoint, centerPoint, flyAngle){
        // 清除飞行片段
		this._clearAllFlyPoint();
        
        // 创建绕点飞行片段，设置起点，绕点中心和角度
		var flySegmentCircle = 1;
        var circleFlySegment = this._flyBox.CreateFlySegment(flySegmentCircle);
		
		var starPoint = starPoint ? starPoint : new Geo.LonLat(116.374153890879, 41.1);
		var centerPoint = centerPoint ? centerPoint : new Geo.LonLat(116.374153890879, 39.9056146840283);
		// 设置起点，相机所处高度默认为2000，暂时设置无效果，会被飞机的飞行高度取代
		circleFlySegment.SetStartCoord(starPoint.lon, starPoint.lat, 2000);
		// 设置绕点中心，相机所处高度默认为0，可以使相机俯视大地
        circleFlySegment.SetCentre(centerPoint.lon, centerPoint.lat, 0);
        // 设置飞行路径围绕中心点的角度
        circleFlySegment.FlyAngle = flyAngle ? flyAngle : 360;
        this._flyBox.AddFlySegment(circleFlySegment);
    },
	
	/**
     * APIMethod: setFlyFreePath
     * 设置自由飞行。
     * 
     * Parameters:
     * starPoint - {<Geo.LonLat>} 起点坐标。
     */
    setFlyFreePath: function(starPoint){
        // 清除飞行片段
		this._clearAllFlyPoint();
        // 创建绕点飞行片段，设置起点，绕点中心和角度
    	var circleFlySegment = this._flyBox.CreateFlySegment(2);
    	// 定义起点
		var starPoint = starPoint ? starPoint : new Geo.LonLat(116.374153890879, 41.001);
		// 设置起点
		circleFlySegment.SetStartCoord(starPoint.lon, starPoint.lat, 1000);
        // 设置飞行路径围绕中心点的角度
        this._flyBox.AddFlySegment(circleFlySegment);
    },			
				
    /**
     * APIMethod: controlFly
     * 控制飞行状态，可以设置开始飞行、暂停飞行、继续飞行和停止飞等状态。控制状态代码被定义为一系列常量，如下：
     * Geo.View3D.FLY_START: 1
     * Geo.View3D.FLY_PASUE: 2
     * Geo.View3D.FLY_CONTINUE: 3
     * Geo.View3D.FLY_STOP: 4
     * 
     * Parameters:
     * mode - {Integer} 控制状态代码。
     */			
	controlFly: function(mode){
		
		switch(mode) {
			case Geo.View3D.FLY_START:
				if(this.points != ""){
					this.setFlyPath();
				}
				this._startFly();
				break;
			case Geo.View3D.FLY_PASUE:
				this._flyPause();
				break;
			case Geo.View3D.FLY_CONTINUE:
				this._flyContinue();
				break;
			case Geo.View3D.FLY_STOP:
				this._flyStop();
				break;
		}
	},

    /**
     * APIMethod: setFlyCameraHeight
     * 在飞行过程中实时调整飞行高度，有效值在5～63781370之间。在调整飞行高度后，为了保证正常的显示效果会自动根据高度调整飞行速度。
     * 
     * Parameters:
     * height - {Float} 飞行高度（单位：米）。
     */	    
    setFlyCameraHeight: function(height){
//    	this.defaultFlyParams.height = height;
    	this._flyBox.RelativeHeight = height;
//		this._flyMotion.FlyHeight = height;
//		this._flyMotion.IsRealtimeAdjust = true;
	},

    /**
     * APIMethod: setFlySpeed
     * 在飞行过程中实时调整飞行速度。
     * 
     * Parameters:
     * speed - {Float} 飞行速度（单位：公里/小时）。
     */	  	
    setFlySpeed: function(speed){
//    	this.defaultFlyParams.speed = speed;
		this._flyBox.FlySpeed = speed;
//		this._flyMotion.FlySpeed = speed;
//		this._flyMotion.IsRealtimeAdjust = true;
	},
	
    /**
     * Method: setFlyMode
     * 设置飞行模式。在geospace3D中，没有提供飞行模式的设置。之前activeX有提供飞行模式的设置。
     * 暂时保留这个接口。
     * 
     * Parameters:
     * mode - {Number} 0 正常飞行，1绕点。
     */	
	setFlyMode: function(mode){
	},
	
	/**
     * APIMethod: setPathFlyMode
     * 设置飞行路径模式。
     * 
     * Parameters:
     * pathFlyMode - {Number} 0：贴地。1：恒高。
     */	
	setPathFlyMode: function(pathFlyMode){
		//贴地
		if(pathFlyMode == 0){
			this.pathFlyMode = 0;
			this._flyBox.FlyHeightStyle = 2;
		}
		//恒高
		if (pathFlyMode == 1) {
			this.pathFlyMode = 1;
			this._flyBox.FlyHeightStyle = 3;
		}
	},
    
    /**
     * Method: saveFlyPathToFile
     * 保存飞行路径至文件。
     * 
     * Parameters:
     * path - {String} 路径。
     */	
    saveFlyPathToFile:function(path){
      //this._flyRoute.SaveFlyPathToFile(path);  
    },
	
    /**
     * Method: loadFlyPathFromFile
     * 从文件里面加载飞行路径
     * 
     * Parameters:
     * path - {String} 路径
     */
    loadFlyPathFromFile:function(path){
      //this._flyRoute.LoadFlyPathFromFile(path);  
    },
	
	/**
     * APIMethod: getGeometryFromFlyPoints
     * 从三维控件里面获取飞行路径点信息，并生成Geometry。
	 */
	getGeometryFromFlyPoints: function(){
		if(this._flyRoute){
			var pointsVar= [];
			for (var i=0; i< this._flyRoute.GetCount(); i++) {
				var pointInfo = this._flyMotionWrapper.GetPoint(this._flyRoute , i);
				var lon = pointInfo.XVal; //longitude
				var lat = pointInfo.YVal; //latitude
				var point = new Geo.Geometry.Point(lon, lat);
				pointsVar.push(point);
			}
			var pathGeometry = new Geo.Geometry.LineString(pointsVar);
			return pathGeometry;
		}
		return null;
	},

    /**
     * Method: setModelPath
     * 设置飞行模型文件路径。只接受绝对路径，可以传入url或本地文件路径。例如：
     * "http://localhost:8080/demo/images/airplane/airplane.x"或"c:\\airplane\\airplane.x"。
     * 设置新的模型文件路径后，模型的可见状态将被设置为false，调用setModelVisible(true)方法可将模型显示打开。
     * 
     * Parameters:
     * filePath - {String} 模型文件路径。
     */		
	setModelPath: function(filePath){
//		var globe = this.map.activexObj;
//		if (globe && (this.model.path !== filePath)) {
//			this.model.path = filePath;
//			this.model.visible = false;
//			globe.SetModelVisible(filePath,this.model.visible);
//		}
	},

    /**
     * APIMethod: setModelVisible
     * 设置当前飞行模型是否可见。
     * 
     * Parameters:
     * isVisible - {Boolean} 模型是否可见。
     */		
	setModelVisible: function(isVisible){
//		var globe = this.map.activexObj;
//		if (globe) {
//			this.model.visible = isVisible;
//			globe.SetModelVisible(this.model.path,isVisible);
//		}
	},

    /**
     * APIMethod: setCameraMode
     * 设置当前相机人称视角。
     * 
     * Parameters:
     * mode - {Number} mode值为0，代表第一人称视角表现飞行功能；mode值为1，代表第三人称视角。
     */		
	setCameraMode: function(mode){
		this._camera.CameraMode = mode;// mode为0，代表第一人称视角表现飞行功能
	},

    /**
     * APIMethod: getCameraMode
     * 获取当前相机人称视角
     * 
     * Returns:
     * {Number} 用于表示第一或第三人称视角表现飞行功能；值为0(1)，代表第一（三）人称视角。
     */		
	getCameraMode: function(){
		return this._camera.CameraMode;
	},
	
	//调整高度后，重新根据高度设置速度
	_getFlySpeed: function(height){
		return height * 14;
	},
	
	_flyRoute: null,
	
	_flyMotion: null,
	
	_camera: null,
	
	//初始化飞行所需对象
	_initFlyOption: function(){
		var globe = this.map.activexObj;
		if(globe){
			this._flyBox = globe.FlyBox;
			this._camera = globe.Camera;
			//geoSpace3D.FlyBox.FlyControl.Camera.CameraMode = 0;
			
//			this._flyRoute = globe.CreateFlyRoute();
//			this._flyMotion = globe.CreateFlyMotion();
//			this._flyMotionWrapper  = globe.GetFlyMotionWrapper();
//			this._camera = globe.GetCamera();

		}
		
	},
	
	//绘制飞行路径后，开始飞行之前，做相应参数设置
	_startFly: function(options){
		if(this._flyBox){
			this._flyBox.StartFly(0);
			//this._camera.CameraMode = 0;
			//this._flyMotion.SetFlyRoute(this._flyRoute);
	        //this._flyMotion.SetCamera(this._camera);
			//this._flyContinue();
		}
	},
	
	_flyPause: function(){
		if(this._flyBox){
			this._flyBox.PauseFly();
			//this._camera.CameraMode = 1;// 不是飞行状态时，恢复第三人称视角。
			//this._flyMotion.Pause();
		}
	},
	
	_flyContinue: function(){
		if(this._flyBox){
			this._flyBox.ResumeFly();
			//this._camera.CameraMode = 0;// 第一人称视角表现飞行功能
			//this._flyMotion.Fly();
		}
	},
	
	_flyStop: function(){
		if(this._flyBox){
			this._flyBox.StopFly();
			this._flyBox.ClearFlySegment();
			//this._camera.CameraMode = 1;// 不是飞行状态时，恢复第三人称视角。
			//this._flyMotion.Stop();
		}
		
	},	
	
	// 清除所有添加的飞行片段
	_clearAllFlyPoint: function(){
//		if(this._flyRoute){
//			this._flyRoute.removeAll();
//		}
		if (this._flyBox) {
			this._flyBox.ClearFlySegment();
		}
	},	
	
    CLASS_NAME: "Geo.View3D.Fly"

});

/**
 * Constant: Geo.View3D.FLY_START
 * 开始飞行的常量。
 */
Geo.View3D.FLY_START = 1;

/**
 * Constant: Geo.View3D.FLY_PASUE
 * 暂停飞行的常量。
 */
Geo.View3D.FLY_PASUE = 2;

/**
 * Constant: Geo.View3D.FLY_CONTINUE
 * 继续飞行的常量。
 */
Geo.View3D.FLY_CONTINUE = 3;

/**
 * Constant: Geo.View3D.FLY_STOP
 * 停止飞行的常量。
 */
Geo.View3D.FLY_STOP = 4;

Geo.View3D.Fly_MODE_ROUND = 1;
Geo.View3D.Fly_MODE_PATH = 0;
/**
 * Class: Geo.View3D.Popup
 * > popup是可以在三维地图上打开和关闭的小型弹出窗口，通常是用于在选中一个矢量要素时，显示该要素的详细信息。
 * > popup通过<Geo.View3D.Map.addPopup>方法添加到三维地图中。
 *
 * Examples:
 * (code)
 * popup = new Geo.View3D.Popup("3dPoup", 
 *                    new Geo.LonLat(5,40),
 *                    new Geo.Size(200,200),
 *                    "这是一个弹出框示例",
 *                    true);
 * map.addPopup(popup);
 * (end)
 */
Geo.View3D.Popup = Geo.Class({

    
    /** APIProperty: id
     * {String} 唯一标识。
     */
    id: "",

    /** 
     * APIProperty: lonlat 
     * {<Geo.LonLat>} 弹出框在地图中的坐标。
     */
    lonlat: null,


    /** 
     * APIProperty: size 
     * {<Geo.Size>} 弹出框的尺寸。
     */
    size: null,    

    /** 
     * APIProperty: contentHTML 
     * {String} 弹出框内显示的内容，如果contentHTML内容用到了CSS样式文件，注意使用CSS文件的绝对地址，否则无效果。
     */
    contentHTML: null,
    
    
    /** 
     * APIProperty: map 
     * {<Geo.View3D.Map>} 三维地图对象的引用。
     */
    map: null,
	
    /** 
     * APIProperty: contentType 
     * {int} 弹出框的内容类型，0.text 1.html 2.url，默认为html。
     */
    contentType: 1,

    //关闭时的回调函数
    _closeBoxCallback: null,
	
	 /** 
     * APIProperty: z 
     * {double} 浮云框锚点位置Z坐标，默认为0.0。
     */
	z: 0,
	
	 /**
     * APIMethod: setPositionZ
     * 绘制弹出框。
     *
     * Parameters:
     * pZ - {Object} z坐标值
     */
    setPositionZ: function(pZ) {
		z = pZ;
	},
	
    /**
     * Constructor: Geo.View3D.Popup
     * Geo.View3D.Popup构造函数。
     *
     * Parameters:
     * id - {Object} 编号。
     * lonlat - {Object} 经纬度信息。
     * contentSize - {Object} 尺寸大小。
     * contentHTML - {Object} HTML代码。
     * closeBox - {Boolean} 是否显示关闭按钮。
     * closeBoxCallback - {Object} 点击关闭按钮的回调函数。
     */
    initialize:function(id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback) {
        if (id == null) {
            id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }

        this.id = id;
        this.lonlat = lonlat;

        this.contentSize = (contentSize != null) ? contentSize 
                                  : new Geo.Size(
                                                   Geo.View3D.Popup.WIDTH,
                                                   Geo.View3D.Popup.HEIGHT);
        if (contentHTML != null) { 
             this.contentHTML = contentHTML;
        }
		
		this._closeBox = new Boolean(closeBox);
		this._closeBoxCallback = closeBoxCallback;
    },
	
    //三维浮云框关闭按钮事件响应
    _closeBoxHandler: function(eType, bubbleWindwo, param) {
        var closeBoxCallback = this._closeBoxCallback;
        if (!closeBoxCallback) {
            return;
        }

        if (eType == 0) {
            closeBoxCallback();
        }
	    if(this.map && this.map.activexObj){
		   this._removeCloseBoxHandler();
		}
    },

    //附加关闭按钮事件响应
    _addCloseBoxHandler: function() {
        var globe = this.map.activexObj;
        this._closeBoxHandler = OpenLayers.Function.bind(this._closeBoxHandler, this);
    //    globe.attachEvent("OnBubbleWindowEvent", this._closeBoxHandler);
		if (globe.addEventListener){
			globe.addEventListener("BubbleWindowEvent",this._closeBoxHandler,false);      
		}else if (globe.attachEvent){
			globe.attachEvent("OnBubbleWindowEvent",this._closeBoxHandler);        
		}	
    },

    //移除关闭按钮事件响应
    _removeCloseBoxHandler: function(callbackFn) {
        var globe = this.map.activexObj;
    //    globe.detachEvent("OnBubbleWindowEvent", this._closeBoxHandler);
		if (globe.removeEventListener){
			globe.removeEventListener("BubbleWindowEvent",this._closeBoxHandler,false);      
		}else if (globe.detachEvent){
			globe.detachEvent("OnBubbleWindowEvent",this._closeBoxHandler);        
		}	
    },
    
    /**
     * APIMethod: draw
     * 绘制弹出框。
     *
     * Parameters:
     * px - {Object} 
     */
    draw: function(px) {
		var lonlat = px;
		var contentSize = this.contentSize;
		var contentHTML = this.contentHTML; 
        this._draw();//lonlat.lon,lonlat.lat,contentSize.w

    },
	
     //设置浮云框内容类型，可以为纯文本、HTML、URL
    _setContentType: function(){
        var globe = this.map.activexObj;
        globe.SceneGroup.SetBubbleContentType(this.contentType);
    },
    
	// 绘制
	_draw: function(){
		var map = this.map;
		if(map && map.activexObj){
		   var globe = map.activexObj;		  
		   var lonlat = this.lonlat;
		   var size = this.contentSize;
		   var sg = globe.SceneGroup;
		   var screenLoaction = map.lonlatToScreen(lonlat.lon,lonlat.lat,this.z);
		   // 改用SceneGroup
		   sg.BubbleWindow.Visible = true;
		   sg.BubbleWindow.SetMinMaxSize(200, 250, 900, 900);
           sg.BubbleWindow.PinMap(lonlat.lon,lonlat.lat,this.z);   
		   this._setContentType();
           sg.BubbleWindow.Height = size.h;
	       sg.BubbleWindow.Width = size.w;
	       sg.BubbleWindow.Content = this.contentHTML;
		   sg.BubbleWindow.ScreenX = screenLoaction.x + 100;
		   sg.BubbleWindow.ScreenY = screenLoaction.y + 100;
		   this._addCloseBoxHandler();
		}
		
	},
	
	// 清除弹出框
	_clear: function(){
		var map = this.map;
		if(map && map.activexObj){
			var globe = map.activexObj;
		   	var sg = globe.SceneGroup;
		   	sg.DeleteBubbleWindow();
		   	this._removeCloseBoxHandler();
		}
	},
	
    CLASS_NAME: "Geo.View3D.Popup"
});

Geo.View3D.Popup.WIDTH = 270;
Geo.View3D.Popup.HEIGHT = 152;
Geo.View3D.Popup.COLOR = "white";
Geo.View3D.Popup.OPACITY = 1;
Geo.View3D.Popup.BORDER = "0px";
Geo.View3D.Popup.CONTENT_TYPE_TEXT = 0;
Geo.View3D.Popup.CONTENT_TYPE_HTML = 1;
Geo.View3D.Popup.CONTENT_TYPE_URL = 2;
/**
 * Class: Geo.View3D.Popup.FramedCloud
 * 三维视图浮云框。
 *
 * Inherits from:
 *  - <Geo.View3D.Popup>
 */
Geo.View3D.Popup.FramedCloud = Geo.Class(Geo.View3D.Popup,{
	
	/** 
     * Constructor: Geo.View3D.Popup.FramedCloud
     * Geo.View3D.Popup.FramedCloud构造函数。
     * 
     * Parameters:
     * id - {String}  浮云框的唯一标识，如果没有设置将会自动生成一个。
     * lonlat - {<Geo.LonLat>} 地图上浮云显示的位置。
     * contentSize - {<Geo.Size>} 浮云的尺寸。
     * contentHTML - {String} 浮云内容，浮云内容为HTML要素的字符串。如果HTML内容引用了CSS样式文件，注意引用CSS文件的绝对地址，否则无效果。
     * anchor - {Object} 锚点。包含一个大小信息{<Geo.Size>}和偏移信息{<Geo.Pixel>}的对象。
     * closeBox - {Boolean} 是否显示关闭浮云窗口的按钮。
     * closeBoxCallback - {Function} 关闭浮云触发该回调函数。
     */
    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
                        closeBoxCallback) {
		var newArguments = [
            id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback
        ];
        Geo.View3D.Popup.prototype.initialize.apply(this, newArguments);
    },

    CLASS_NAME: "Geo.View3D.Popup.FramedCloud"
});/**
 * Class: Geo.View3D.FeatureManager
 * 要素结果管理器。提供了与矢量要素相关的一系列功能。支持对同一矢量图层上的要素进行分类管理，包含矢量图层样式设置、
 * 要素选择功能、要素浮云显示、要素集客户端分页等功能。
 */
Geo.View3D.FeatureManager = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识。
     */
    id: null,	
    
    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 所属的地图对象。
     */
    map: null,
	
	//结果类型映射
	_typeMapping: null,
	
	/**
     * APIProperty: featureSortField
     * {String} 标识要素分类的属性名。
     */
	featureSortField: "featureSort",

	/**
     * APIProperty: orderNumberField
     * {String} 标识要素序号的属性名。
     */	
	orderNumberField: "orderNumber",

	/**
     * APIProperty: vectorLayer
     * {<Geo.View3D.Layer.Vector>} 矢量图层。
     */		
	vectorLayer: null,

	/**
     * APIProperty: selectControl
     * {<Geo.View3D.Control.SelectFeature>} 矢量要素选择控件。
     */	
	selectControl: null,

	/**
     * APIProperty: selectControl
     * {Integer} 默认的要素分页数量。
     */	
	maxFeaturesPerPage: 15,

    /**
     * Constructor: Geo.View3D.FeatureManager
     * Geo.View3D.FeatureManager对象构造函数
     * 
     * Parameters:
     * options - {Object} 相关选项设置
     */
	initialize: function(options){
		this._typeMapping = {};
		this.registerResultType("default");
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: setMap
     * 将要素管理对象关联到相应的地图对象。在关联到地图对象时,会在地图对象中加入一个矢量图层和相关控件。
     *
     * Parameters:
     * map - {<Geo.View3D.Map>} 地图对象
     */
	setMap: function(map){
		if(map && !this.map){
			this.map = map;
			
			//添加结果图层
			this.vectorLayer = new Geo.View3D.Layer.Vector("GeoGlobeFeatureManagerVector", {
				isOnTop: true,
				displayInLayerSwitcher: false
			});
			this.map.addLayer(this.vectorLayer);
			this._initSelectControl();
		}
	},

	/**
     * APIMethod: registerFeatureSort
     * 注册要素类别。如果希望对多个分类的要素进行管理，则需要先注册要素类别加以区分，
     * 然后再调用addFeatures方法向分类中添加要素集。
     *
     * Parameters:
     * sort - {String} 要素分类
     * options - {Object} 参数设置
     */	
	registerFeatureSort: function(sort,options){
		var DEFAULT_PARAMS = {
			features:[],
			currentPage:0,
			maxFeaturesPerPage: this.maxFeaturesPerPage,
			onTurnToPage: this.onTurnToPage,
			onFeatureSelect: Geo.View3D.FeatureManager.showFramedCloud,
			onFeatureUnselect: Geo.View3D.FeatureManager.closeFramedCloud,
			onFeatureOver: Geo.View3D.FeatureManager.showTopic,
			onFeatureOut: Geo.View3D.FeatureManager.closeTopic
		};
		this._typeMapping[sort] = OpenLayers.Util.extend(DEFAULT_PARAMS,options);
	},

     
    //此方法已被废弃，推荐使用registerResultSort
	registerResultType: function(sort,options){
        this.registerFeatureSort(sort,options);
	},
	
	/**
     * APIMethod: addFeatures
     * 向类别中添加要素，要素添加到类别后将为要素的外部属性中加上类型标识。
     *
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 添加的要素数组
     * sort - {String} 要素类别
     * isAppend - {Boolean} 是否追加要素
     */		
	addFeatures: function(features,sort,isAppend){
		sort = sort || "default";
        if(!(Geo.Util.isArray(features))) {
			features = [features];
		}
		
		if(this._typeMapping[sort]){
			var features =  this._addTypeMarker(features,sort);
			
			//为要素添加自定义样式
			var style = this._typeMapping[sort].style;
			if(style){
				this._addStyleForFeatures(features,style);
			}
			
			if(!isAppend){
				this.clearResultFromMap(sort);
				this._typeMapping[sort].features = features;
			} else {
				this._typeMapping[sort].features.concat(features);
			}
			this._typeMapping[sort].currentPage = 0;
		}
	},
	
	/*
	 * APIMethod: onTurnToPage
	 * 获取当前页的要素，本方法需要用户自己去覆盖
	 * 
	 */
	onTurnToPage: function(feature){
		
	},
	
	/**
     * APIMethod: turnToPageN
     * 翻到指定页数。
     *
     * Parameters:
     * page - {Integer} 当前第几页
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。
     */	
	turnToPageN: function(page, sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];

		var pageNum = this.getTotalPageNumber(sort);
		page = (page <= 0) ? 1 : page;
		page = (page > pageNum) ? pageNum : page; 
				
		var features = this._pagingFeatures({
			maxPerPage: mapping.maxFeaturesPerPage,
			pageNum:page,
			resultArr:mapping.features
		});
        
        this.addOrderForFeatures(features);
				
		if(page !== mapping.currentPage){
			this.clearResultFromMap(sort);
			this.drawFeaturesToMap(features);
			mapping.currentPage = page;
		}
		mapping.onTurnToPage(features);
		
		return features;
	},
	
	/**
     * APIMethod: turnToFirst
     * 翻到首页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。 
     */		
	turnToFirst:function(sort, isDrawToMap){
		sort = sort || "default";
		return this.turnToPageN(1,sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToNext
     * 翻到下页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。
     */		
	turnToNext:function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage + 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToPre
     * 翻到前页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。 
     */		
	turnToPre:function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage - 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToLast
     * 翻到尾页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     */		
	turnToLast:function(sort, isDrawToMap){
		sort = sort || "default";
		var last = this.getTotalPageNumber(sort);
		this.turnToPageN(last, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: getPageInfo
     * 获取分页相关情况。
     *
     * Parameters:
     * sort - {String} 要素类别
     * 
     * Returns:
     * pageInfo - {Integer} 分页相关情况。
     */		
	getPageInfo: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getTotalPageNumber
     * 获取指定类别的要素分页页数。
     *
     * Parameters:
     * sort - {String} 要素类别
     * 
     * Returns:
     * pageInfo - {Integer} 分页相关情况。
     */			
	getTotalPageNumber: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getFeatures
     * 获取指定结果类型的要素。
     *
     * Parameters:
     * sort - {String} 要素类别
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。  
     */		
	getFeatures:function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return mapping.features;
	},
	
	/**
     * APIMethod: drawFeaturesToMap
     * 将要素绘制到地图上，可以是指定类别名或指定要素数组。
     *
     * Parameters:
     * content - {String|<Array(Geo.Feature.Vector)>} 
     */		
	drawFeaturesToMap: function(content){
		var map, layer, features;
		map = this.map;
		layer = this.vectorLayer;
		
		if( typeof(content) == "string"){
			var sort = content || "default";
			if(this._typeMapping[sort] && map){
				features = this.getFeatures(sort);
			}

		};
		
		if( content instanceof  Array){
			features = content;
		};
		layer.addFeatures(features);
		layer.map.zoomToExtent(layer.getDataExtent());
	},
	
	/**
     * APIMethod: selectFeatureById
     * 通过ID来指定要素,通过选择控件来选择。
     *
     * Parameters:
     * featureid - {String|<Array(Geo.Feature.Vector)>} 要素编号
     */	
	selectFeatureById:function(featureid){
		this.selectControl.unselectAll();
//		var feature = this.vectorLayer.getFeatureById(featureid);
//		this.selectControl.select(feature);
		this.selectControl.select(featureid);
	},

	/**
     * APIMethod: clearFeatureFromMap
     * 清除指定类别要素,如无指定类别则默认清除"default"类别，如果指定值为"allType"则清除所有分类要素。
     *
     * Parameters:
     * sort - {String|<Array(Geo.Feature.Vector)>} 要素类别
     */		
	clearFeatureFromMap: function(sort){		
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features;
		var layer = this.vectorLayer;
		if(sort == "allType"){
			features = this.vectorLayer.features;
		} else {
			features = mapping ? mapping.features : [];
		}
		
		if(layer){
			this.selectControl.unselectAll();
			layer.removeFeatures(features);
		}
		
		
	},

    //此方法被废弃，推荐使用clearFeatureFromMap
	clearResultFromMap: function(sort){		
		this.clearFeatureFromMap(sort);
	},
	
	/**
     * APIMethod: addOrderForFeatures
     * 为要素数组中每个要素按顺序添加编号，编号是记录在“orderNumberField”属性指定的要素
     * 外部属性中。
     *
     * Parameters:
     * features - {Array<Geo.Feature.Vector>} 要素数组
     * 
     * Returns:
     * {Array<Geo.Feature.Vector>}
     */	
	addOrderForFeatures: function(features){
		//添加带序号的结果图标
	    for (var i = 0; i < features.length; i++) {
	        features[i].attributes[this.orderNumberField] = i;
	    }
		return features;
	},
    	
	//为要素加上样式
	_addStyleForFeatures: function(features, style){
		for(var i=0; i<features.length; i++){
			var f = features[i];
			if(!f.style){
				f.style = style;
			}
		}
	},
	
	//为每个要素添加类型标识属性
	_addTypeMarker: function(features,type){
		for(var i=0; i<features.length; i++){
			var feature = features[i];
			feature.attributes[this.featureSortField] = type;
		}
		return features;
	},
	
	/**
	 * 对指定结果要素数组进行分页处理
	 * options示例:
	 * {
	 * 		maxPerPage:15,
	 * 		pageNum:1,
	 * 		resultArr:[]
	 * }
	 */
	_pagingFeatures: function(options){
	    var start, end, 
			maxPerPage = options.maxPerPage, 
			pageNum = options.pageNum, 
			resultArr = options.resultArr;
	    start = (pageNum - 1) * maxPerPage;
	    end = pageNum * maxPerPage - 1;
	    
		var features = resultArr.slice(start, end + 1);
	    
	    //添加带序号的结果图标
	    var prefix = "images/resultIcons/";
	    for (var i = 0; i < features.length; i++) {
	        features[i].attributes[this.orderNumberField] = i;
	    }
	    
	    return features;
	},
	
	//根据事件类型分派事件
	_dispatchEvent: function(scope,feature,eventType){
		var resultType = feature.attributes[scope.featureSortField];
		var mapping = scope._typeMapping[resultType];
		mapping[eventType](feature);
	},
	
	//激活选择控件,自动检查是否控件初始化
	_initSelectControl: function(){
		if(!this.map){
			return;
		}
		if(!this.selectControl){
			
			//添加选择控件
			this.selectControl = new Geo.View3D.Control.SelectFeature(this.vectorLayer,{
				onSelect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureSelect");
				},this),
				onUnselect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureUnselect");
				},this),
				callbacks:{
					over: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOver");
					},this),
					out: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOut");
					},this)
				}
			})
			this.map.addControl(this.selectControl);
		}
	}
});

/**
 * APIProperty: Geo.View3D.FeatureManager.defaultStyleMap
 * {<Geo.StyleMap>} FeatureManager中vectorLayer图层的默认要素样式。
 */
Geo.View3D.FeatureManager.defaultStyleMap = new Geo.StyleMap({
    "default": new Geo.Style({
    	externalGraphic: OpenLayers.Util.getImagesLocation() + "marker.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    }) ,
    "select": new Geo.Style({
        externalGraphic: OpenLayers.Util.getImagesLocation() + "marker-blue.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    })
});

/**
 * APIMethod: Geo.View3D.FeatureManager.showFramedCloud
 * 为要素添加浮云，如果指定指定内容模板则浮云内空按模板规则生成。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素
 * templateString - 字符串内容模板
 * 
 */
Geo.View3D.FeatureManager.showFramedCloud = function(feature, templateString){
	var layer = feature.layer, map = layer ? layer.map : null;
	if(!layer || !map){
		return;
	}
	var str;
	if(templateString){
		var obj = {}
		for(var item in feature.attributes){
			obj[item] = feature.attributes[item];
		}
		str = OpenLayers.String.format(templateString,obj);
	} else {
		str = (function(){
	        var str = "";
	        for (var myitem in feature.attributes) {
	            str += myitem + ":" + feature.attributes[myitem] + "<br>";
	        }
	        return str;
	    })();
	}
    

	var lonlat = feature.geometry.getBounds().getCenterLonLat();
	
    if (map) {
        //map.panTo(lonlat);
		// 4000为设置的三维俯视高度
		map.flyTo(lonlat, 4000);
    }
    
    var popup = new Geo.View3D.Popup.FramedCloud(
		"featureInfo", 
		lonlat, 
		null, 
		str, 
		null, 
		true, 
		Geo.View3D.FeatureManager.onPopupClose
	);
    feature.popup = popup;
    map.addPopup(popup);
};

/**
 * APIMethod: Geo.View3D.FeatureManager.closeFramedCloud
 * 关闭并消毁指定要素上添加的浮云。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素
 * 
 */
Geo.View3D.FeatureManager.closeFramedCloud = function(feature){
    
};

/**
 * APIMethod: Geo.View3D.FeatureManager.onPopupClose
 * 浮云关闭时触发的方法。
 */
Geo.View3D.FeatureManager.onPopupClose = function(){
   
}
	
Geo.View3D.FeatureManager.showTopic = function(feature){
	
};
	
Geo.View3D.FeatureManager.closeTopic = function(feature){
	
};
/**
 * Class: Geo.View3D.Control.Measure.PointInfo
 * 量算出一个点的信息结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.PointInfo = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Point,
    
    //MEASURE_PARAM: 6,
    /**
     * Constructor: Geo.View3D.Control.Measure.PointInfo
     * 构造函数。生成一个Geo.View3D.Control.Measure.PointInfo的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
        var pointsString = geometry.x + "," + geometry.y;
        var options = {};
        options.coordinates = pointsString;
        
		var longitude = parseFloat(geometry.x);
		var latitude = parseFloat(geometry.y);
		var altitude = this.map.activexObj.AnalysisBox.QueryAltitude(longitude, latitude);
        //最终结果定义
        var finalResult = {
            longitude: longitude,
            latitude: latitude,
            altitude: altitude,
            slope: null,
            aspect: null
        };
        
		
		this.onComplete(finalResult);
//        //分三次异步请求查询高程、坡度、坡向
//        this._getMeasureResult("pointAltitude", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.altitude = result.Result.Value;
//            this._getMeasureResult("pointSlope", options, OpenLayers.Function.bind(function(result){
//                if (this._terrainAnalysisService._isException(result)) {
//                    this.onComplete(result);
//                    return result;
//                }
//                finalResult.slope = result.Result.Value;
//                this._getMeasureResult("pointAspect", options, OpenLayers.Function.bind(function(result){
//                    if (this._terrainAnalysisService._isException(result)) {
//                        this.onComplete(result);
//                        return result;
//                    }
//                    finalResult.aspect = result.Result.Value;
//                    this.onComplete(finalResult);
//                }, this));
//            }, this));
//        }, this));
        
        
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(){
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.PointInfo"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.PointInfo"

});

/**
 * Class: Geo.View3D.Control.Measure.Distance
 * 量算出距离结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Distance = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Path,
    
    /**
     * APIProperty: isRealTime
     * {Boolean} 是否实时获取结果。 默认值为false。
     */
    isRealTime: false,
    //MEASURE_PARAM: 7,
    /**
     * Constructor: Geo.View3D.Control.Measure.Distance
     * 构造函数。生成一个Geo.View3D.Control.Measure.Distance的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /*
     _measureHandler: function(mouseEvent){
     var result = {
     distance: mouseEvent.Distance,
     surfDistance: mouseEvent.SurfDistance
     };
     this._result = result;
     this.onAddPoint(result);
     },
     */
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        
        var finalResult = {
            distance: null,
            surfDistance: null
        };
        finalResult.distance = geometry.getGeodesicLength();
		
		this.onComplete(finalResult);
//        this._getMeasureResult("surfaceDistance", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.surfDistance = result.Result.Value;
//            this.onComplete(finalResult);
//        }, this));
    },
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 1) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            var finalResult = {
                surfDistance: null
            };
            
            this._getMeasureResult("surfaceDistance", options, OpenLayers.Function.bind(function(result){
            
                finalResult.surfDistance = result.Result.Value;
                this.onAddPoint(finalResult);
            }, this));
        }
        
        
        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
    
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.PointInfo"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.PointInfo"

});

/**
 * Class: Geo.View3D.Control.Measure.Area
 * 量算出一个面结果。
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Area = Geo.Class(Geo.View3D.Control.Measure, {

    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型。
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 2,
    
    /**
     * APIProperty: isRealTime
     * {Boolean} 是否实时获取结果。 默认值为false。
     */
    isRealTime: false,
    
    /**
     * Constructor: Geo.View3D.Control.Measure.Area
     * 构造函数。生成一个Geo.View3D.Control.Measure.Area的实例。
     * 
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /*
     _measureHandler: function(mouseEvent){
     var result = {
     area: mouseEvent.Area,
     surfArea: mouseEvent.SurfArea
     };
     this._result = result;
     this.onAddPoint(result);
     },
     */
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法。
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
    
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法。
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法。
     * geometry - {Object} 要素。
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        
        var finalResult = {
            area: null,
            surfaceArea: null
        };
        finalResult.area = geometry.getGeodesicArea();
		
		this.onComplete(finalResult);
//        this._getMeasureResult("surfaceArea", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.surfaceArea = result.Result.Value;
//            this.onComplete(finalResult);
//        }, this));
    },
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法。
     * pointGeometry - {Object}
     * lineGeometry - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            var finalResult = {
                surfaceArea: null
            };
            
            this._getMeasureResult("surfaceArea", options, OpenLayers.Function.bind(function(result){
            
                finalResult.surfaceArea = result.Result.Value;
                this.onAddPoint(finalResult);
            }, this));
        }
        
        
        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
    
    /*
     _onComplete:function(geometry){
     this.onComplete(this._result);
     },
     
     _onAddPoint: function(pointGeometry,polygonGeometry){
     
     //检查多于两个点才计算
     var linearRing = polygonGeometry.components[0];
     var allPoints = linearRing.components;
     if(allPoints.length <= 2){
     return;
     }
     //正式量算
     var pointsStr = this._getPointsSpaceSplitStr(polygonGeometry,0);
     this._setMeasureParams(this.MEASURE_PARAM, pointsStr, 0);
     },
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Area"
});

/**
 * Class: Geo.View3D.Control.Measure.Volume
 * 量算体积的分析结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Volume = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 2,
    /**
     * APIProperty: height
     * {Integer} 海拔高度。 默认值为200。
     */
    height: 200,
	
    /**
     * Constructor: Geo.View3D.Control.Measure.Volume
     * 构造函数。生成一个Geo.View3D.Control.Measure.Volume的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /*
     _measureHandler: function(mouseEvent){
     var result = {
     height: this.height,
     volume: mouseEvent.Volume
     };
     this._result = result;
     this.onAddPoint(result);
     },
     */
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /*
     _onComplete:function(geometry){
     this.onComplete(this._result);
     },
     
     _onAddPoint: function(pointGeometry,polygonGeometry){
     var linearRing = polygonGeometry.components[0];
     var allPoints = linearRing.components;
     if(allPoints.length <= 2){
     return;
     }
     var pointsStr = this._getPointsSpaceSplitStr(polygonGeometry);
     this._setMeasureParams(this.MEASURE_PARAM, pointsStr, this.height);
     },
     */
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        options.subjoin = this.height;
        var finalResult = {
            height: this.height,
            geometry: geometry,
            //excavate:null,
            //file:null,
            volume: null
        };
		
		
		this.onComplete(finalResult);
//        this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            var arr = result.Result.Value.split(" ");
//            finalResult.volume = arr[0];
//            //finalResult.excavate = arr[1];
//            //finalResult.fill = arr[2];
//            this.onComplete(finalResult);
//        }, this));
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            options.subjoin = this.height;
            var finalResult = {
                height: this.height,
                geometry: lineGeometry,
                //excavate: null,
                //fill: null,
                volume: null
            };
            
            this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
            
                //finalResult.volume = result.Result.Value;
                var arr = result.Result.Value.split(" ");
                finalResult.volume = arr[0];
                finalResult.excavate = arr[1];
                finalResult.fill = arr[2];
                this.onAddPoint(finalResult);
            }, this));
        }

        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Volume"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Volume"

});

/**
 * Class: Geo.View3D.Control.Measure.Excavate
 * 量算填挖方的分析结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Excavate = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 0,
    /**
     * APIProperty: height
     * {Integer} 海拔高度。 默认值为200。
     */
    height: 200,
	
    /**
     * APIProperty: lowHeight
     * {Integer} 挖填方高度(低)。 默认值为0。
     */
	lowHeight: 0,
	
    /**
     * APIProperty: highHeight
     * {Integer} 挖填方高度(高)。 默认值为200。
     */
	highHeight: 200,
    /**
     * Constructor: Geo.View3D.Control.Measure.Excavate
     * 构造函数。生成一个Geo.View3D.Control.Measure.Excavate的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        options.subjoin = this.height;
        var finalResult = {
            height: this.height,
            geometry: geometry,
            excavate: null,
            fill: null,
            volume: null
        };
		
		var ringStr = geometry.toString().replace("POLYGON","Ring");
		var ringStr = ringStr.replace("((","(");
		var ringStr = ringStr.replace("))",")");
        var polygon3D = this.map.activexObj.DrawBox.CreateGeometryObject(ringStr, "", 3, 1);
        //var polygon = this.map.activexObj.DrawBox.CreateGeometryObject("Ring(114 30,115 30,115 31,114 31,114 30)", "", 3, 1);
		var result3D = this.map.activexObj.AnalysisBox.CutFill(polygon3D, this.lowHeight, this.height);
        //var result = this.map.activexObj.AnalysisBox.CutFill(polygon, 0, 1);
		finalResult.excavate = result3D.CutVolume;
		finalResult.fill = result3D.FillVolume;
		finalResult.volume = 0;
		this.onComplete(finalResult);
		
       // alert("填：" + result.FillVolume + "挖：" + result.CutVolume);
//        this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            var arr = result.Result.Value.split(" ");
//            finalResult.volume = arr[0];
//            finalResult.excavate = arr[1];
//            finalResult.fill = arr[2];
//            this.onComplete(finalResult);
//        }, this));
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            options.subjoin = this.height;
            var finalResult = {
                height: this.height,
                geometry: lineGeometry,
                excavate: null,
                fill: null,
                volume: null
            };
            
            this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
            
                //finalResult.volume = result.Result.Value;
                var arr = result.Result.Value.split(" ");
                finalResult.volume = arr[0];
                finalResult.excavate = arr[1];
                finalResult.fill = arr[2];
                this.onAddPoint(finalResult);
            }, this));
        }
    },
    
    /**
     * APIMethod: deactivate
     * 取消激活控件并清除盒子图层
     * Returns:
     * {Boolean} true
     */
    deactivate: function(){
        if (Geo.View3D.Control.prototype.deactivate.apply(this, arguments)) {
            //this._clearBoxLayer();
        }
        return true;
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Excavate"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Excavate"

});

/**
 * Class: Geo.View3D.Control.Measure.Flood
 * 量算淹没分析的结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Flood = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 1,
    /**
     * APIProperty: height
     * {Integer} 海拔高度。 默认值为2000。
     */
    height: 2000,
    
    solidOptions: null,
    
    solid: null,
    /**
     * Constructor: Geo.View3D.Control.Measure.Flood
     * 构造函数。生成一个Geo.View3D.Control.Measure.Flood的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    _measureHandler: function(mouseEvent){
        var result = {
            height: this.height,
            volume: mouseEvent.Volume,
            inundatedArea: mouseEvent.InundatedArea,
            floodArea: mouseEvent.FloodArea,
            floodVolume: mouseEvent.FloodVolume
        };
        this._result = result;
        this.onAddPoint(result);
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /*
     _onComplete:function(geometry){
     this._createBoxLayer(geometry);
     this.onComplete(this._result);
     },
     
     _onAddPoint: function(pointGeometry,polygonGeometry){
     var linearRing = polygonGeometry.components[0];
     var allPoints = linearRing.components;
     if(allPoints.length <= 2){
     return;
     }
     var pointsStr = this._getPointsSpaceSplitStr(polygonGeometry);
     this._setMeasureParams(this.MEASURE_PARAM, pointsStr, this.height);
     },
     */
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        options.subjoin = this.height;
        var finalResult = {
            height: this.height,
            inundatedArea: null,
            floodArea: null,
            floodVolume: null
        };
		
		this.onComplete(finalResult);
//        this._getMeasureResult("floodAnalysis", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            var arr = result.Result.Value.split(" ");
//            finalResult.inundatedArea = arr[0];
//            finalResult.floodArea = arr[1];
//            finalResult.floodVolume = arr[2];
//            this._drawSolid(geometry);
//            this.onComplete(finalResult);
//        }, this));
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
            var options = {};
            options.coordinates = pointsString;
            options.subjoin = this.height;
            var finalResult = {
                height: this.height,
                inundatedArea: null,
                floodArea: null,
                floodVolume: null
            };
            this._getMeasureResult("floodAnalysis", options, OpenLayers.Function.bind(function(result){
                var arr = result.Result.Value.split(" ");
                finalResult.inundatedArea = arr[0];
                finalResult.floodArea = arr[1];
                finalResult.floodVolume = arr[2];
                this.onComplete(finalResult);
            }, this));
        }
        
        
        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
    /**
     * 在三维视图上画一个盒子图层
     * geometry - {Object}
     */
    _drawSolid: function(geometry){
        if (this.solid) {
            this._clearSolid();
        }
        this.solid = new Geo.View3D.Layer.Solid(this.id + "_solid", geometry, this.height, this.solidOptions);
        this.map.addLayer(this.solid);
    },
    
    /**
     * 清除盒子图层
     */
    _clearSolid: function(){
        if (this.solid && this.map) {
            this.map.removeLayer(this.solid);
        }
    },
    
    /**
     * APIMethod: deactivate
     * 取消激活控件并清除盒子图层
     * 
     * Returns:
     * {Boolean} true
     */
    deactivate: function(){
        if (Geo.View3D.Control.prototype.deactivate.apply(this, arguments)) {
            this._clearSolid();
        }
        return true;
    },
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Flood"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Flood"

});

/**
 * Class: Geo.View3D.Control.Measure.Profile
 * 量算出两个点的剖面地形分析结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Profile = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Path,
	
    /**
     * Constructor: Geo.View3D.Control.Measure.Profile
     * 构造函数。生成一个Geo.View3D.Control.Measure.Profile的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.serviceUrl = serviceUrl;
        this._terrainAnalysisService = new Geo.Service.TAS(this.id + "_service", serviceUrl);
        this.callbacks = OpenLayers.Util.extend({
            point: this._onAddPoint
        }, this.callbacks);
        this.handlerOptions = this.handlerOptions || {};
        if (this.handlerType) {
            this.handler = new this.handlerType(this, this.callbacks, this.handlerOptions);
        }
        
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
        var pointsString = this._points.join(",");
        
        var options = {};
        options.coordinates = pointsString;
        var finalResult = {
            heightArray: null
        };
        
		
		this.onComplete(finalResult);
//        this._getMeasureResult("profileAnalysis", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.heightArray = result.Result.Value;
//            this.onComplete(finalResult);
//        }, this));
        
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length == 2) {
            this._onComplete();
            this.handler.deactivate();
            this.handler.activate();
            return;
        }
        
    },
    
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Profile"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Profile"

});
/**
 * Class: Geo.View3D.Control.Measure.TwoPointThrough
 * 量算出两个点是否可见以及分析的结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.TwoPointThrough = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Path,
	
    /**
     * Constructor: Geo.View3D.Control.Measure.TwoPointThrough
     * 构造函数。生成一个Geo.View3D.Control.Measure.TwoPointThrough的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
        var pointsString = this._points.join(",");
        
        var options = {};
        options.coordinates = pointsString;
        var finalResult = {
            from: null,
            to: null,
            isVisible: null,
            firstUnseenHeight: null,
            heightArray: null
        };
        
		
		this.onComplete(finalResult);
//        this._getMeasureResult("profileAnalysis", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.heightArray = result.Result.Value;
//            finalResult.isVisible = this.getVisible(finalResult.heightArray).isVisible;
//            finalResult.firstUnseenHeight = this.getVisible(finalResult.heightArray).firstUnseenHeight;
//            this.onComplete(finalResult);
//        }, this));
        
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length == 2) {
            this._onComplete();
            this.handler.deactivate();
            this.handler.activate();
            return;
        }
        
    },
	
    /**
     * APIMethod: getVisible
     * 得到是否可见的结果
     *
     * Paramters:
     * arrayString - {String} 一些高度的字符串
     */
    getVisible: function(arrayString){
        var array = arrayString.split(" ");
        var length = array.length;
        var isVisible = true;
        // 第一个障碍点高程值
        var firstUnseenHeight = null;
        for (var i = 0; i < length; i++) {
        
            //起点和终点之间的高度差
            var num1 = array[length - 1] - array[0];
            //高度差分成点总数的段数
            var num2 = num1 / (length - 1);
            //每段乘以第i个点，得到第i个点的高度
            var num3 = num2 * i;
            //第i个点的高度加上第一个点的高度
            var lineY = Number(array[0]) + num3;
            
            //判断第二个点至倒数第二个点是否有障碍点
            if (i > 0 && i < (length - 1) && isVisible && array[i] >= lineY) {
                isVisible = false;
                // 第一个障碍点高程值
                firstUnseenHeight = lineY;
            }
        }
        //     alert("firstUnseenPoint:" + firstUnseenPoint);
        var result = {
            firstUnseenHeight: firstUnseenHeight,
            isVisible: isVisible
        };
        return result;
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.TwoPointThrough"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.TwoPointThrough"

});

/**
 * Class: Geo.View3D.Control.ModelChoose
 * 三维视图模型选择控件类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.ModelChoose = Geo.Class(Geo.View3D.Control, {
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: {},
	
    /**
     * Constructor: Geo.View3D.Control.ModelChoose
     * Geo.View3D.Control.ModelChoose构造函数。
     */
    initialize: function(options) {
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "chooseModel": this.chooseModel
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.ModelChoose(this,
                            this.callbacks, this.handlerOptions);
    },	
	
	chooseModel: function(mouseEvent, isSelected) {
		
	},
	
	CLASS_NAME: "Geo.View3D.Control.ModelChoose"
});/**
 * Class: Geo.View3D.Control.DrawBox
 * 屏幕元素绘制控件类。使用本控件可以在三维地图上创建纹理源模块、创建屏幕元素模块、创建贴地立体元素模块、创建特效元素模块、元素管理模块。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawBox = Geo.Class(Geo.View3D.Control, {

 	/**
	 * Constructor: Geo.View3D.Control.DrawBox
	 * Geo.View3D.Control.DrawBox构造函数。
	 */   
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
    },
	
	/**
	 * APIMethod: createScreenPictureElement
	 * 创建屏幕图片元素
	 * 
	 * Paramters:
	 * x - {Number} 元素定位点的左侧X坐标，单位像素
	 * y - {Number} 元素定位点的上侧Y坐标，单位像素
	 * varImg - {String} 图片地址
	 * nWidth - {Number} 元素的宽度，单位像素
	 * nHeight - {Number} 元素的高度，单位像素
	 * 
	 * Returns:
     * {Object} IScreenPictureElement3D*类型。
	 */
	createScreenPictureElement: function(x, y, varImg, nWidth, nHeitht){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var pictureTextureSource = this.createPictureTextureSource(varImg);
				return globe.ElementBox.CreateScreenPictureElement(x, y, pictureTextureSource, nWidth, nHeitht);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createTextElement
	 * 创建屏幕文本元素
	 * 
	 * Paramters:
	 * x - {Number} 元素定位点的左侧X坐标，单位像素
	 * y - {Number} 元素定位点的上侧Y坐标，单位像素
	 * bstrtext - {String} 元素文本内容
	 * nWidth - {Number} 元素的宽度，单位像素
	 * nHeight - {Number} 元素的高度，单位像素
	 * fontName - {String}  字体
	 * nFontSize - {Number} 字号
	 * nFontColor - {String} 字体颜色
	 * 
	 * Returns:
     * {Object} ITextElement3D*类型。
	 */
	createTextElement: function(x, y, bstrtext, nWidth, nHeight, fontName,  nFontSize, nFontColor){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateTextElement(x, y, bstrtext, nWidth, nHeight);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createButtonWidgetElement
	 * 创建屏幕按钮元素
	 * 
	 * Paramters:
	 * x - {Number} 元素定位点的左侧X坐标，单位像素
	 * y - {Number} 元素定位点的上侧Y坐标，单位像素
	 * varImage - {String} 元素的显示图片
	 * varPressImage - {String} 点击时元素图片
	 * varHoverImage - {String} 在元素上停留时图片
	 * nWidth - {Number}  图片的宽度，单位像素
	 * nHeight - {Number} 图片的高度，单位像素
	 * 
	 * Returns:
     * {Object} IButtonWidgetElement*类型。
	 */
	createButtonWidgetElement: function(x, y, varImage, varPressImage, varHoverImage, nWidth, nHeight){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var varImage = this.createPictureTextureSource(varImage);
				var varPressImage = this.createPictureTextureSource(varPressImage);
				var varHoverImage = this.createPictureTextureSource(varHoverImage);
				return globe.ElementBox.CreateButtonWidgetElement(x, y, varImage, varPressImage, varHoverImage, nWidth, nHeight);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createScreenGeometryElement
	 * 创建屏幕几何元素
	 * 
	 * Paramters:
	 * varCoord - {String} 线的点坐标数组,支持WKT字符串
	 * nColor - {String} 线的颜色
	 * nWidth - {Number} 线的宽度，单位像素
	 * bPattern - {Boolean} 是否使用虚线
	 * fPatternScale - {Number} 虚线间隔
	 * 
	 *  Returns:
     * {Object} IScreenGeometryElement*类型。
	 */
	createScreenGeometryElement: function(varCoord, nColor, nWidth, bPattern, fPatternScale){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateScreenGeometryElement(varCoord, nColor, nWidth, bPattern, fPatternScale);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createBillBoardElement3D
	 * 创建广告片元素
	 * 
	 * Paramters:
	 * lon - {Number} 经度
	 * lat - {Number} 纬度
	 * alt - {Number} 高程，单位米
	 * varImg - {String} 显示图片
	 * 
	 *  Returns:
     * {Object} IBillboardElement3D*类型。
	 */
	createBillBoardElement3D: function(lon, lat, alt, varImg){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var pictureTextureSource = this.createPictureTextureSource(varImg);
				return globe.ElementBox.CreateBillBoardElement3D(lon, lat, alt, pictureTextureSource);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createPOIElement3D
	 * 创建POI元素
	 * 
	 * Paramters:
	 * lon - {Number} 经度
	 * lat - {Number} 纬度
	 * alt - {Number} 高程，单位米
	 * eTexPos - {String} 显示方式
	 * bstrCaption - {String} 文本
	 * varIcon - {String} 图标
	 * bstrFontName - {String} 字体名称
	 * nFontSize - {Number} 字号
	 * nFontColor - {String} 字体颜色
	 * 
	 * Returns:
	 * {Object} IPOIElement3D*类型。
	 */
	createPOIElement3D: function(lon, lat, alt, eTexPos, bstrCaption, varIcon, bstrFontName, nFontSize, nFontColor){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreatePOIElement3D(lon, lat, alt, eTexPos, bstrCaption, varIcon);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createGeoPictureElement3D
	 * 创建贴地图片元素
	 * 
	 * Paramters:
	 * minX - {Number} 球面最小经度坐标
	 * minY - {Number} 球面最小纬度坐标 
	 * maxX - {Number} 球面最大经度坐标
	 * maxY - {Number} 球面最大纬度坐标
	 * varImage - {String} 图片
	 * 
	 * Returns:
	 * {Object} IGeoPictureElement3D*类型。
	 */
	createGeoPictureElement3D: function(minX, minY, maxX, maxY, varImage){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var pictureTextureSource = this.createPictureTextureSource(varImage);
				return globe.ElementBox.CreateGeoPictureElement3D(minX, minY, maxX, maxY, pictureTextureSource);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createMeshElement3D
	 * 创建球面立体元素
	 * 
	 * Paramters:
	 * lon - {Number} 元素的定位点lon坐标，经度
	 * lat - {Number} 元素的定位点lat坐标，纬度
	 * alt - {Number} 元素的定位点alt坐标，高程，单位米
	 * varMesh - {Object} 立体几何对象
	 * varMaterial - {Object} 材质对象
	 * varTextureSource - {Object} 纹理
	 * 
	 * Returns:
	 * {Object} IMeshElement3D*类型。
	 */
	createMeshElement3D: function(lon, lat, alt, varMesh, varMaterial, varTextureSource){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateMeshElement3D(lon, lat, alt, varMesh, varMaterial, varTextureSource);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createMaterial3D
	 * 创建3D材质
	 * 
	 * Paramters:
	 * nAmbient - {Number} 环境光，值域0-0xffffffff
	 * nDiffuse - {Number} 漫反射光，值域0-0xffffffff
	 * nSpecular - {Number} 镜面反射光，值域0-0xffffffff
	 * nEmissive - {Number} 自发光，值域0-0xffffffff
	 * fPower - {Number} 镜面高光
	 * 
	 * Returns:
	 * {Object} IMaterial3D*类型。
	 */
	createMaterial3D: function(nAmbient, nDiffuse, nSpecular, nEmissive, fPower){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateMaterial3D(nAmbient, nDiffuse, nSpecular, nEmissive, fPower);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createPictureTextureSource
	 * 创建图片纹理源
	 * 
	 * Paramters:
	 * varData - {Number} 指定了图片的来源，支持url、字符串路径、图片字节流；
	 * 
	 * Returns:
	 * {Object} IPictureTextureSource*类型。
	 */
	createPictureTextureSource: function(varData){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var ptex = globe.ElementBox.CreatePictureTextureSource(varData);
				return ptex;
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createCuboidMesh
	 * 创建长方体
	 * 
	 * Paramters:
	 * dblLength - {Number} 长，单位米
	 * dblBreadth - {Number} 宽，单位米
	 * dblHeight - {Number} 高，单位米
	 * etxtStyle - {Number} 纹理贴图类型
	 * 
	 * Returns:
	 * {Object} IMesh3D*类型。
	 */
	createCuboidMesh: function(dblLength, dblBreadth, dblHeight, etxtStyle){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var pCuboid = globe.ElementBox.CreateCuboidMesh(dblLength, dblBreadth, dblHeight, etxtStyle);
				return pCuboid;
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createFireElement3D
	 * 创建特效火元素
	 * 
	 * Paramters:
	 * lon - {Number} 元素的定位点lon坐标，经度
	 * lat - {Number} 元素的定位点lat坐标，纬度
	 * alt - {Number} 元素的定位点alt坐标，高程，单位米
	 * ePowerLevel - {Number} 火焰火力等级，2-最高等级 1-中等等级 0-最低等级 
	 * dblRadius - {Number} 火焰半径，单位米
	 * nColor - {Number} 火焰颜色，没有A通道，只有RGB
	 * 
	 * Returns:
	 * {Object} IFireElement3D*类型。
	 */
	createFireElement3D: function(lon, lat, alt, ePowerLevel, dblRadius, nColor){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateFireElement3D(lon, lat, alt, ePowerLevel, dblRadius, nColor);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createSmokeElement3D
	 * 创建特效烟元素
	 * 
	 * Paramters:
	 * lon - {Number} 元素的定位点lon坐标，经度
	 * lat - {Number} 元素的定位点lat坐标，纬度
	 * alt - {Number} 元素的定位点alt坐标，高程，单位米
	 * eDensity - {Number} 烟浓度，大、中、小三个值，10-最大密度 5-中等密度 1-最低密度
	 * dblRadius - {Number} 烟的半径，单位米
	 * nColor - {Number} 烟的颜色,没有A通道，只有RGB
	 * 
	 * Returns:
	 * {Object} ISmokeElement3D*类型。
	 */
	createSmokeElement3D: function(lon, lat, alt, eDensity, dblRadius, nColor){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateSmokeElement3D(lon, lat, alt, eDensity, dblRadius, nColor);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createSpringElement3D
	 * 创建特效水柱或喷泉元素
	 * 
	 * Paramters:
	 * lon - {Number} 元素的定位点lon坐标，经度
	 * lat - {Number} 元素的定位点lat坐标，纬度
	 * alt - {Number} 元素的定位点alt坐标，高程，单位米
	 * dblHeading - {Number} 水柱喷射的方位角
	 * dblTilt - {Number} 水柱喷射的俯仰角
	 * dblRadius - {Number} 水柱的粗细
	 * dblMinDistance - {Number} 水柱喷射的最近距离，单位米
	 * dblMaxDistance - {Number} 水柱喷射的最大距离，单位米
	 * 
	 * Returns:
	 * {Object} ISpringElement3D*类型。
	 */
	createSpringElement3D: function(lon, lat, alt, dblHeading, dblTilt, dblRadius, dblMinDistance, dblMaxDistance){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateSpringElement3D(lon, lat, alt, dblHeading, dblTilt, dblRadius, dblMinDistance, dblMaxDistance);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createRainElement3D
	 * 创建特效雨元素
	 * 
	 * Paramters:
	 * lon - {Number} 元素的定位点lon坐标，经度
	 * lat - {Number} 元素的定位点lat坐标，纬度
	 * alt - {Number} 元素的定位点alt坐标，高程，单位米
	 * dblLength - {Number} 范围的长，单位米
	 * dblWidth - {Number} 范围的宽，单位米
	 * eDensity - {Number} 雨的等级
	 * 
	 * Returns:
	 * {Object} IRainElement3D*类型。
	 */
	createRainElement3D: function(lon, lat, alt, dblLength, dblWidth, eDensity){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateRainElement3D(lon, lat, alt, dblLength, dblWidth, eDensity);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: setSkyBoxVisible
	 * 设置天空盒显示和隐藏状态
	 * 
	 * Paramters:
	 * visible - {Boolean} 是否显示
	 */
	setSkyBoxVisible: function(visible){
		var globe = this.map.activexObj;
		if (globe) {
			globe.ScreenBox.ChangeScreenElementVisible(2, !visible);
			globe.ElementBox.SkyBox.Visible = visible;
		}
	},     
	
	/**
	 * APIMethod: setSunVisible
	 * 设置光晕显示和隐藏状态
	 * 
	 * Paramters:
	 * visible - {Boolean} 是否显示
	 */
	setSunVisible: function(visible){
		var globe = this.map.activexObj;
		if (globe) {
			globe.ConfigBox.SaveConfigItem(22, visible); 
			if(!visible) globe.Camera.CameraMode = 1;
			globe.ElementBox.Sun.Visible = visible;
		}
	}, 
	
	/**
	 * APIMethod: removeBoxs
	 * 删除全部元素
	 * 
	 */
	removeBoxs: function(){
		var globe = map.activexObj;
		if (globe) {
			var elementBox = globe.ElementBox;
			var count = elementBox.ElementCount;
//			for (var i = 0; i < count; i++) {
//				elementBox.RemoveElementAt(i);
//			}
			for (var i = count - 1; i >= 0; i--)
            {
                elementBox.RemoveElementAt(i);
            }
		}
	},
	
	CLASS_NAME: "Geo.View3D.Control.DrawBox"
});
/**
 * Class: Geo.CombineView
 * 地图视图类(复合视图),封装了二三维视图。
 * 
 * 复合视图是将二维地图和三维地图整合到一起，为用户提供不同的地理信息数据视图方式，
 * 并且可以方便的在两种视图方式之间切换、同步。具体实现过程是分别构造二维和三维两个
 * 地图对象，将两者同时放置在一个 div元素中，同一时间只显示一个地图对象，在切换到另
 * 一个地图对象时隐藏前一个，并将中心点位置和当前级别进行同步。用户可以分别对二、三
 * 维地图对象独立控制，比如进行相关控件、图层对象添加，属性的更改等操作。
 */
Geo.CombineView = Geo.Class({
	
	/**
     * APIProperty: id
     * {String} id号，视图中地图的唯一标识。
     */
    id: null,
    
 	/**
     * APIProperty: div
     * {DOMElement|String} 视图所在容器。
     */
    div: null,
    
  	/**
     * APIProperty: map2D
     * {<Geo.View2D.Map>} 二维地图对象,为与三维保持一致,二维视图对象只能为360金字塔。
     */
    map2D: null,
    
  	/**
     * APIProperty: map2DOptions
     * {Object} 可选二维地图初始化参数。
     */
    map2DOptions: null,
    
  	/**
     * APIProperty: map3D
     * {<Geo.View3D.Map>} 三维地图对象。
     */
    map3D: null,
    
   	/**
     * APIProperty: map3DOptions
     * {Object} 可选三维地图初始化参数。
     */
    map3DOptions: null,
	
	/**
     * Property: mapFlash
     * {<Geo.ViewFl.Map>} flash地图对象。
     */
	mapFlash: null,
	
	/**
     * Property: mapFlashOptions
     * {Object} flash地图构造参数。
     */
	mapFlashOptions: null,
    
   	/**
     * APIProperty: currentView
     * {Object} 当前视图。
     */
    currentView: null,
    
   	/**
     * APIProperty: viewList
     * {Object} 支持的视图列表及相关映射。
     */
    viewList: null,
    
   	/**
     * APIProperty: defaultView
     * {String} 缺省视图。可选：“2D”、“3D”，默认值为“2D”（即默认为二维视图）。
     */
    defaultView: "2D",
	
   	/**
     * APIProperty: defaultLayout
     * {String | <Geo.CombineView.layoutList>} 缺省布局。默认值为“single”。
     */
	defaultLayout: "single",
	
   	/**
     * APIProperty: currentLayout
     * {String} 当前布局。
     */
	currentLayout: null,
	
   	/**
     * APIProperty: center
     * {<Geo.LonLat>} 当前中心点。
     */
	center: null,
	
   	/**
     * APIProperty: zoom
     * {Integer} 当前级别。
     */
	zoom: null,
	
   	/**
     * APIProperty: ayncType
     * {Boolean} 视图同步方式"all","center","layers"。
     */
	ayncType: "all",
	
   	/**
     * APIProperty: layoutList
     * {Array} 支持的布局。
     */
	layoutList: ["single","vertical","horizontal"],
    
   	/**
     * APIProperty: EVENT_TYPES
     * {Array} 事件类型。
     */
    EVENT_TYPES: ["viewswitch", "addlayer", "loadlayergroup"],
    
   	/**
     * APIProperty: events
     * 复合视图对象的事件。
     */
    events: null,
    
   	/**
     * APIProperty: eventListeners
     * 复合视图对象的事件监听器。
     */
    eventListeners: null,
    
    /**
     * Constructor: Geo.CombineView
     * 构造函数。生成一个二三维复合视图对象实例。
     * 
     * Parameters:
     * div - {String} 指定地图对象将被渲染到哪个div 元素中。
     * options - {Object} 地图对象相关选项设置。
     */
	initialize: function(div, options){
        this.id = OpenLayers.Util.createUniqueID("Geo.CombineView_");
        this.div = OpenLayers.Util.getElement(div);
        
        this.viewList = {
            "2D": {
                title: "二维视图",
                getMapObj: OpenLayers.Function.bind(function(){
                    return this.map2D;
                }, this),
                initFn: OpenLayers.Function.bind(this.initMap2D, this),
                getInitOptions: OpenLayers.Function.bind(function(){
                    return this.map2DOptions;
                }, this)
            },
            "3D": {
                title: "三维视图",
                getMapObj: OpenLayers.Function.bind(function(){
                    return this.map3D;
                }, this),
                initFn: OpenLayers.Function.bind(this.initMap3D, this),
                getInitOptions: OpenLayers.Function.bind(function(){
                    return this.map3DOptions;
                }, this)
            },
			"flash": {
				title: "flash视图",
				getMapObj: OpenLayers.Function.bind(function(){
                    return this.mapFlash;
                }, this),
				initFn: OpenLayers.Function.bind(this.initMapFlash, this),
				getInitOptions: OpenLayers.Function.bind(function(){
                    return this.mapFlashOptions;
                }, this)
			}
        };
        OpenLayers.Util.extend(this, options);
		this.initLayout();
		
        //初始化缺省视图
        this.currentView = this.defaultView;
        var initFn = this.viewList[this.currentView].initFn;
        var initOptions = this.viewList[this.currentView].getInitOptions();
        initFn(initOptions);
        
        this.events = new OpenLayers.Events(this, this.div, this.EVENT_TYPES, this.fallThrough, {
            includeXY: true
        });
        if (this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
        

    },
    
    /**
     * APIMethod: initMap2D
     * 初始化二维地图对象。
     * 
     * Parameters:
     * options - {Object} 地图对象相关选项设置。
     * 
     * Returns
     * {Boolean} true为初始化成功。
     */
	initMap2D: function(options){
        if (!this.map2D) {
            var map2DDiv = document.createElement("div");
            map2DDiv.style.height = "100%";
            map2DDiv.style.width = "100%";
            map2DDiv.id = this.id + "_map2D";
            this.div.appendChild(map2DDiv);
            this.map2D = new Geo.View2D.Map(map2DDiv, options);
			
			this.map2D.events.on({
	            "move": function(){
					this.center = this.map2D.getCenter();
					this.zoom = this.map2D.getZoom();
				},
	            scope: this
	        });

            //this.map2D.setCenter(0,0);
        }
        return true;
    },
    
    /**
     * APIMethod: initMap3D
     * 初始化三维地图对象。
     * 
     * Parameters:
     * options - {Object} 地图对象相关选项设置。
     * 
     * Returns
     * {Boolean} true为初始化成功。
     */
    initMap3D: function(options){
        if (!this.map3D) {
            var map3DDiv = document.createElement("div");
            map3DDiv.style.height = "100%";
            map3DDiv.style.width = "100%";
            map3DDiv.id = this.id + "_map3D";
            this.div.appendChild(map3DDiv);
            this.map3D = new Geo.View3D.Map(map3DDiv, options);
        }
        return true;
    },
	
	/**
     * APIMethod: initMapFlash
     * 初始化三维地图对象。
     * 
     * Parameters:
     * options - {Object} 地图对象相关选项设置。
     * 
     * Returns
     * {Boolean} true为初始化成功。
     */
    initMapFlash: function(options){
        if (!this.mapFlash) {
            var mapFlashDiv = document.createElement("div");
            mapFlashDiv.style.height = "100%";
            mapFlashDiv.style.width = "100%";
            mapFlashDiv.id = this.id + "_mapFlash";
            this.div.appendChild(mapFlashDiv);
            this.mapFlash = new Geo.ViewFl.Map(mapFlashDiv, options);
        }
        return true;
    },
	
	//初始化布局
	initLayout:function(){
		
	},
	
    /**
     * APIMethod: switchView
     * 切换视图。
     * 
     * Parameters:
     * view - 要切换到的视图。
     */
	switchView: function(view){
        if (view == this.currentView) {
            return;
        }
        
        //未指视图或视图名字未找到，则切换到下一视图
        if (!view || !this.viewList[view]) {
            view = this.getNextView(this.currentView);
        };
		
		//如果将切换的视图未初始化，则初始化
        if (!this.viewList[view].mapObj) {
            this.viewList[view].initFn();
        };
        var currMapObj = this.viewList[this.currentView].getMapObj();
        currMapObj.div.style.display = "none";
        var mapObj = this.viewList[view].getMapObj();
		//设置三维组件线程启用
		if(view == "3D"){
			mapObj.activexObj.Suspend = false;
		}else {
			//设置三维组件线程关闭
			currMapObj.activexObj.Suspend = true;
		}
        mapObj.div.style.display = "";
        this.syncView();
        this.currentView = view;
        this.events.triggerEvent("viewswitch", {
            view: view
        });
    },
	
     /**
     * APIMethod: zoomIn
     * 视图放大。
     */
	zoomIn: function(){
		var map = this.getCurrentMapObj();
		map.zoomIn();
	},
	
     /**
     * APIMethod: zoomOut
     * 视图缩小。
     */
	zoomOut: function(){
		var map = this.getCurrentMapObj();
		map.zoomOut();
	},
	
	/**
	 * APIMethod: setCenter
	 * 对视图进行中心定位，并放大到指定级别。
	 * 
	 * Parameters:
	 * center - {<Geo.LonLat>} 中心点的坐标。
	 * level - {Int}要放大的级别。
	 */
	setCenter: function(center, level){
		this.center = center;
		this.zoom = level;
		var map = this.getCurrentMapObj();
		map.setCenter(center, level);	
	},
	
   /**
    * APIMethod: addLayer
    * 添加图层。
    *
    * Parameters:
    * layer - {<OpenLayers.Layer>} 
    */	
	addLayer: function(layer){
		var map = this.getCurrentMapObj();
		map.addLayer(layer);
	},
	
	/**
	 * APIMethod: addLayers
	 * 添加多个图层。
	 * 
     * Parameters:
	 * layers - {Array(<OpenLayers.Layer>)} 
	 */
	addLayers: function(layers){
		if(!(Geo.Util.isArray(layers))){
			layers = [layers];
		}
		for(var i=0; i<layers.length; i++){
			this.addLayer(layers[i]);
		}
	},

	/**
	 * APIMethod: loadLayerGroup
	 * 加载图层组。
	 * 
     * Parameters:
	 * layerGroup - {<Geo.View2D.LayerGroup>|Geo.View3D.LayerGroup} 
	 */
	loadLayerGroup:function(layerGroup){
		var map = this.getCurrentMapObj();
		map.loadLayerGroup(layerGroup);
	},

	/**
	 * APIMethod: unloadLayerGroup
	 * 卸载图层组。
	 */
	unloadLayerGroup: function(){
        var map = this.getCurrentMapObj();
		map.unloadLayerGroup();
    },
    	
	/**
	 * APIMethod: getCurrentMapObj
	 * 获取当前地图对象。
	 * 
	 * Return:
	 * {<Geo.View2D.Map>|<Geo.View3D.Map>} 当前地图对象的引用。
	 */
	getCurrentMapObj:function(){
		var view = this.currentView;
		var list = this.viewList;
		
		var map = list[view].getMapObj();
		if(!map){
			return null;
		}
		return map;
	},
	
	/**
	 * APIMethod: syncView
	 * 同步视图。
	 */
	syncView: function(){
		var list = this.viewList;
		var currentView = this.currentView;
		var currentMap = list[currentView].getMapObj();
		
		
		for(var item in list){
			if(currentView == item){
				continue;
			}
			var targetMap = list[item].getMapObj();
			if(!targetMap){
				return;
			}
			var currentRes = currentMap.getResolution();
            var targetZoom = targetMap.getZoomForResolution(currentRes);
            var targetCenter = currentMap.getCenter();
            targetMap.setCenter(targetCenter, targetZoom);
		}
	},

    	
	/**
	 * APIMethod: getNextView
	 * 获取下一个视图名称,用于循环切换视图。
	 * 
	 * Parameters:
	 * view - 指定的视图。
	 * 
	 * Returns:
	 * {Object} 当前视图。
	 */	
	getNextView:function(view){

		var firstView = null;
		var nextView = null;
		var isFisrt = true;
		var isNext = false;
		for(var item in this.viewList){
			if(isFisrt){
				firstView = item;
				isFisrt = false;
			}

			if (isNext){
				nextView = item;
				break;
			}
			
			if(item === view){
				isNext = true;
				continue;
			}
		}
		//如果下一视图为空,说明两种情况一是没有指定视图,
		//二是指定视图为最后一个视图,均返回第一个视图.
		if(!nextView){
			return firstView;
		}
		return nextView;
	},
	
    CLASS_NAME: "Geo.CombineView"
});

/**
 * Class: Geo.LayerManager
 * 图层管理器类，提供同时对二维、三维视图的图层操作相关功能,包括图层的添加，删除，图层的透明度设置，上移下移，定位等功能。
 */
Geo.LayerManager = Geo.Class({

    /**
     * APIProperty: map
     * {<Geo.View2D.Map>|<Geo.View3D.Map>|<Geo.CombineView>}关联的地图对象。 
     */
	map:null,
	
    /**
     * APIProperty: autoUpdateList
     * {Boolean} 是否自动触发更新图层列表方法updateLayerList，默认为"true"。 
     */
	autoUpdateList: true,
	
    /**
     * APIProperty: isAllLayers
     * {Boolean} 是否管理全部图层，默认为否，在使用getLayers方法获取地图对象所有图层时，
     * 图层属性displayInLayerSwitcher为false的图层对象将不在返回值的数组中。 
     */
	isAllLayers: false,
	
	 /**
     * APIProperty: template
     * {Object} 图层列表模板，json格式，是否自动触发更新图层列表方法updateLayerList，默认为"true"。 
     */
	template: {
		//外部容器
		wrapper: "<ul>${layerItemTemplate}</ul>",
		
		//图层列表表现模板
		item: "<li><input type='checkbox' ${visibility} " + 
			  "onchange='lm.toggleLayerVisibility(${layerid})' />${layerName}</li>" +
			  "",
	
		//无图层提示
		noLayer: "<li>当前没有图层</li>"
	},
	
	
    /**
     * APIProperty: ascending
     * 图层排列顺序。默认为“true”，表示按升序排序；当取值为“false”表示按降序排列。 
     */
	ascending: true,
	
	/**
	 * Constructor: Geo.LayerManager
	 * 构造方法。
	 * 
	 * Parameters:
	 * options - {Object} 可选的实例属性设置对象。
	 */
	initialize:function(options){
		OpenLayers.Util.extend(this,options);
	},
	
	/**
	 * Method: setMap
	 * 关联地图对象。
	 * 
	 * Parameters:
	 * map - {<Geo.View2D.Map>|<Geo.View3D.Map>|<Geo.CombineView>} 要关联的地图对象。
	 */
	setMap:function(map){
		this.map = map;
		this._updateLayerList();
	},

	/**
	 * APIMethod: getCurrentMapObj
	 * 获取当前地图对象。
	 * 
	 * Return:
	 * map - {<Geo.View2D.Map>|<Geo.View3D.Map>|<Geo.CombineView>} 要关联的地图对象。
	 */	
	getCurrentMapObj:function(){
		var map = this.map;
		if(map.CLASS_NAME == "Geo.CombineView"){
			map = map.getCurrentMapObj();
		}
		return map;
	},

	/**
	 * APIMethod: updateLayerList
	 * 更新图层列表回调函数，可以由用户自定义覆盖。
	 * 
	 * layers - {Array(<Openlayers.Layer>|<Geo.View3D.Layer>)} 当前地图中加载的图层对象。
	 */		
	updateLayerList:function(layers){
	},
	
	//获取当前地图中的图层对象，调用更新图层方法。
	_updateLayerList: function(){
		var layers = this.getLayers();
		if (this.map && this.autoUpdateList) {
			this.updateLayerList(layers);
		}
	},
	
	/**
	 * APIMethod: getLayers
	 * 获取当前地图对象中所有加载的图层。如果isAllLayers属性设置false，
	 * 则只获取那些图层属性displayInLayerSwitcher为false图层。
	 * 
	 * Return:
	 * {Array(<Openlayers.Layer>|<Geo.View3D.Layer>)} 图层数组。
	 */
	getLayers:function(){
		var layers = [];
		var map = this.getCurrentMapObj();
		
		//不存在地图,返回空图层数组
		if(!map){
			return layers;
		}
		
		//如果未设置全部图层,则只获在图层管理器里显示的图层
		var allLayers = map.layers;
		if(!this.isAllLayers){			
			for(var i = 0; i<allLayers.length; i++){
				var layer = allLayers[i];
				if(layer.displayInLayerSwitcher){
					layers.push(layer);
				}
			}			
		}
		if (!this.ascending) { layers.reverse(); }
		return layers;
	},
	
	/**
	 * APIMethod: setOpacity
	 * 设置图层透明度。
	 * 
	 * Parameters:
	 * layerid - 图层的标识。
	 * opacity - {Float} 透明度值。
	 */
	setOpacity: function(layerid, opacity){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if (layer) {
            layer.setOpacity(opacity);
        }
		this._updateLayerList();
    },
	
	/**
	 * APIMethod: raisLayer
	 * 上移,下移图层。通过指定增量值更改指定图层的索引。当指定增量值为正时图层上移，当指定增量值为负时图层下移。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 * delta - 指定的增量值，决定图层的移动方式。
	 */
	raisLayer: function(layerid, delta){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if (layer) {
            map.raiseLayer(layer, delta);
        }
		this._updateLayerList();
    },
	
	/**
	 * APIMethod: raisLayerToTop
	 * 将指定图层移动到顶层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 */
	raisLayerToTop:function(layerid){
		var map = this.getCurrentMapObj();
		var layer = map.getLayer(layerid);
        if (layer) {
            var layers = map.layers;
			var index = OpenLayers.Util.indexOf(layers,layer);
			var delta = layers.length - index;
			this.raisLayer(layerid,delta);
        }
	},
	
	/**
	 * APIMethod: raisLayerToBottom
	 * 将指定图层移动到底层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 */
	raisLayerToBottom: function(layerid){
		var map = this.getCurrentMapObj();
		var layer = map.getLayer(layerid);
        if (layer) {
			var layers = map.layers;
			var index = OpenLayers.Util.indexOf(layers,layer);
			var delta = 0 - index;
			this.raisLayer(layerid,delta)
        }
	},
	
	/**
	 * APIMethod: toggleLayerVisibility
	 * 切换图层可视性。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 * isUpdateLayerList - 是否自动更新图层列表。
	 */
	toggleLayerVisibility: function(layerid, isUpdateLayerList){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        layer.setVisibility(!layer.getVisibility());
//		this._updateLayerList();
    },
	
	/**
	 * APIMethod: gotoLayer
	 * 将地图视图定位到指定图层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 */
	gotoLayer: function(layerid){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if(layer.gotoCenter){
            layer.gotoCenter();
            return;
        }
        var extent, zoom;
		if(layer instanceof Geo.View2D.Layer.WMTS) {
			extent = layer.tileFullExtent;
		}else if(layer instanceof OpenLayers.Layer.Vector) {
			extent = layer.getDataExtent();
			extent = extent ? extent : (layer.maxExtent ? layer.maxExtent : map.maxExtent);
			map.zoomToExtent(extent);
			return;
		}else if(layer instanceof Geo.View2D.Layer.WMS) {
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
			map.zoomToExtent(extent);
			return;
		}else if(layer instanceof Geo.View2D.Layer.DynamicMapService) {
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
			map.zoomToExtent(extent);
			return;
		}else if(layer instanceof Geo.View2D.Layer.TileMapService) {
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
			map.zoomToExtent(extent);
			return;
		}else{
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
		}
        //判断当前地图是否是flex，如果是flex，从layer中获取extent和maxRes的值。
        var maxRes
        var currentView = this.getCurrentMapObj().CLASS_NAME;
		if(currentView == "Geo.ViewFl.Map"){
			extent = layer.maxExtent ? layer.maxExtent : layer.getExtent();
			maxRes = layer.getResolution();
		}else {
        	maxRes = layer.maxResolution ? layer.maxResolution : map.maxResolution;
		}
        zoom = map.getZoomForResolution(maxRes,true);
        map.setCenter(extent.getCenterLonLat(), zoom);
    },
	
	/**
	 * APIMethod: removeLayer
	 * 移除指定的图层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 * isUpdateLayerList - 是否自动更新图层列表。
	 */
	removeLayer:function(layerid, isUpdateLayerList){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if (layer) {
            map.removeLayer(layer);
        }
		this._updateLayerList();
	},
	
	/**
	 * APIMethod: addLayer
	 * 加载图层。
	 * 
	 * Parameters:
	 * type - {String} 图层类型。
	 * allOptions - 属性设置项对象。
	 * 
	 * Returns:
	 * {Boolean} 添加成功返回true，反之返回false。
	 */
	addLayer: function(type, allOptions){
		var map = this.getCurrentMapObj();
        var view = map.CLASS_NAME;
		type = type.toUpperCase();
		var layerObj = Geo.LayerManager.supportService[view][type];
		var layer = null;
		if(layerObj){
			layer = layerObj(allOptions);
			map.addOverLayer(layer);
			this._updateLayerList();
			return true;
		}
		return false;
	},
	
	CLASS_NAME: "Geo.LayerManager"
});

/**
 * APIProperty: Geo.LayerManager.supportService
 * {Object} Geo.LayerManager对图层类型的支持。
 */
Geo.LayerManager.supportService = {
    "Geo.View2D.Map": {
        "OGC_WMS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var params = allOptions.params;
            var options = allOptions.options;
            var isSeparate = allOptions.isSeparate;
            var layersStr = allOptions.params.layers
            
            //分开加载各个图层
            if (isSeparate) {
                var arrLayersStr = layersStr.split(",");
                var arrLayer = [];
                for (var i = 0, l = arrLayers.length; i < l; i++) {
                    OpenLayers.Util.extend(params, {
                        layers: arrLayers[i]
                    });
                    arrLayer.push(new OpenLayers.Layer.WMS(name, url, params, options));
                }
                return arrLayer;
            }
            
            return new OpenLayers.Layer.WMS(name, url, params, options);
        },
        "GEO_TILE": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View2D.Layer.GlobeTile(name, url, options);
        },
        "OGC_WMTS": function(allOptions){
            return new OpenLayers.Layer.WMTS(allOptions);
        },
		"GEO_CWMS": function(allOptions){
			var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View2D.Layer.CWMS(name, url, options);
        },
		"ARCGIS_REST": function(allOptions){
			var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View2D.Layer.ArcGIS93Rest(name, url, options);
        },
		"OGC_WFS": function(allOptions){
			var name = allOptions.name;
            var url = allOptions.url;
			var version = allOptions.version;
            var options = allOptions.options;
			
			
            var strategies = [];
            // 如果IsViewPort为true，则根据可视范围来查询
        //  if (options.isViewPort == "true") {
            	strategies.push(new OpenLayers.Strategy.BBOX());
       //   }
            
            // 如果有关键字，则在策略中加入一个过滤器。
            if (options.keyWord) {
                var filter = new Geo.Filter.Comparison({
                    type: Geo.Filter.Comparison.LIKE,//关系运算
                    property: options.featurePropertyName,//查询字段
                    value: "/*" + options.keyWord + "/*"// 值
                });
                var strategyFilter = new OpenLayers.Strategy.Filter({
                    filter: filter
                });
                strategies.push(strategyFilter);
            }
            var wfsLayer = new Geo.View2D.Layer.Vector(name, {
                //使用bbox查询策略
                strategies: strategies,
                //使用WFS协议方法
                protocol: new OpenLayers.Protocol.WFS({
                    maxFeatures: options.maxFeatures,//现在服务返回的结果数
                    geometryName: options.geometry,
                    url: url,
					version:version,
                    featureType: options.featureType//要素类型
                })
            });
            return wfsLayer;
        }
    },
    "Geo.View3D.Map": {
        "OGC_WMS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var params = allOptions.params;
            var options = allOptions.options;
            var isSeparate = allOptions.isSeparate;
            var layersStr = allOptions.params.layers
            
            //分开加载各个图层
            if (isSeparate) {
                var arrLayersStr = layersStr.split(",");
                var arrLayer = [];
                for (var i = 0, l = arrLayers.length; i < l; i++) {
                    OpenLayers.Util.extend(params, {
                        layers: arrLayers[i]
                    });
                    arrLayer.push(new Geo.View3D.Layer.WMS(name, url, params, options));
                }
                return arrLayer;
            }
            
            return new Geo.View3D.Layer.WMS(name, url, params, options);
        },
        "GEO_TILE": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.GlobeTile(name, url, options);
        },
        "GEO_TERRAIN": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.Terrain(name, url, options);
        },
        "GEO_MODEL": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.Model(name, url, options);
        },
        "OGC_WMTS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions;
            return new Geo.View3D.Layer.WMTS(name, url, options);
        },
		"GEO_WTFS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.WTFS(name, url, options);
        },
		"ARCGIS_REST": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.ArcgisRest(name, url, options);
        },
		"OGC_WFS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.WFS(name, url, options);
        }
    },
    "Geo.ViewFl.Map": {
        "OGC_WMS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var params = allOptions.params;
            var options = allOptions.options;
            var isSeparate = allOptions.isSeparate;
            var layersStr = allOptions.params.layers
            
            //分开加载各个图层
            if (isSeparate) {
                var arrLayersStr = layersStr.split(",");
                var arrLayer = [];
                for (var i = 0, l = arrLayers.length; i < l; i++) {
                    OpenLayers.Util.extend(params, {
                        layers: arrLayers[i]
                    });
                    arrLayer.push(new Geo.ViewFl.Layer.WMS(name, url, params, options));
                }
                return arrLayer;
            }
            
            return new Geo.ViewFl.Layer.WMS(name, url, params, options);
        },
        "GEO_TILE": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.ViewFl.Layer.GlobeTile(name, url, options);
        },
        "OGC_WMTS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions;
            return new Geo.ViewFl.Layer.WMTS(name, url, options);
        }
    }
};
/**
 * Class: Geo.Analysis.BufferAnalysis
 * 缓冲区分析类。
 */
Geo.Analysis.BufferAnalysis = Geo.Class({

	/**
     * APIProperty: url
     * {String} 缓冲分析操作所需要的WPS服务地址。
     */	
	url: null,

	/**
     * APIProperty: type
     * {Integer} 缓冲区的端点类型，默认值为Geo.Analysis.BufferAnalysis.CAP_ROUND。
     * 可以为Geo.Analysis.BufferAnalysis.CAP_ROUND、Geo.Analysis.BufferAnalysis.CAP_BUTT、
     * Geo.Analysis.BufferAnalysis.CAP_SQUARE三者之一。
     */
	type: 1,
	
	/**
     * APIProperty: accuracy
     * {Integer} 缓冲的拟合精度。默认值为32。
     */
	accuracy: 32,

	/**
	 * Constructor: Geo.Analysis.BufferAnalysis
	 * Geo.Analysis.BufferAnalysis类构造函数。
	 *
	 * Parameters:
	 * url - {String} WPS服务地址。
	 * options - {Object} 相关属性的设置项，可选。
	 */	
	initialize: function(url,options){
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},
	
    
    /**
     * 构造查询字串。将要缓冲的要素和缓冲半径来构造用于Post查询的字符串。
     * 参数:
     * features - 要执行缓冲分析的要素。
     * distance - 缓冲半径。
     */
	_buildPostXML: function(features,distance){
				
		var gmlParser = new OpenLayers.Format.GML();
        var geoStr = gmlParser.write(features);
		var xmlstr = 
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + 
			    '<wps:Execute service="WPS" version="1.0.0" xmlns:gml="http://www.opengis.net/gml" xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd">' + 
			    '<ows:Identifier>Buffer</ows:Identifier>' +
			    '<wps:DataInputs><wps:Input><ows:Identifier>InputPolygon</ows:Identifier><wps:Data><wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">' + 
			    geoStr + '</wps:ComplexData></wps:Data></wps:Input>' + 
			'<wps:Input><ows:Identifier>BufferDistance</ows:Identifier><wps:Data><wps:LiteralData>' + distance + '</wps:LiteralData></wps:Data>' + 
			'</wps:Input><wps:Input><ows:Identifier>BufferType</ows:Identifier><wps:Data><wps:LiteralData>' + this.type + '</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>BufferAccuracy</ows:Identifier><wps:Data><wps:LiteralData>' + this.accuracy + '</wps:LiteralData></wps:Data></wps:Input></wps:DataInputs><wps:ResponseForm><wps:RawDataOutput><ows:Identifier>BufferedPolygon</ows:Identifier></wps:RawDataOutput></wps:ResponseForm></wps:Execute>';
        return xmlstr;
	},

    /**
     * 获取所有要素范围之合的中心点。
     * 
     * 参数:
     * features - 要执行缓冲分析的要素。
     * 
     * 返回值:
     * {<Geo.LonLat>} 中心点的坐标。
     */
	_getFeaturesCenter: function(features){		
		var bounds = this._getFeaturesExtent(features);
		return bounds.getCenterLonLat();
	},
	
	/**
	 * 获取要素数组范围之合。
	 *
	 * 参数:
	 * features - 要查看的要素数组。
	 * 
	 * 返回值:
	 * {<Geo.Bounds>} 要素数组的总的范围。
	 */
	_getFeaturesExtent: function (features) {
        if(!(Geo.Util.isArray(features))){
			features = [features];
		}
        var maxExtent = null;
        if(features && (features.length > 0)) {
            maxExtent = new Geo.Bounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
	
	/**
	 * APIMethod: startAnalysis
	 * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
	 *
	 * Parameters:
	 * feature - {<Geo.Feature.Vector>}要分析的要素。
	 * distance - {Integer}缓冲半径。
	 * unit - {String} 长度计量单位。取值"m","km","degree"，可选，默认值为"m"。
	 * 
	 * Example:
	 * (code)
	 * //绘制一个被缓冲的中心点
     * var geometry = new Geo.Geometry.Point(110, 35);
     * var feature = new Geo.Feature.Vector(geometry);
     * 
	 * //设置缓冲距离500米
     * var distance = 500;
     * 
     * //缓冲单位
     * var unit = "m";
     * 
     * //开始缓冲分析
     * ba.startAnalysis(feature, distance, unit);
     * (end)
	 */
	startAnalysis: function(feature,distance,unit){
		var unitList = ["m","km","degree"];
		
		var lonlat = this._getFeaturesCenter(feature);
		
		//距离单位默认为米
		if(!unit || (OpenLayers.Util.indexOf(unitList,unit) == -1)){
			unit = "m";
		}
		
		switch(unit){
			case "km":
				distance = 1000 * distance;
			case "m":
				distance = this._meterToDegree(distance,lonlat);				
		}
		var postStr = this._buildPostXML(feature,distance);
		var xhr = new OpenLayers.Request.POST({
			url: this.url,
			data: postStr,
			scope: this,
			success:function(result){
				if("" == result.responseText || null == result.responseText){
					this.failFn();
					return;
				}
                var feature = this._parserResult(result);
                this.successFn(feature);
            },
			failure:this.failFn
			
		});
	},
	
	/**
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * 参数:
	 * meter - 要转换的地理坐标。
	 * lonlat - 经纬度。
	 */
	_meterToDegree: function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(OpenLayers.Util.rad(templat)) );
	},
	
	/**
	 * APIMethod: successFn
	 * 缓冲分析操作成功的回调函数，由用户使用自己定义的方法替代。
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 结果要素数组。
	 */	
	successFn:function(features){
	},

	/**
	 * APIMethod: failFn
	 * 缓冲分析操作失败回调函数，默认提示"缓冲分析操作失败，请检测服务是否正常运行。"，
	 * 用户可以使用自定义方法覆写。
	 */		
	failFn:function(){
		alert("缓冲分析操作失败，请检测服务是否正常运行。");
	},
	
    /**
     * 解析缓冲分析操作返回结果
     */
	_parserResult: function(result){
		var feature = null;
		var xmlParser = new OpenLayers.Format.XML();
		if(!result.responseXML){
			result.responseXML = xmlParser.read(result.responseText);
		}
		var gmlParser = new OpenLayers.Format.GML();		
			feature = gmlParser.read(result.responseXML);
		return feature;
	},

	CLASS_NAME: "Geo.Analysis.BufferAnalysis"
});

/**
 * Constant: Geo.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 圆形缓冲区端点。
 */
Geo.Analysis.BufferAnalysis.CAP_ROUND = 1;

/**
 * Constant: Geo.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 平角缓冲区端点。
 */
Geo.Analysis.BufferAnalysis.CAP_BUTT = 2;


/**
 * Constant: Geo.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 矩形缓冲区端点。
 */
Geo.Analysis.BufferAnalysis.CAP_SQUARE = 3;/**
 * Class: Geo.Analysis.SuperposeAnalysis
 * 叠置分析类。
 */
Geo.Analysis.SuperposeAnalysis = Geo.Class({
	
	/**
     * APIProperty: url
     * {String} 叠置分析操作所需要的WPS服务地址。
     */	
	url: null,
	
	/**
     * APIProperty: type
     * {String} 叠置分析操作类型。
     */	
	type:"Intersection",

    //请求串模板
	_requestStringTemplate:
		'<wps:Execute service="WPS" version="1.0.0" xmlns:gml="http://www.opengis.net/gml" xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:wfs="http://www.opengis.net/wfs" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd">'+
			'<ows:Identifier>${type}</ows:Identifier>'+
			'<wps:DataInputs>'+
				'<wps:Input>'+
					'<ows:Identifier>InputPolygon</ows:Identifier>'+
					'<wps:Data>'+
						'<wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">'+
							'${dataInputs}'+
						'</wps:ComplexData>'+
					'</wps:Data>'+
				'</wps:Input>'+
			'</wps:DataInputs>'+
			'<wps:ResponseForm>'+
				'<wps:RawDataOutput>'+
					'<ows:Identifier>BufferedPolygon</ows:Identifier>'+
				'</wps:RawDataOutput>'+
			'</wps:ResponseForm>'+
		'</wps:Execute>',

	/**
     * APIProperty: sourceFeatures
     * {Array(<Geo.Feature.Vector>)}  叠置分析操作指定的源要素。
     */	
	sourceFeatures: null,

	/**
     * APIProperty: targetFeatures
     * {Array(<Geo.Feature.Vector>)}  叠置分析操作指定的目标要素。
     */	
	targetFeatures: null,
	
    /**
     * Constructor: Geo.Analysis.SuperposeAnalysis
     * Geo.Analysis.SuperposeAnalysis类构造函数。
     *
     * Parameters:
     * url - {String} WPS服务地址
     * options - {Object} 相关属性的设置项，可选
     */
	initialize: function(url,options){
		this.url = url;
		this.sourceFeatures = [];
		this.targetFeatures = [];
		OpenLayers.Util.extend(this, options);
	},
	
	//构造查询字串
	_buildRequestString: function(){
		var gmlParser = new OpenLayers.Format.GML();
        var sourceStr = gmlParser.write(this.sourceFeatures);
		var targetStr = gmlParser.write(this.targetFeatures);
		
		var string = OpenLayers.String.format(this._requestStringTemplate,{
            type: this.type,
			dataInputs: sourceStr + targetStr
		});
        return string;
	},
	
	/**
	 * APIMethod: startAnalysis
	 * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
	 *
	 */
	startAnalysis: function(){
		
		//查询前做设置方面检查
		if(this._checkSet()){
			return false;
		}
		
		//发送分析请求
		var postStr = this._buildRequestString();
		var xhr = new OpenLayers.Request.POST({
			url: this.url,
			data: postStr,
			scope: this,
			success:function(result){
				if("" == result.responseText || null == result.responseText){
					this.failFn();
					return;
				}
                var features = this._parserResult(result);
                this.successFn(features);
            },
			failure:this.failFn
			
		});
	},
	
	//检查相关参数设置
	_checkSet: function(){
		if(!this.url){
			return false;
		}
		if(!this.sourceFeatures || !this.sourceFeatures.length){
			return false;
		}
		if(!this.targetFeatures || !this.targetFeatures.length){
			return false;
		}
	},
	
	/**
	 * APIMethod: successFn
	 * 分析操作成功的回调函数
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 结果要素数组
	 */	
	successFn:function(features){
		
	},

	/**
	 * APIMethod: failFn
	 * 叠置分析操作失败回调函数，默认提示"叠置分析操作失败，请检测服务是否正常运行。"，
	 * 用户可以使用自定义方法替代。
	 */		
	failFn:function(){
		alert("叠置分析操作失败，请检测服务是否正常运行。");
	},
	
	//解析结果
	_parserResult: function(result){
		var feature = [];
		var xmlParser = new OpenLayers.Format.XML();
		if(!result.responseXML){
			result.responseXML = xmlParser.read(result.responseText);
		}
		var gmlPrefix = "gml";
		var gmlUri = xmlParser.lookupNamespaceURI(result.responseXML, gmlPrefix);
		var featureCollection = xmlParser.getElementsByTagNameNS(result.responseXML, gmlUri, "FeatureCollection");
		if(featureCollection.length > 0){
			var gmlstr = xmlParser.write(featureCollection[0]);
			var gmlParser = new OpenLayers.Format.GML();		
			feature = gmlParser.read(gmlstr);
		}
		return feature;
	},				

	CLASS_NAME:"Geo.Analysis.SuperposeAnalysis"
	
});/**
 * Class: Geo.Query.WFSQuery
 * WFS地图要素服务查询类。本类也适用于聚合网络要素服务（Aggregation Web Feature Service简称AWFS）和地名地址要素服务（Web Feature Service Gazetteer简称WFS-G）的查询。
 */
Geo.Query.WFSQuery = Geo.Class({
	
    /**
     * APIProperty: url
     * {String} WFS服务地址。
     */
	url: null,
	
	/**
     * APIProperty: version
     * {String} WFS服务版本
     */
	version: "1.0.0",

    /**
     * APIProperty: featureNS
     * {String} 要素命名空间
     */
    featureNS: null,
	
	/**
	 * APIProperty: isReverse
	 * {Boolean} 是否对请求结果中的几何信息进行轴序反转，默认值为false,
	 * 当取值为false时，对请求结果不做反转操作。
	 * 当取值为true时，对请求结果做反转操作。
	 */
	isReverse: false,
	
	/**
	 * APIProperty: featurePrefix
	 * {String} 要素类型前缀，默认值""
	 */
	featurePrefix:"",
	
    /**
     * APIProperty: featureType
     * {String} 要素类型。
     */	
	featureType: "",
	
    /**
     * APIProperty: maxFeatures
     * {Number} 最大结果数。
     */	
	maxFeatures: 10,
	
    /**
     * APIProperty: filter
     * {<Geo.Filter>} 查询条件。
     */
	filter: null,
    
    /**
     * APIProperty: geometryName
     * {String} 要素中geometry属性的名称，默认为"the_geom"。
     */
    geometryName: "the_geom",	


    /**
     * APIProperty: protocol
     * {<Geo.Protocol>} WFS查询协议对象。
     */	
	protocol: null,

    /**
     * APIProperty: format
     * {<Geo.Format>} 用于对查询操作返回结果进行解析的格式解析器，默认为GML解析器。
     */
	format: null,
    
    /**
     * APIProperty: format
     * {<Geo.Format>} 格式解析器构造参数。
     */    
    formatOptions: null,
    
    /**
     * APIProperty: isSeparate
     * {Boolean} 设置是否将查询结果按图层名分类。
     */  
    isSeparate: false,
	
    /**
     * APIProperty: srsName
     * {String} 空间参考名。默认值为"EPSG:4326"。
     */
    srsName: "EPSG:4326",	
	
	/**
	 * APIProperty: sortBy
	 * {Array} 设置WFS查询结果的排序参数，该参数为一个数组对象。
     * > sortBy数组内对象所包含的属性:
     * > property - {String} 查询出的要素的某一属性的名称，根据该属性进行排序。
     * > order - {String} 设置正序("ASC")或倒序("DESC")。
     * 
	 * 说明：
	 * 1.wfsg和wfs服务都支持排序；如果wfsg服务中的Post请求串中没有sort节点，那么该服务就不进行排序了（此时用其他字段排序也不起作用了）。当服务在查询中
	 * 有sort节点的时候， 建议用户选择STANDARDNAME和sort字段之一进行排序。如果使用DoMainName作为查询关键字，也可以使用DoMainName进行作为排序字段。
	 * 
	 * 2.wfsg服务和wfs服务默认是以sort字段进行排序，sort字段的值是数字，如果用户以sort字段进行排序，那么sort字段的值（数字）越大，
	 * 在结果列表中越排在后面，相反，sort字段的值越小，则在结果列表中排在越前面，如果sort字段的值相同，则按照其在数据库中读出来的先后顺序排列，
	 * 如果sort字段没值，则排在结果的最后面。
	 * 
	 * 3.若是以STANDARDNAME作为排序字段，如果STANDARDNAME的值是中文，那么排序就是第一个汉字的拼音的首字母的先后顺序作为排序字段（如北京和安徽，
	 * 北京是b为拼音首字母，安徽是a为拼音首字母，那么就是安徽排在北京的前面），若值的第一个汉字拼音首字母相同，则是以第一个汉字拼音的第二个字
	 * 母的先后顺序排列；如果STANDARDNAME的值是英文，也一样，依次类推。
	 * 
	 * Examples:
	 * (code)
	 *		 wfsQueryObj.sortBy = [{
     *              property: "STANDARDNAME",
     *              order: "DESC"
     *          }]
	 * (end)
	 */
	sortBy: null,


	/**
	 * Constructor: Geo.Query.WFSQuery
	 * Geo.Query.WFSQuery类构造函数。
	 * 
	 * Parameters:
	 * url - {String} WFS服务地址。
	 * featureType - {String} 要素类型。
	 * options - {Object} 相关属性的设置项，可选。
	 */	
	initialize: function(url,featureType,options){
		this.url = url;
		this.featureType = featureType;
		var xy = null;
		if(options) {
			if(options.isReverse === true) {
				this.isReverse = options.isReverse;
				xy = !options.isReverse;
			}else if(options.isReverse === false) {
				this.isReverse = options.isReverse;
				//xy顺序即是不反转
				xy = !options.isReverse;
			}else {
				//默认不反转
				xy = !this.isReverse;
			}
			if(!options.format) {
				this.format = new OpenLayers.Format.GML({xy:xy});
			}else if(options.format instanceof OpenLayers.Format.GML.v2 ||options.format instanceof OpenLayers.Format.GML.v3) {
				options.format.setFeatureType_(featureType);
			}
		}
		OpenLayers.Util.extend(this, options);
	},

	/**
	 * APIMethod: query
	 * 开始查询。
	 * 
	 * Parameters:
	 * filter - {Geo.Filter} 过滤器。
	 * 说明：
	 * 1.当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，参数filter中的
	 * 所有几何参数都需要改为纬度，经度的顺序。举例说明：
	 * 以矩形范围为例：
	 * new Geo.Bounds(-180,-90,180,90);
	 * 在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该矩形范围应写成
	 * new Geo.Bounds(-90,-180,90,180);
	 * 
	 * successFn - {Function} 请求成功的回调函数。
	 * > 该回调函数会提供一个形参，该形参是一个数组，名为features。在地名查询2.0及其以上的版本中，features有一个属性叫trueNames，
	 * > 该属性用于存放纠错词信息。在地名查询2.0以下的版本中不提供trueNames属性。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * Examplse:
	 * (code)
	 *  	//查询范围
	 *		var queryBBOX = new Geo.Bounds(-180,-90,180,90);
	 *		 //范围过滤
	 *		 var filter = new Geo.Filter.Spatial({
	 *           type: Geo.Filter.Spatial.BBOX,
	 *           property: this.geometryName,            
	 *		    value: queryBBOX
	 *       });
	 *		 wfsQueryObj.query(filter,successFn,failFn);
	 * (end)
	 */
	query: function(filter,successFn,failFn){
		
		this.protocol = new OpenLayers.Protocol.WFS({
			readFormat: this.format,
            formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			srsName:this.srsName
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = OpenLayers.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var features = result.features
            
            //根据要求进行按图层名分捡要素
            if(this.isSeparate){
                features = this._separateFeatures(features);
            }
            //对于容错给予提示的节点
            var trueNames = this._read_trueName(result);
			trueNames ? (features.trueNames = trueNames) : features;
			querySuccessFn(features);
			
		},this);

		this.response = this.protocol.read({
			sortBy: this.sortBy,
			filter: queryFilter,
			callback: callback
		});
	},
    
	//读取容错提示节点
	_read_trueName: function(result) {
		var trueNames = [];
		if(result.priv && result.priv.responseText) {
			if(null == this.format){
				return null;
			}
			var trueNameDocs = this.format.getXMLDoc().getElementsByTagName("trueName");
			if (trueNameDocs == null || trueNameDocs.length == 0) {
                return null;
            }
			for(var i = 0; i < trueNameDocs.length; i++) {
				trueNames.push(trueNameDocs[i].text);
			}
			return trueNames;
		}
		return trueNames;
	},
	
	/**
	 * APIMethod: getBufferRegion
	 * 得到缓冲区域。
	 * 
	 * Parameters:
     * point - {<Geo.Feature.Vector>} 点要素。
     * distance - {Integer} 半径。
     * unit - {String} 缓冲单位。
     * 
	 * Returns:
     * {<Geo.Geometry.Polygon>} 几何多边形。
	 */
	getBufferRegion: function(point,distance,unit) {
		var lonlat = this._getFeaturesCenter(point);
		switch(unit){
			case "km":
				distance = 1000 * distance;
			case "m":
				distance = this._meterToDegree(distance,lonlat);				
		}
		return Geo.Geometry.Polygon.createRegularPolygon(point,distance,40,360); 
	},
	
    /**
     * Method: _getFeaturesCenter
     * 获取所有要素范围之合的中心点。
     * 
     * Parameters:
     * features - 要执行缓冲分析的要素。
     * 
     * Returns:
     * {<Geo.LonLat>} 中心点的坐标。
     */
	_getFeaturesCenter: function(features){		
		var bounds = this._getFeaturesExtent(features);
		return bounds.getCenterLonLat();
	},
	
	/**
	 * Method: _getFeaturesExtent
	 * 获取要素数组范围之合。
	 *
	 * Parameters:
	 * features - 要查看的要素数组
	 * 
	 * Returns:
	 * {<Geo.Bounds>} 要素数组的总的范围。
	 */
	_getFeaturesExtent: function (features) {
        if(!(Geo.Util.isArray(features))){
			features = [features];
		}
        var maxExtent = null;
        if(features && (features.length > 0)) {
            maxExtent = new Geo.Bounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
	/**
	 * Method: _meterToDegree
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * Parameters:
	 * meter - 要转换的地理坐标。
	 * lonlat - 经纬度。
	 */
	_meterToDegree: function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(OpenLayers.Util.rad(templat)) );
	},
	
	/**
	 * APIMethod: pointQuery
	 * 点查询。
	 * 
	 * Parameters:
	 * point - {<Geo.Geometry.Point>} 点要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的point参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个点要素为例：new Geo.Geometry.Point(112,20)。
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该点要素应写成new Geo.Geometry.Point(20,112)
	 * distance - {Number} 缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 * unit - {String} 单位  值为"m"或degree。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * Examples:
	 * (code)
	 *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
	 *   //点要素
	 *	 var queryPoint = new Geo.Geometry.Point(110.40056,39.93202);
	 *   wfsQueryObj.pointQuery(queryPoint,distance,unit,successFn,failFn);
	 * (end)
	 */
    pointQuery: function(point,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new OpenLayers.Filter.Spatial({
            type:OpenLayers.Filter.Spatial.DWITHIN,
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: point
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: pathQuery
	 * 线查询。
	 * 
	 * Parameters:
	 * path - {<Geo.Geometry.LineString>} 线要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的path参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个线要素为例：new Geo.Geometry.LineString([new Geo.Geometry.Point(118,20),new Geo.Geometry.Point(118.8,20.8)])。
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该线要素应写成
     * 		new Geo.Geometry.LineString([new Geo.Geometry.Point(20,118),new Geo.Geometry.Point(20.8,118.8)])。
	 * distance - {Number}缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 * unit - {String} 单位  值为"m"或degree。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * Examples:
     * (code)
     *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
     *   //线要素
	 *	 var queryPath = new Geo.Geometry.LineString([
     *         new Geo.Geometry.Point(110,35),
     *         new Geo.Geometry.Point(110,36)
     *    ]);
     * 	 wfsQueryObj.pathQuery(queryPath, distance, unit, successFn,failFn);
     * (end)
	 */
    pathQuery: function(path,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new OpenLayers.Filter.Spatial({
            type:OpenLayers.Filter.Spatial.DWITHIN,
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: path
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: polygonQuery
	 * 面查询。
	 * 
	 * Parameters:
	 * polygon - {<Geo.Geometry.Polygon>} 面要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的polygon参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个面要素为例：
     * 		new Geo.Geometry.Polygon([
     *   	 new Geo.Geometry.LinearRing([
     *       new Geo.Geometry.Point(177.76672363281,37.655639648436),
     *       new Geo.Geometry.Point(177.8884299300619,38.21858951787163),
     *       new Geo.Geometry.Point(177.8884299300619,38.21858951787163),
     *       new Geo.Geometry.Point(177.8884299300619,38.21858951787163)
     *       ])
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该面要素应写成
     * 		new Geo.Geometry.Polygon([
     *   	 new Geo.Geometry.LinearRing([
     *       new Geo.Geometry.Point(37.655639648436,177.76672363281),
     *       new Geo.Geometry.Point(38.21858951787163,177.8884299300619),
     *       new Geo.Geometry.Point(38.21858951787163,177.8884299300619),
     *       new Geo.Geometry.Point(38.21858951787163,177.8884299300619)
     *       ])
	 * 
	 * isContain - {Boolean} 是包含还是相交。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * Examples:
     * (code)
     * 	 var isContain = false;
	 *	 var queryPolygon = new Geo.Geometry.Polygon([
     *   	 new Geo.Geometry.LinearRing([
     *       new Geo.Geometry.Point(77.76672363281,37.655639648436),
     *       new Geo.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new Geo.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new Geo.Geometry.Point(77.8884299300619,38.21858951787163)
     *       ])                
     *   ]);
     * 	 wfsQueryObj.polygonQuery(queryPolygon, isContain, successFn,failFn);
     * (end)
	 */
    polygonQuery: function(polygon,isContain,successFn,failFn){
        var filterType = isContain ? OpenLayers.Filter.Spatial.CONTAINS : 
                                     OpenLayers.Filter.Spatial.INTERSECTS;
        var filter = new OpenLayers.Filter.Spatial({
            type: filterType,
            property: this.geometryName, 
            value: polygon
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: bboxQuery
	 * 范围查询。
	 * 
	 * Parameters:
	 * bbox - {<Geo.Bounds>} 范围。
	 * 说明：
	 * 1.当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，参数filter中的
	 * 所有几何参数都需要改为纬度，经度的顺序。举例说明：
	 * 以矩形范围为例：
	 * new Geo.Bounds(-180,-90,180,90);
	 * 在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该矩形范围应写成
	 * new Geo.Bounds(-90,-180,90,180);
	 * 
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * Examples:
	 * (code)
	 *   //查询范围
		 var queryBBOX = new Geo.Bounds(-180,-90,180,90);
	 * 	 wfsQueryObj.bboxQuery(queryBBOX, successFn,failFn);
	 * (end)
	 */
    bboxQuery: function(bbox,successFn,failFn){
        var filter = new Geo.Filter.Spatial({
            type: OpenLayers.Filter.Spatial.BBOX,
            property: this.geometryName,            
		    value: bbox
        });
        this.query(filter,successFn,failFn);
    },
    
	/**
	 * APIMethod: attributeQuery
	 * 属性查询。
	 * 
	 * Parameters:
	 * type - {String} 比较类型。
	 * property - {String} 属性名。
	 * value - {Number} or {String} 属性值。
	 * options - {Object} 可选参数。
	 *    lowerBoundary - {Number} or {String} 值小的边界。
	 *    upperBoundary - {Number} or {String} 值大的边界。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * Examples:
     * (code)
     *   var type = Geo.Filter.Comparison.LIKE;
	 *		var property = "label";
	 *		var value = "*";
	 *		wfsQueryObj.attributeQuery(type,property,value,{
	 *			matchCase : true
	 *	 },successFn,failFn);
     * (end)
	 * 
	 */
    attributeQuery: function(type, property, value, options, successFn,failFn){
        
        var matchCase = options && options.matchCase;
        var lowerBoundary = options ? options.lowerBoundary : null;
        var upperBoundary = options ? options.upperBoundary : null;
        
        var filter = new OpenLayers.Filter.Comparison({
            type: type,
            property: property,            
		    value: value,
            matchCase: matchCase,
            lowerBoundary: lowerBoundary,
            upperBoundary: upperBoundary
        });
        this.query(filter,successFn,failFn);
    },

    /**
     * APIProperty: successFn
     * 查询成功后的回调函数，用户可以自定义此方法。
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 结果要素数组。
     */
	successFn: function(features){
        
    },

    /**
     * APIMethod: failFn
     * WFS查询失败响应方法，默认提示"对不起,查询失败,请查询服务是否正常"，用户可以根据需要覆盖此方法。
     */    
    failFn: function(){
    	alert("对不起,查询失败,请查询服务是否正常。");
    },
    
    //私有,按图层类型分离要素
    _separateFeatures: function(features){
        var result = {};
        for(var i=0; i<features.length; i++){
            var f = features[i];
            var featureType;
            
            //如果是经GML2解析器则判断gml属性中的featureType，如果是GML3则判断type
            if (f.gml) {
                featureType = f.gml.featureType;
            }
            else {
                featureType = f.type;
            }
            
            if(!result[featureType]){
                result[featureType] = [];
            }
            result[featureType].push(f);
        }
        return result;
    },
    	
	CLASS_NAME: "Geo.Query.WFSQuery"
});

Geo.Query.WFSQuery.reverseGeometryXY = function(geometry) {
	
	var geometryTypes = {
        "OpenLayers.Geometry.Point": "Point",
        "OpenLayers.Geometry.MultiPoint": "MultiPoint",
        "OpenLayers.Geometry.LineString": "LineString",
        "OpenLayers.Geometry.MultiLineString": "MultiLineString",
        "OpenLayers.Geometry.Polygon": "Polygon",
        "OpenLayers.Geometry.MultiPolygon": "MultiPolygon",
        "OpenLayers.Geometry.Collection": "GeometryCollection"
    };
	var types = {
		"Point": function(geometry,types) {
			var pointx = geometry.x;
			var pointy = geometry.y;
			var point = geometry.clone(geometry);
			point.x = pointy;
			point.y = pointx;
			return point;
		},
		"LineString": function(geometry,types) {
			var lineString = geometry.clone(geometry);
			for(var i = 0; i < lineString.components.length; i++) {
				var point = types["Point"](lineString.components[i]);
				lineString.components[i] = point;
			}
			return lineString;
		},
		"Polygon": function(geometry,types) {
			var polygon = geometry.clone(geometry);
			for(var i = 0; i < polygon.components.length; i++) {
				for(var j = 0; j <polygon.components[i].components.length - 1; j++) {
					var point = types["Point"](polygon.components[i].components[j]);
					polygon.components[i].components[j] = point;
				}
			}
			return polygon;
		}
	}
	var ageometry = types[geometryTypes[geometry.CLASS_NAME]](geometry,types);
	return ageometry;
};/*
 * ===================================================
 * WFS查询服务端分页所需类定义
 * ===================================================
 */
OpenLayers.Format.Filter.v1.prototype.writers["ogc"]["SortBy"] = function(sortProperties) {
	var node = this.createElementNSPlus("ogc:SortBy");
	for (var i=0,l=sortProperties.length;i<l;i++) {
	    this.writeNode(
	        "ogc:SortProperty",
	        sortProperties[i],
	        node
	    );
	}
	return node;
},
/*
 * ===================================================
 * 注意，以下是对Format/WFST/v1.js文件的修改
 * 增加：
 * resultType: options && options.resultType,
 * startPosition: options && options.startPosition,
 * ===================================================
 */

OpenLayers.Format.WFST.v1.prototype.writers.wfs.GetFeature = function(options) {
    var node = this.createElementNSPlus("wfs:GetFeature", {
        attributes: {
            service: "WFS",
            version: this.version,
            outputFormat: options && options.outputFormat,
            resultType: options && options.resultType,
            startPosition: options && options.startPosition,
            maxFeatures: options && options.maxFeatures,
            "xsi:schemaLocation": this.schemaLocationAttr(options)
        }
    });
    if (typeof this.featureType == "string") {
        this.writeNode("Query", options, node);
    } else {
        for (var i=0,len = this.featureType.length; i<len; i++) { 
            options.featureType = this.featureType[i]; 
            this.writeNode("Query", options, node); 
        } 
    }
    return node;
}
OpenLayers.Format.Filter.v1.prototype.writers["ogc"]["SortProperty"] = function(sortProperty) {
	var node = this.createElementNSPlus("ogc:SortProperty");
	this.writeNode(
	    "ogc:PropertyName",
	    sortProperty,
	    node
	);
	this.writeNode(
	    "ogc:SortOrder",
	    (sortProperty.order == 'DESC') ? 'DESC' : 'ASC',
	    node
	);
	return node;
},

OpenLayers.Format.Filter.v1.prototype.writers["ogc"]["SortOrder"] = function(value) {
    var node = this.createElementNSPlus("ogc:SortOrder", {
        value: value
    });
    return node;
},


//查询服务出错时给出错误提示
OpenLayers.Protocol.WFS.v1.prototype.parseResponse  = function(request, options) {
    var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
        var result=null;
        try{
        	result = (this.readFormat !== null) ? this.readFormat.read(doc) : 
            this.format.read(doc, options);
        }catch(e){
        	var error = "程序运行异常："+e.name + "，"+e.message;
        	alert(error);
//        	throw e;
        }
        if (!this.featureNS) {
            var format = this.readFormat || this.format;
            this.featureNS = format.featureNS;
            // no need to auto-configure again on subsequent reads
            format.autoConfig = false;
            if (!this.geometryName) {
                this.setGeometryName(format.geometryName);
            }
        }
        return result;
},

OpenLayers.Format.WFST.v1_0_0.prototype.writers = {
    "wfs": OpenLayers.Util.applyDefaults({
        "Query": function(options) {
            options = OpenLayers.Util.extend({
                featureNS: this.featureNS,
                featurePrefix: this.featurePrefix,
                featureType: this.featureType,
                srsName: this.srsName,
                srsNameInQuery: this.srsNameInQuery
            }, options);
            var node = this.createElementNSPlus("wfs:Query", {
                attributes: {
                    typeName: (options.featureNS ? options.featurePrefix + ":" : "") +
                        options.featureType
                }
            });
            if(options.srsNameInQuery && options.srsName) {
                node.setAttribute("srsName", options.srsName);
            }
            if(options.featureNS) {
                node.setAttribute("xmlns:" + options.featurePrefix, options.featureNS);
            }
            if(options.propertyNames) {
                for(var i=0,len = options.propertyNames.length; i<len; i++) {
                    this.writeNode(
                        "ogc:PropertyName", 
                        {property: options.propertyNames[i]},
                        node
                    );
                }
            }
            if(options.filter) {
                this.setFilterProperty(options.filter);
                this.writeNode("ogc:Filter", options.filter, node);
            }
            if (options.sortBy) {
                this.writeNode("ogc:SortBy", options.sortBy, node);
            }
            return node;
        }
    }, OpenLayers.Format.WFST.v1.prototype.writers["wfs"]),
    "gml": OpenLayers.Format.GML.v2.prototype.writers["gml"],
    "feature": OpenLayers.Format.GML.v2.prototype.writers["feature"],
    "ogc": OpenLayers.Format.Filter.v1_0_0.prototype.writers["ogc"]
},

Geo.Query.WFSQuery.prototype.sortBy =  null,

//增加featureType_属性，让gml解析器能解析多个图层的数据。
OpenLayers.Format.GML.Base.prototype.setFeatureType_ = function(featureType) {
	this.featureType_ = featureType;
}, 
//覆盖ol2.13的方法，ol提供的gml.v3和gmlv2解析器只支持解析一个图层的数据，但是实际应用场景中，会解析多个图层的数据。
//增加本方法的目的是让解析器同时能解析服务返回的多个图层的数据
OpenLayers.Format.GML.Base.prototype.readers["feature"]["*"] = function(node, obj) {
    // The node can either be named like the featureType, or it
    // can be a child of the feature:featureType.  Children can be
    // geometry or attributes.
    var name;
    var local = node.localName || node.nodeName.split(":").pop();
    // Since an attribute can have the same name as the feature type
    // we only want to read the node as a feature if the parent
    // node can have feature nodes as children.  In this case, the
    // obj.features property is set.
    if (obj.features) {
        if (!this.singleFeatureType &&
            (OpenLayers.Util.indexOf(this.featureType, local) !== -1)) {
            name = "_typeName";
        } else if(local === this.featureType) {
            name = "_typeName";
			//this.featureType_属性是补丁中新增的属性，目的是让解析器能解析多个图层的数据。
        }else if(OpenLayers.Util.isArray(this.featureType_)) {
			for(var i = 0; i < this.featureType_.length;i++) {
				if(this.featureType_[i] === local) {
					name = "_typeName";
					break;
				}
			}
		}
    } else {
        // Assume attribute elements have one child node and that the child
        // is a text node.  Otherwise assume it is a geometry node.
        if(node.childNodes.length == 0 ||
           (node.childNodes.length == 1 && node.firstChild.nodeType == 3)) {
            if(this.extractAttributes) {
                name = "_attribute";
            }
        } else {
            name = "_geometry";
        }
    }
    if(name) {
        this.readers.feature[name].apply(this, [node, obj]);
    }
},

OpenLayers.Format.WFSHits = OpenLayers.Class(OpenLayers.Format.XML,{

  wfsns: "http://www.opengis.net/wfs",

  featureCollection: "FeatureCollection",

  read:function(data){
    if(typeof data == "string") { 
        data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);
    }
    var featureCollectionNodes = data.documentElement;
    var numberOfFeatures = parseInt(featureCollectionNodes.getAttribute("numberOfFeatures"));
    return {numberOfFeatures:numberOfFeatures}
  }
});


Geo.Query.WFSQuery.prototype.resultType = "Results";

Geo.Query.WFSQuery.prototype.startPosition = null;

//查询总数据的总条数
Geo.Query.WFSQuery.prototype.queryTotalNumber = function(filter,successFn,failFn){

        var hitsParser = new OpenLayers.Format.WFSHits();

		this.protocol = new OpenLayers.Protocol.WFS({
			readFormat: hitsParser,
			propertyNames: this.propertyNames,
            resultType: "hits",
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = OpenLayers.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var hitsResult = result.features
            
			querySuccessFn(hitsResult);
			
		},this);

		this.response = this.protocol.read({
			filter: queryFilter,
			callback: callback
		});

};

/*
 * 查询当前页的内容
 */
Geo.Query.WFSQuery.prototype.queryPage = function(filter, successFn, failFn, options){
    var perPageNumber = (options && options.perPageNumber) || 15,
        pageNumber = (options && options.pageNumber) || 1;
    
    var startPosition = (pageNumber - 1) * perPageNumber + 1;
	this.protocol = new OpenLayers.Protocol.WFS({
		readFormat: this.format,
		multi:true,
        formatOptions: this.formatOptions,
		propertyNames: this.propertyNames,
        maxFeatures: perPageNumber,
        startPosition: startPosition,
        featurePrefix:this.featurePrefix,
        url: this.url,
        featureNS: this.featureNS,
		version: this.version,
		geometryName : this.geometryName,
        featureType: this.featureType,
		srsName:this.srsName
    });
	
    //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
    var queryFilter = filter || this.filter;
    var querySuccessFn = successFn || this.successFn;
    var queryFailFn = failFn || this.failFn;
    
	var callback = OpenLayers.Function.bind(function(result){
			
		//显示查询失败信息
		if(!result.success()){
			queryFailFn();
			return;
		}

		var features = result.features
        
        //根据要求进行按图层名分捡要素
        if(this.isSeparate){
            features = this._separateFeatures(features);
        }
        //对于容错给予提示的节点
        var trueNames = this._read_trueName(result);
		features.trueNames = trueNames;
		querySuccessFn(features);
		
	},this);
	this.response = this.protocol.read({
		sortBy:this.sortBy,
//		maxFeatures: this.maxFeatures,
		filter: queryFilter,
		callback: callback
	});
}/**
 * Class: Geo.Query.CatalogQuery
 * CSW资源目录服务查询类。
 * 
 */
Geo.Query.CatalogQuery = Geo.Class({
	
	/**
     * APIProperty: url
     * {String} CSW服务地址。
     */
	url: null,
	
	/**
     * APIProperty: failFn
     * {Function} 请求失败的回调函数，可以用自定义函数覆盖。
     */
	failFn: function(){
		alert("对不起，查询请求失败！请检查资源目录服务是否正常运行。\n" + 
				"当前服务地址为：" + this.url);
	},
	
	/**
     * Constructor: Geo.Query.CatalogQuery
     * Geo.Query.CatalogQuery类的构造函数。
     *
     * Parameters:
     * url - {String} CSW服务地址。
     * options - {Object} 相关属性的设置项，可选。
     *
     */
	initialize: function(url, options){
		this.url = url;
		OpenLayers.Util.extend(this,options);
	},
	
	//soap格式请求串模板
	_soapTemplate: 
		'<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xsi:schemaLocation="http://www.opengis.net/ows" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
		   '<soapenv:Body>' +
		      '${soapBody}' +
		   '</soapenv:Body>' +
		'</soapenv:Envelope>',
	
	//查询请求串模板
	_getRecordsTemplate: 
	     '<csw:GetRecords service="CSW" version="2.0.2" outputFormat="text/xml" ' + 
		 		'resultType="results" ${outputSchema} ' + 
				'xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ogc="http://www.opengis.net/ogc" ' + 
				'${customNamespaces}> ' +
	         '<csw:Query typeNames="${typeNames}">' +
	            '<csw:ElementSetName>full</csw:ElementSetName>' +
	            '${constraint}' +
	         '</csw:Query>' +
	      '</csw:GetRecords>',
	
	//查询条件模板
	_constraintTemplate:
		'<csw:Constraint version="2.0.0">' +
		   '${filter}' +
		'</csw:Constraint>',
	
    /**
     * APIMethod: getResTreeNode
     * 读取资源目录树节点。
     * 
     * Parameters:
     * parentId - {String} 要读取的资源目录树节点父类ID号，默认值为0。
     * caller - {Object} 回调函数的作用域。。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     */
	getResTreeNode: function(parentId,caller,successFn,failFn){
		if(parentId){
			parentId = 0;
		}
		
		//请求相关设置
		var customNamespaces = 'xmlns:geoglobe="http://www.geostar.com.cn/geoglobe"';
		var outputSchema = 'outputSchema="geoglobe:ResourceType"';
		var typeNames = "geoglobe:ResourceType";
		
		//生成查询条件过滤器
		var kindFilter = new Geo.Filter.Comparison({
	        type: Geo.Filter.Comparison.EQUAL_TO,
	        property: "/geoglobe:ResourceType/geoglobe:kind",
	        value: "CATALOG"
	    });		
		var parentIdFilter = new Geo.Filter.Comparison({
	        type: Geo.Filter.Comparison.EQUAL_TO,
	        property: "/geoglobe:ResourceType/geoglobe:parentId",
	        value: parentId
	    });
		var constraintFilter = new Geo.Filter.Logical({
		    type: Geo.Filter.Logical.AND,
		    filters: [kindFilter,parentIdFilter]
		});
		var constraintString = this._makerFilterString(constraintFilter);
		
		//生成查询请求串
		var requestString = OpenLayers.String.format(this._getRecordsTemplate,{
			customNamespaces: customNamespaces,
			constraint: constraintString,
			outputSchema: outputSchema,
			typeNames: typeNames
		});
		
		requestString = this._wrapToSoapRequest(requestString);
		
		//发送查询请求
		if(!(failFn instanceof Function)){
			failFn = this.failFn;
		}
		
		var successHandler = OpenLayers.Function.bind(function(result){
			var result = this._getBodyFromSoapResponse(result.responseText);
			var successHandler = OpenLayers.Function.bind(successFn,this);
			successHandler(result);
		},this);
		
		var xhr = new OpenLayers.Ajax.Request(
			this.url, 
			{
				contentType:"application/xml", method:"post",
				postBody: requestString,
				onSuccess: successHandler,
				onFailure: failFn
			}
		);
	},
	
	//输入关键字等条件查询所需服务元数据，对queryMetaData方法的封装，方便使用
	searchServices: function(options,caller,successFn,failFn){
		
		
	},

    /**
     * APIMethod: queryMetaData
     * 查询服务元数据。
     * 
     * Parameters:
     * filter - {<Geo.Filter>} 查询条件，如果不指定（值为null）则返回所有服务元数据记录。
     * caller - {Object} 指定回调函数的作用域。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     */
	queryMetaData: function(filter,caller,successFn,failFn){
		
		//查询资源目录用到的XML名字空间
		var customNamespaces = ' xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007"';
		var outputSchema= ' outputSchema="smmd:Metadata"';
		var typeNames = "smmd:Metadata";
		
		var constraintString = this._makerFilterString(filter);
		
		//生成查询请求串
		var requestString = OpenLayers.String.format(this._getRecordsTemplate,{
			customNamespaces: customNamespaces,
			constraint: constraintString,
			outputSchema: outputSchema,
			typeNames: typeNames
		});
		
		requestString = this._wrapToSoapRequest(requestString);
		
		//发送查询请求
		if(!(failFn instanceof Function)){
			failFn = this.failFn;
		}
		
		var successHandler = OpenLayers.Function.bind(function(result){
			var result = this._getBodyFromSoapResponse(result.responseText);
			var successHandler = OpenLayers.Function.bind(successFn,this);
			successHandler(result);
		},this);
		var xhr = new OpenLayers.Ajax.Request(
			this.url, 
			{
				contentType:"application/xml", method:"post",
				postBody: requestString,
				onSuccess: successHandler,
				onFailure: failFn
			}
		);
	},
	
	//加上SOAP请求包
	_wrapToSoapRequest:function(string){
		var requestString = OpenLayers.String.format(this._soapTemplate,{
			soapBody: string
		});
		return requestString;
	},
	
	//从SOAP响应结果中获取实际内容
	_getBodyFromSoapResponse:function(data){
		if(typeof data == "string") { 
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
		
		//如果是SOAP响应，从中取出内容，如果不是直接返回内容。
		if(data.nodeName == "SOAP-ENV:Envelope"){
			return data.childNodes[0].childNodes[0];
		}
		return data;
	},
	
	//生成过滤器字符串
	_makerFilterString: function(filter){
		if(!filter){
			filter = new Geo.Filter.Comparison({
                type: Geo.Filter.Comparison.LIKE,
                property: "/smmd:Metadata/smmd:mdFileID",
                value: "*"
            });
		}
		var parser = new Geo.Format.Filter();
		var filterString = parser.write(filter).xml;
		constraintString = OpenLayers.String.format(this._constraintTemplate, {
			filter: filterString
		});
		return constraintString;
	},
	
	CLASS_NAME: "Geo.Query.CatalogQuery"
});

/**
 * 继承并修改自Geo.Format.CSWGetRecords.v2_0_2类，
 * 增加对CSW2.0.0以及国家资源目录标准的支持。
 */
Geo.Format.CSWGetRecords.v2_0_0 = Geo.Class(Geo.Format.CSWGetRecords.v2_0_2, {

    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        csw: "http://www.opengis.net/cat/csw",
        dc: "http://purl.org/dc/elements/1.1/",
        dct: "http://purl.org/dc/terms/",
        ows: "http://www.opengis.net/ows",
		geoglobe: "http://www.geostar.com.cn/geoglobe",
		smmd: "http://data.sbsm.gov.cn/smmd/2007"
    },

    version: "2.0.0",
	
    schemaLocation: "http://www.opengis.net/cat/csw http://schemas.opengis.net/csw/CSW-discovery.xsd",

    readers: {
        "csw": {
            "GetRecordsResponse": function(node, obj) {
                obj.records = [];
                this.readChildNodes(node, obj);
                var version = this.getAttributeNS(node, "", 'version');
                if (version != "") {
                    obj.version = version;
                }
            },
            "RequestId": function(node, obj) {
                obj.RequestId = this.getChildValue(node);
            },
            "SearchStatus": function(node, obj) {
                obj.SearchStatus = {};
                var timestamp = this.getAttributeNS(node, "", 'timestamp');
                if (timestamp != "") {
                    obj.SearchStatus.timestamp = timestamp;
                }
            },
            "SearchResults": function(node, obj) {
                this.readChildNodes(node, obj);
                var attrs = node.attributes;
                var SearchResults = {};
                for(var i=0, len=attrs.length; i<len; ++i) {
                    if ((attrs[i].name == "numberOfRecordsMatched") ||
                        (attrs[i].name == "numberOfRecordsReturned") ||
                        (attrs[i].name == "nextRecord")) {
                        SearchResults[attrs[i].name] = parseInt(attrs[i].nodeValue);
                    } else {
                        SearchResults[attrs[i].name] = attrs[i].nodeValue;
                    }
                }
                obj.SearchResults = SearchResults;
            }
        },
        "dc": {
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(Geo.Util.isArray(obj[name]))) {
                    obj[name] = new Array();
                }
                var dc_element = {};
                var attrs = node.attributes;
                for(var i=0, len=attrs.length; i<len; ++i) {
                    dc_element[attrs[i].name] = attrs[i].nodeValue;
                }
                dc_element.value = this.getChildValue(node);
                obj[name].push(dc_element);
            }
        },
        "dct": {
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(Geo.Util.isArray(obj[name]))) {
                    obj[name] = new Array();
                }
                obj[name].push(this.getChildValue(node));
            }
        },
        "ows": {
            "WGS84BoundingBox": function(node, obj) {
                if (!(Geo.Util.isArray(obj.BoundingBox))) {
                    obj.BoundingBox = new Array();
                }
                var lc = this.getChildValue(
                    this.getElementsByTagNameNS(
                        node,
                        this.namespaces["ows"],
                        "LowerCorner"
                    )[0]
                ).split(' ', 2);
                var uc = this.getChildValue(
                    this.getElementsByTagNameNS(
                        node,
                        this.namespaces["ows"],
                        "UpperCorner"
                    )[0]
                ).split(' ', 2);

                var boundingBox = {
                    value: [
                        parseFloat(lc[0]),
                        parseFloat(lc[1]),
                        parseFloat(uc[0]),
                        parseFloat(uc[1])
                    ]
                };
                var attrs = node.attributes;
                for(var i=0, len=attrs.length; i<len; ++i) {
                    boundingBox[attrs[i].name] = attrs[i].nodeValue;
                }
                obj.BoundingBox.push(boundingBox);
            },

            "BoundingBox": function(node, obj) {
                this.readers['ows']['WGS84BoundingBox'].apply(this, [node, obj]);
            }
        },
		
		//增加自定义记录类型
		"geoglobe": {
			"ResourceType": function(node, obj){
				var record = {type: "ResourceType"};
                this.readChildNodes(node, record);
                obj.records.push(record);
				
			},
			"*": function(node, obj){
				var name = node.localName || node.nodeName.split(":").pop();
                obj[name] = this.getChildValue(node);
			}
		},
		"smmd": {
			"Metadata": function(node, obj){
				var record = {type: "Metadata"};
                this.readChildNodes(node, record);
                obj.records.push(record);
			},
			"*": function(node, obj){
				var name = node.localName || node.nodeName.split(":").pop();
                obj[name] = this.getChildValue(node);
			}
		}
    },

	CLASS_NAME: "OpenLayers.Format.CSWGetRecords.v2_0_0" 
});/**
 * Class: Geo.Query.ModelQuery
 * 三维地图模型服务查询类。
 * 本类支持：1.鼠标点击模型查询模型信息;2.根据矩形范围查询模型信息。
 */
Geo.Query.ModelQuery = Geo.Class({
	
    /**
     * Property: url
     * {String} 服务地址。
     */
//	url: null,
	
    /**
     * APIProperty: maxFeatures
     * {Number} 最大结果数。
     */	
	maxFeatures: 10,

    /**
     * APIProperty: format
     * {<Geo.Format>} 用于对查询操作返回结果进行解析的格式解析器，默认为XML解析器。
     */
	format: null,
    
    /**
     * APIProperty: modelLayer
     * {<Geo.View3d.Layer.ModelLayer>} 查询的模型图层对象。
     */
    modelLayer : null,
    
    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 三维地图对象。 
     */
    map : null,
    
    /**
     * APIProperty: enumLayerPropertyName
     * <Object>} 图层属性对象。
     */
	enumLayerPropertyName :
	{
		layerName : 0,
		layerVisible : 1,
		layerTransparency : 2,
		layerFullEnvelope : 3,
		wmslayerInfo : 4,
		wmtslayerInfo : 5,
		EnableSelection : 6
	},
	/**
	 * Constructor: Geo.Query.ModelQuery
	 * Geo.Query.ModelQuery类构造函数。
	 * 
	 * Parameters:
	 * options - {Object} 相关属性的设置项，可选。
	 */	
	initialize: function(modelLayer,options){
		//this.url = url;
		this.modelLayer = modelLayer;
		this.format = new Geo.Util.Format.XML2JSON();
		OpenLayers.Util.extend(this, options);
	},

	/**
	 * APIMethod: query
	 * 开始查询。
	 * 
	 * Parameters:
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
	 * (end)
	 */
	query: function(successFn,failFn){
		if(this.modelLayer == null){
			return;
		}
		var map = this.modelLayer.map;
		var globe = map.activexObj; 
		//打开SelectionBox的选择功能，打开图层的选择功能
		globe.SelectionBox.EnableSelection = true;
		var layerOp = globe.LayerBox.CreateLayerOperate(this.modelLayer._layerData);
		layerOp.ChangeLayerProperty(this.enumLayerPropertyName.EnableSelection, true);
		//监听鼠标事件,在鼠标事件中执行选择命令
		var querySuccessFn = successFn || this.successFn;
		var queryFailFn = failFn || this.failFn;
		this.queryHandler = OpenLayers.Function.bind(function(eventObj,successFn,failFn){
	        this._queryHandler(eventObj,querySuccessFn,queryFailFn);
	    }, this);
		//调用SelectionBox的选择方法,输入参数是屏幕坐标
	//	globe.attachEvent("OnMouseEvent", this.queryHandler);
		if (globe.addEventListener){
			globe.addEventListener("MouseEvent",this.queryHandler,false);      
		}else if (globe.attachEvent){
			globe.attachEvent("OnMouseEvent",this.queryHandler);        
		}	
	},
	
	//点击查询
	 _queryHandler : function(e,successFn,failFn){
    	var map = this.modelLayer.map;
		var globe = map.activexObj; 
		//监听鼠标单击事件
		if(e.MouseButton === 1 && e.MouseState === 0){
			globe.SelectionBox.SelectByScreenPoint(e.ScreenX, e.ScreenY);
			if(!e){
				failFn();
				return;
			}
			//alert(""+e.ScreenX+","+ e.ScreenY);
			//获取选中的模型ID,根据选择集中的索引，获取模型ID
			var modelId = globe.SelectionBox.QuerySelectedID(0);
			if(globe.SelectionBox.Count == 0){
				return;
			}
			//创建一个请求属性数据的对象
			var AttributeOperater = globe.ObjectFactory.CreateObjectFromParameter("eGMDLAttributeOperater", "");
			var strAtt = AttributeOperater.QueryAttributeFromServerID(this.modelLayer.url, modelId);
			var attXml = this.format.read(strAtt);
			if(attXml){
				var feature = attXml.Feature;
				if(feature){
					var x = feature.X ? feature.X : "";
					var y = feature.Y ? feature.Y : "";
					var z = feature.Z ? feature.Z : "";
					var minX = feature.GEOSTAR_MIN_X ? feature.GEOSTAR_MIN_X : "";
					var minY = feature.GEOSTAR_MIN_Y ? feature.GEOSTAR_MIN_Y : "";
					var maxX = feature.GEOSTAR_MAX_X ? feature.GEOSTAR_MAX_X : "";
					var maxY = feature.GEOSTAR_MAX_X ? feature.GEOSTAR_MAX_X : "";
					var name = feature.NAME ? feature.NAME :"";
					var featureObject = {
						longitude: null,
			            latitude: null,
			            altitude: null,
			            name: null,
			            bounds: null
					}; 
					featureObject.longitude = x;
					featureObject.latitude = y;
					featureObject.altitude = z;
					featureObject.name = name;
					featureObject.bounds = new Geo.Bounds(minX, minY, maxX, maxY);
					//调用回调函数
					successFn(featureObject);
				}
			}
		}
    },
    /**
     * 删除查询模型监听 
     */
    removeQuery: function(){
    	var map = this.modelLayer.map;
    	var globe = map.activexObj; 
	//	globe.detachEvent("OnMouseEvent", this.queryHandler);
		if (globe.removeEventListener){
			globe.removeEventListener("MouseEvent",this.queryHandler,false);      
		}else if (globe.detachEvent){
			globe.detachEvent("OnMouseEvent",this.queryHandler);        
		}	
    },
    
	CLASS_NAME: "Geo.Query.ModelQuery"
});
/**
 * Class: Geo.Query.MapServiceQuery
 * MapService服务查询类，可以查询指定图层或表的要素结果，支持几何查询和属性查询两种方式.
 */
Geo.Query.MapServiceQuery = Geo.Class({
	
	/**
	 *  APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceQuery
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可设置的参数
	 */	
	initialize: function(url,options){
		var location = url.indexOf("/",url.length - 1);
		if(location != -1) {
			this.url = url + "query";
		}else {
			this.url = url + "/" + "query";
		}
		var format = new Geo.Util.Format.MapServiceQuery();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceQueryParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 *      (code)
	 *      例如：
	 *      var url = "http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer/1";
 	 *     	var queryObj = new Geo.Query.MapServiceQuery(url);
	 *		var params = new Geo.Query.MapServiceQueryParameters();
	 *		params.where="STATE_NAME='Florida'",
	 *		params.geometry=new Geo.Bounds(-180,-90,180,90),
	 *		params.spatialRel="esriSpatialRelEnvelopeIntersects",
	 *		params.inSR="4326",
	 *		params.outSR="4326"
	 *		queryObj.query(params,function(result) {
	 *			vectorLayer.addFeatures(result.features);	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json",
			pretty:true
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    );
		this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
			var failFn = failFn || this.failFn;
			if(result.error) {
				failFn(result.error);
				return;
			}
			var features = this.jsonp.format.read(result);
			var queryResult =  new Geo.Query.MapServiceQueryResult();
			queryResult.features = features;
			queryResult.displayFieldName = result["displayFieldName"];
			queryResult.fieldAliases = result["fieldAliases"];
			queryResult.geometryType = result["geometryType"];
			queryResult.spatialReference = result["spatialReference"];
			successFn(queryResult);
		},this));

	},
	
	queryForIds: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json",
			returnIdsOnly:true,
			pretty:true
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    );
		this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
			var queryResult = {
				objectIdFieldName:result["objectIdFieldName"],
				objectIds:result["objectIds"]
			}
			successFn(queryResult);
		},this));
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			if(params.serviceType == "ArcgisRest") {
				params.geometryType = "esri" + this._getGeometryType(params.geometry);
			}else {
				params.geometryType = this._getGeometryType(params.geometry);
			}
			params.geometry = this._getGeometryRepresentation(params.geometry);//this.jsonp.format._getGeometryRepresentation
		}
		
		if(params.timeExtent) {
			if(params.timeExtent.startTime instanceof Date && params.timeExtent.endTime instanceof Date) {
				var startTime = Date.parse(params.timeExtent.startTime);
				var endTime = Date.parse(params.timeExtent.endTime);
				params.time = startTime + "," + endTime;
				delete params.timeExtent;
			}
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = OpenLayers.Format.JSON.prototype.write.apply(this.jsonp.format,
                                                              [jsonObj]);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = OpenLayers.Format.JSON.prototype.write.apply(this.jsonp.format,
                                                              [jsonObj]);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	/**
	 * APIMethod: failFn
	 * 查询失败响应方法，默认提示"对不起,查询失败,请查询服务是否正常"，用户可以根据需要覆盖此方法。
	 */
	failFn: function(error){
		alert("对不起,查询失败,请查询服务是否正常。");
    },

	CLASS_NAME: "Geo.Query.MapServiceQuery"
});/**
 * Class: Geo.Query.MapServiceQueryParameters
 * 本对象支持服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest
 */
Geo.Query.MapServiceQueryParameters = Geo.Class({
	
	/**
	 * APIProperty: serviceType
	 * 服务类型，默认值：MapserviceRest
	 * 可供选择的值：MapserviceRest，ArcgisRest
	 * 其中MapserviceRest表示OGC 地图服务查询接口，
	 * ArcgisRest表示Arcgis地图服务查询接口
	 * 
	 */
	serviceType:"MapserviceRest",

	/**
	 * APIProperty: geometry
	 * {<Geo.Bounds> || <Geo.Geometry>}geometry} 作为空间过滤条件。
	 * 如果要使用空间范围作为查询条件则使用本属性，如果不需要空间范围作为条件则本属性可忽略。
	 * 本属性支持的服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest
	 * 本属性支持的Geo.Geometry类型包括：
	 * Geo.Geometry.Point,Geo.Geometry.MultiPoint,Geo.Geometry.MultiLineString,Geo.Geometry.Polygon
	 * 其他Geo.Geometry类型不支持。
	 */
	geometry:null,
	
	/**
	 * APIProperty: objectIds
	 * {String} 
	 * 查询的要素ID。默认可不填。取值举例：objectIds:"1,2",本属性就像一个过滤器，会过滤掉要素id不为1或2的要素。
	 * 
	 */
	objectIds:null,
	
	/**
	 * APIProperty: orderByFields
	 * {Array(String)} 查询排序字段。Arcgis 10.1 以后才支持。默认可不填。
	 */
	orderByFields:null,
	
	/**
	 * APIProperty: outFields
	 *  {Array(String)} 输出字段。如果不需要定制输出的字段，默认可不填。
	 */
	outFields:null,
	
	/**
	 * APIProperty: inSR
	 * {Integer} 输入几何对象的投影类型编号。不填则按服务默认的投影类型解析geometry参数
	 */
	inSR:null,
	
	/**
	 * APIProperty: outSR
	 * {Integer} 输出几何对象的投影类型编号。不填则按服务默认的投影类型输出结果
	 */
	outSR:null,
	
	/**
	 * APIProperty: maxAllowableOffset
	 *  定义Find操作返回的几何对象的最大允许偏移值。本属性主要用于对线和面进行抽稀
	 *  maxAllowableOffset的单位与空间参考单位一致。
	 *  如果sr值未定义，maxAllowableOffset的单位与地图的空间参考单位一致。
	 *  如：maxAllowableOffset=2
	 */
	maxAllowableOffset: null,
	
	/**
	 * APIProperty: returnGeometry
	 * 	{Boolean} 返回结果中是否包含几何信息。不填则服务默认其值为true
	 */
	returnGeometry:null,
	
	/**
	 * APIProperty: spatialRelationship
	 * {String} 空间查询条件。不填则默认值为"SpatialRelIntersects"。
	 */
	spatialRel:null,
	
	/**
	 * APIProperty: timeExtent
	 * {Object} 请求指定时间段内的瓦片。默认可不填
	 */
	timeExtent:null,
	
	/**
	 * APIProperty: where
	 * {String} 属性查询条件，sql语句格式
	 */
	where:null,
	
	/**
	 * APIProperty: text
	 * {String} 根据服务的displayField字段进行查询；
	 *  value参数是对where <displayField> like '%<text>%' 的where子句的速记。
	 *  文本是区分大小写的。如果指定了where参数，该参数会被忽略。
	 */
	text:null,
	
	/**
	 * Constructor: Geo.Query.MapServiceQueryParameters
	 * 构造函数。
	 * 
	 */	
	initialize: function(options){
		OpenLayers.Util.extend(this, options);
	}
});
/**
 * Class: Geo.Query.MapServiceQueryResult
 * Geo.Query.MapServiceQuery 地图服务查询类结果操作对象。本对象支持服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest
 * 说明：地名服务查询对象调用query方法进入成功回调后，回调函数返回的就是本对象。
 */
Geo.Query.MapServiceQueryResult = Geo.Class({
	/**
     * APIProperty: displayFieldName
     * {String} 字段名称：
     */
	displayFieldName:null,
	
	/**
	 * APIProperty: features
	 * Array({<Geo.Feature.Vector>}) 要素对象集合
	 */
	features:null,
	
	/**
     * APIProperty: fieldAliases
     * {String} 字段别名
     */
	fieldAliases:null,
	
	/**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */
	geometryType:null,
	
	/**
     * APIProperty: spatialReference
     * {String} 空间参考
     */
	spatialReference:null,
	
	/**
	 * Constructor: Geo.Query.MapServiceQueryResult
	 * 构造函数。
	 * 
	 */	
	initialize: function(options){
		OpenLayers.Util.extend(this, options);
	}
});
/**
 * Class: Geo.Query.MapServiceIdentify
 * MapService服务空间查询类，以空间关系做查询条件进行要素查询。
 */
Geo.Query.MapServiceIdentify = Geo.Class({
	
    /**
	 * APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceIdentify
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可用参数
	 */	
	initialize: function(url,options){
		this.url = url + "/identify";
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceIdentifyParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。 	
	 *      (code)
	 *      例如：
 	 *     	var queryObj = new Geo.Query.MapServiceIdentify("http://192.168.42.75:7777/wkDT/MapServer/identify");
	 *		var params = new Geo.Query.MapServiceIdentifyParameters();
	 *		params.geometryType = "GeometryEnvelope",
	 *		params.layers = "all:4",
	 *		params.geometry = "75,10,130,50",
	 *		params.imageDisplay = "600,550,96",
	 *		queryObj.query(params,function(result) {
	 *			for(var i = 0,len = result.length; i < len; i++){
	 *	    		vectorLayer.addFeatures(result[i].feature);
	 *	    	}	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json"
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    )
	    this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
	    	if(result.error) {
				if(failFn){
					failFn(result.error);
	    		}
				return;
			}
			var results = this._getResult(result);
			successFn(results);
		},this));
	},
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */	
	_getResult : function(result){
		var results = [];
		if(result.results) {
			for(var i = 0,j = result.results.length; i < j; i++) {
				var olGeometry = this._getGeometry(result.results[i].geometry);
				var attributes = this._getAttribute(result.results[i].attributes);
				var feature = new OpenLayers.Feature.Vector(olGeometry,attributes);
				var identifyResult = new Geo.Query.MapServiceIdentifyResult();
				identifyResult.layerId = result.results[i].layerId;
				identifyResult.layerName = result.results[i].layerName;
				identifyResult.displayFieldName = result.results[i].displayFieldName;
				identifyResult.feature = feature;
				identifyResult.geometryType = result.results[i].geometryType;
				results.push(identifyResult);
			}
		}
		return results;
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			params.geometry = this._getGeometryRepresentation(params.geometry);
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		if(params.geometryType && params.serviceType == "ArcgisRest") {
			params.geometryType = "esri" + this._getGeometryType(params.geometry);
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */	
	_getJson: function(result) {
		var resultObj = this.format.read(result.responseText);
		return resultObj;
	},
	
	/**
	 * Method: 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},

	/**
	 * Method: 得到要素的属性信息
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(Geo.Util.isArray(attrs))) {
			attrs = [attrs];
		}
		if(Geo.Util.isArray(attrs)) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	CLASS_NAME: "Geo.Query.MapServiceIdentify"
});
/**
 * Class: Geo.Query.MapServiceIdentifyParameters
 * Identify空间查询参数，rest服务的空间查询参数。本对象须结合Geo.Query.MapServiceIdentify对象使用，Geo.Query.MapServiceIdentify对象的query方法的第一个参数传入是本对象。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceIdentifyParameters = Geo.Class({
	
    /**
     * APIProperty: geometry
     * {<Geo.Geometry>} Geo.Geometry对象。
     */
	geometry: null,
	
    /**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */	
	geometryType: "",
	
    /**
     * APIProperty: layers
     * {String} 执行Identify操作的图层 有三种方式定义哪 些图层执行Identify操作：
	 * top:仅指定位置最上层的图层。
	 * visible:在指定位置的所有可见图层。
	 * all:在指定位置的所有图层。
	 * 缺省为"top"即最顶层图层。如：layers= visible:2,5。
     */	
	layers: "",
	
    /**
     * APIProperty: imageDisplay
     * {<Geo.Filter>} 地图的屏幕图像显示参数（width, height和 dpi）。mapExtent和imageDisplay参数由服务用于决定当前范围的图层可见性。它们也用于计算地图上的基于屏幕像素值的搜索距离容差。如：imageDisplay=600,550,96。
     */
	imageDisplay: "",
    
    /**
     * APIProperty: returnGeometry
     * {String} 如果为true，结果集中包含每个结果相关的几何对象，缺省为“true” 。如：returnGeometry=false。
     */
    returnGeometry: true,	
    /**
     * APIProperty: layerDefs
     * {String} 附加参数，允许在地图输出中分别对各个图层进行条件过滤，通过对这些图层指定表达方式的方式。每个图层的过滤器表达示应用于选择显示在地图中的图层的相关要素。如：0:POP2000 > 1000000;5:AREA > 100000 (文本形式){"0":"POP2000 > 1000000","5":"AREA > 100000"} (JSON形式)。
     */	
	layerDefs: "",
	
	/**
	 * Constructor: Geo.Query.MapServiceIdentifyParameters
	 * 构造函数。
	 */	
	initialize: function(){
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceIdentifyParameters"
});
/**
 * Class: Geo.Query.MapServiceIdentifyResult
 * Identify空间查询结果操作对象。本对象须结合Geo.Query.MapServiceIdentify对象使用，Geo.Query.MapServiceIdentify对象的query方法的第二个参数返回的结果。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceIdentifyResult = Geo.Class({
	
    /**
     * APIProperty: layerId
     * {Number} 图层ID。
     */
	layerId: null,
	
    /**
     * APIProperty: layerName
     * {String} 图层名称
     */	
	layerName: "",
	
    /**
     * APIProperty: displayFieldName
     * {String} 字段名称：
     */	
	displayFieldName: "",
	
    /**
     * APIProperty: feature
     * {<Geo.Feature.Vector>} 要素对象
     */
	feature: null,
	
	 /**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */	
	geometryType: "",
	
	/**
	 * Constructor: Geo.Query.MapServiceIdentifyResult
	 * 构造函数。
	 */	
	initialize: function(){
	},
    
    	
	CLASS_NAME: "Geo.Query.MapServiceIdentifyResult"
});
/**
 * Class: Geo.Query.MapServiceDataFeatures
 * MapService服务要素查询，查询指定图层中的单个要素信息。
 */
Geo.Query.MapServiceDataFeatures = Geo.Class({
	
   /**
	 * APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceDataFeatures
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可用参数
	 */	
	initialize: function(url,options){
		this.url = url;
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceDataFeaturesParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 *      (code)
	 *      例如：
 	 *     	var queryObj = new Geo.Query.MapServiceDataFeatures("http://192.168.42.75:7777/wkDT/MapServer");
	 *		var params = new Geo.Query.MapServiceDataFeaturesParameters();
	 *		params.layerOrTableId="4",
	 *		params.featureId="3",
	 *		queryObj.query(params,function(result) {
	 *			vectorLayer.addFeatures(result.feature);	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		if(!queryParameter.layerOrTableId){
			return;
		}
		if(!queryParameter.featureId){
			return;
		}
		this.accessUrl = this.url + "/" + queryParameter.layerOrTableId + "/" + queryParameter.featureId;
		var DEFAULT_PARAMS = {
			f:"json"
		}
		var params = queryParameter;
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    )
	    this.jsonp.createRequest(this.accessUrl,params, OpenLayers.Function.bind(function(result){
	    	if(result.error) {
				if(failFn){
					failFn(result.error);
	    		}
				return;
			}
			var feature = null;
			var featuresResult = new Geo.Query.MapServiceDataFeaturesResult();
			if(result.feature.geometry){
				feature = this._getFeatures(result);
			}
			featuresResult.feature = feature;
			successFn(featuresResult);
		},this));
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			params.geometry = this._getGeometryRepresentation(params.geometry);
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		if(params.geometryType && params.serviceType == "ArcgisRest") {
			params.geometryType = "esri" + this._getGeometryType(params.geometry);
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */
	_getJson: function(result) {
		var resultObj = this.format.read(result.responseText);
		return resultObj;
	},
	
	/**
	 * Method: 获取查询结果的要素
	 * 
	 * Parameters:
	 * {Object} result
	 */
	_getFeatures:function(result) {
		var feature = null;
		if(result.feature) {
			var olGeometry = this._getGeometry(result.feature.geometry);
			var attributes = this._getAttribute(result.feature.attributes);
			var f = new OpenLayers.Feature.Vector(olGeometry,attributes);
			feature = f;
		}
		return feature;
	},
	
	/**
	 * Method: 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: 得到要素的属性信息
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(Geo.Util.isArray(attrs))) {
			attrs = [attrs];
		}
		if(Geo.Util.isArray(attrs)) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceDataFeatures"
});
/**
 * Class: Geo.Query.MapServiceDataFeaturesParameters
 * DataFeatures要素查询参数，rest服务的地图服务要素查询参数。本对象须结合Geo.Query.MapServiceDataFeatures对象使用，Geo.Query.MapServiceDataFeatures对象的query方法的第一个参数传入是本对象。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceDataFeaturesParameters = Geo.Class({
	
    /**
     * APIProperty: layerOrTableId
     * {Number} 图层或表 id。
     */
	layerOrTableId: 0,
	
    /**
     * APIProperty: featureId
     * {Number} 要素id
     */	
	featureId: 0,
	
	/**
	 * Constructor: Geo.Query.MapServiceDataFeaturesParameters
	 * 构造函数。
	 */	
	initialize: function(){
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceDataFeaturesParameters"
});
/**
 * Class: Geo.Query.MapServiceDataFeaturesResult
 * DataFeatures要素查询结果操作对象。本对象须结合Geo.Query.MapServiceDataFeatures对象使用，Geo.Query.MapServiceDataFeatures对象的query方法的第二个参数返回的结果。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceDataFeaturesResult = Geo.Class({
	
	 /**
     * APIProperty: feature
     * {<Geo.Vector.Feature>} 要素对象
     */
	feature: null,
	/**
	 * Constructor: Geo.Query.MapServiceDataFeaturesResult
	 * 构造函数。
	 */	
	initialize: function(){
	},
     	
	CLASS_NAME: "Geo.Query.MapServiceDataFeaturesResult"
});/**
 * Class: Geo.Query.MapServiceFind
 * MapService服务搜索类，在一或多个图层中，查询搜索指定文本。
 */
Geo.Query.MapServiceFind = Geo.Class({
	
   /**
	 * APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceFind
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可用参数
	 */	
	initialize: function(url,options){
		this.url = url + "/find";
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceFindParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 *      (code)
	 *      例如：
 	 *     	var queryObj = new Geo.Query.MapServiceFind("http://192.168.42.75:7777/wkDT/MapServer/find");
	 *		var params = new Geo.Query.MapServiceFindParameters();
	 *		params.searchText = "1";
	 *		params.searchFields = "NAME";
	 * 		params.layers = "0,1,2,4";
	 *		params.returnGeometry = "true";
	 *		queryObj.query(params,function(result) {
	 *		    for(var i = 0,len = result.length; i < len; i++){
	 *	    		vectorLayer.addFeatures(result[i].feature);
	 *	    	}	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json",
			pretty:true
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    )
	    this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
	    	if(result.error) {
				if(failFn){
					failFn(result.error);
	    		}
				return;
			}
			var results = this._getResult(result);
			successFn(results);
		},this));
	},
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */
	_getResult : function(result){
		var results = [];
		if(result.results) {
			for(var i = 0,j = result.results.length; i < j; i++) {
				var olGeometry = this._getGeometry(result.results[i].geometry);
				var attributes = this._getAttribute(result.results[i].attributes);
				var feature = new OpenLayers.Feature.Vector(olGeometry,attributes);
				var identifyResult = new Geo.Query.MapServiceIdentifyResult();
				identifyResult.layerId = result.results[i].layerId;
				identifyResult.layerName = result.results[i].layerName;
				identifyResult.displayFieldName = result.results[i].displayFieldName;
				identifyResult.feature = feature;
				identifyResult.geometryType = result.results[i].geometryType;
				identifyResult.foundFieldName = result.results[i].foundFieldName;
				results.push(identifyResult);
			}
		}
		return results;
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			params.geometry = this._getGeometryRepresentation(params.geometry);
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		if(params.geometryType && params.serviceType == "ArcgisRest") {
			params.geometryType = "esri" + this._getGeometryType(params.geometry);
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: 得到要素的属性信息
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(Geo.Util.isArray(attrs))) {
			attrs = [attrs];
		}
		if(Geo.Util.isArray(attrs)) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	CLASS_NAME: "Geo.Query.MapServiceFind"
});
/**
 * Class: Geo.Query.MapServiceFindParameters
 * Find搜索参数，rest服务的搜索参数。本对象须结合Geo.Query.MapServiceFind对象使用，Geo.Query.MapServiceFind对象的query方法的第一个参数传入的是本对象。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceFindParameters = Geo.Class({
	
    /**
     * APIProperty: searchText
     * {String} 搜索文本。本参数值是跨图层和用户指定字段的文本。如：searchText=Los.
     */
	searchText: "",
	
    /**
     * APIProperty: contains
     * {Boolean} 输出数据格式，缺省为“true” 。如：contains=false
     */	
	contains: true,
	
	/**
     * APIProperty: searchFields
     * {String} 要搜索的字段的名称。字段以一个逗号分隔的图层资源中返回的字段列表的形式定义，缺省搜索多个字段。如：searchFields=AREANAME,SUB_REGION
     */	
	searchFields: "",
	
	/**
     * APIProperty: layers
     * {String} 执行Find操作的多个图层。以逗号分隔的地图服务根资源中返回的图层ID列表指定。如：layers=2,4,7
     */	
	layers: "",
	
	/**
     * APIProperty: returnGeometry
     * {Boolean} 如果为true，结果集包含每个结果相关的几何对象，缺省为“true”。如：returnGeometry=false
     */	
	returnGeometry: true,
	
	/**
	 * Constructor: Geo.Query.MapServiceFindParameters
	 * 构造函数。
	 */	
	initialize: function(){
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceFindParameters"
});
/**
 * Class: Geo.Query.MapServiceFindResult
 * Find文本搜索结果操作对象。本对象须结合Geo.Query.MapServiceFind对象使用，Geo.Query.MapServiceFind对象的query方法的第二个参数返回的结果。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceFindResult = Geo.Class({
	
    /**
     * APIProperty: layerId
     * {Number} 图层ID。
     */
	layerId: null,
	
    /**
     * APIProperty: layerName
     * {String} 图层名称
     */	
	layerName: "",
	
    /**
     * APIProperty: displayFieldName
     * {String} 字段名称：
     */	
	displayFieldName: "",
	
    /**
     * APIProperty: feature
     * {Geo.Vector.Feature} 要素对象
     */
	feature: null,
	
	 /**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */	
	geometryType: "",
	
	 /**
     * APIProperty: foundFieldName
     * {String} 查找的字段名称
     */
	foundFieldName: "",
	
	/**
	 * Constructor: Geo.Query.MapServiceFindResult
	 * 构造函数。
	 */	
	initialize: function(){
	},
    
    	
	CLASS_NAME: "Geo.Query.MapServiceFindResult"
});
/**
 * Class: Geo.Query.GeoCodingQuery
 * 地址匹配查询类。默认版本是1.0.0。
 *
 * 例子:
 * (code)
 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
 *			version:"1.1.0"
 *		});
 * (end)
 */
Geo.Query.GeoCodingQuery = function(url, options) {
    options = OpenLayers.Util.applyDefaults(
        options, Geo.Query.GeoCodingQuery.DEFAULTS
    );
    var cls = Geo.Query.GeoCodingQuery["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "不支持的地址匹配服务版本: " + options.version;
    }
    return new cls(url, options);
};

Geo.Query.GeoCodingQuery.DEFAULTS = {
    "version": "1.0.0"
};/**
 * Class: Geo.Query.GeoCodingQuery.v1
 * 地址匹配服务查询接口的抽象类,抽象类不能实例化。
 */
Geo.Query.GeoCodingQuery.v1 = Geo.Class({
	
	/**
	 * APIProperty: version
	 * 服务版本，默认值是"1.0.0"。
	 */
	version:"1.0.0",
	
	/**
     * APIProperty: url
     * {String}服务地址。
     */
	url: null,
	
	/**
     * Constructor: Geo.Query.GeoCodingQuery.v1
     * Geo.Query.GeoCodingQuery.v1类的构造函数。
     *
     * Parameters:
     * url - {String} 服务地址。
     * options - {Object} 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	initialize: function(url, options){
		this.url = url;
		OpenLayers.Util.extend(this,options);
		this.format = new Geo.Format.JSON();
	},
	
	/**
	 * Method: getCommonParams
	 * 获取公共的参数
	 * 
	 * Parameters:
	 * 	options
	 */
	getCommonParams: function(options) {
		var params = {
			request: "GetCategory",
			service:"GeoCoding",
			version:this.version,
			output:"json"
		};
		OpenLayers.Util.extend(params,options);
		return params;
	},
	
	/**
	 * APIMethod: getCategoryByName
	 * 根据类别名称查询类别及子类别。
	 * 
	 * Parameters:
	 * name - {String} 类别名称。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 */
	getCategoryByName:function(name,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof name === "string" && name.length !== 0) {
			params.categoryName = name;
		}
		var failFn = failFn || this.failFn;
		OpenLayers.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},

	/**
	 * APIMethod: getCategoryByCode
	 * 根据类别编码查询类别及子类别。
	 * 
	 * Parameters:
	 * code - {Number}类别编码。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * Example:
	 * (code)
	 *      //根据范围和地址进行查询：
	 * 		var coding = new Geo.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
	 * 		coding.getCategoryByCode(1012001008000000,
	 * 		function(GeoCoding){},function(){});
	 * (end)
	 */
	getCategoryByCode: function(code,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof code === "number") {
			params.categoryCode = code;
		}
		OpenLayers.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * APIMethod: getAllCategory
	 * 查询所有类别信息。
	 * 
	 * Parameters:
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 */
	getAllCategory: function(successFn,failFn) {
		var params = this.getCommonParams();
		OpenLayers.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * Method: _requestCategory
	 * 执行get请求操作
	 * 
	 * Parameters:
	 * 	params
	 *  successFn
	 *  failFn
	 */
	_requestCategory:function(params,successFn,failFn) {
		var failFn = failFn || this.failFn;
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var category = this.format.read(result.responseText);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(category);
		},failFn);
	},
	
	/**
	 * Method: _analysis_GeoCodeResult
	 * 解析返回的结果，getCoder接口查询结果第一级结构
	 * 
	 * Parameters:
	 * 	json
	 */
	_analysis_GeoCodeResult: function(json) {
		var queryResult = {
			status:json.status
		};
		switch(json.status) {
			case "OK":
				var results = json.results;
				if(results) {
					queryResult.results = this._analysis_GeoCodeResult_results(results);
				}
			break;
			case "INVALID_REQUEST":
				
			
			case "NO_RESULTS":
				
			
			case "UNKNOWN_ERROR":
				
			break;
		}
		return queryResult;
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results
	 * getCoder接口查询结果第二级结构
	 * 
	 * Parameters:
	 * 	results
	 */
	_analysis_GeoCodeResult_results: function(results) {
		var aresults = [];
		//如果存在results节点，那么它就是一个数组
		if(Geo.Util.isArray(results)) {
			for(var i = 0,j = results.length; i < j;i++) {
				var result = {};
				result.requestKeyWord = results[i].requestKeyWord;
				if(results[i].errorCorrectionTips) {
					result.errorCorrectionTips = results[i].errorCorrectionTips;
				}
				//匹配结果总数
				result.count = results[i].count;
				if(results[i].result) {
					result.result = this._analysis_GeoCodeResult_results_result(results[i].result);
				}
				aresults.push(result);
			}
			return aresults;
		}
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results
	 * getCoder接口查询结果第三级结构
	 * 
	 * Parameters:
	 * 	result
	 */
	_analysis_GeoCodeResult_results_result: function(result) {
		var addresss = [];
		for(var i = 0,j = result.length; i < j;i++) {
			var address = {};
			//匹配结果的类型
			address.resultType = result[i].resultType;
			//匹配地址是否为精确地址
			address.precise = result[i].precise;
			//该条匹配结果是否为摘要信息
			address.isBrief = result[i].isBrief;
			//匹配结果与请求关键字的匹配度，值域为1到100，值越大匹配度就越高
			address.score = result[i].score;
			if(address.isBrief == false) {
				address.addressComponent = this._analysis_GeoCodeResult_results_result_address(result[i].addressComponent,address.resultType);
			}
			address.poiArray = this._analysispoiArray(result[i].poiArray);
			if(result[i].location) {
				address.location = result[i].location;
			}
			//TODO:referenceAddressArray
			if(address.precise == 0) {
				address.referenceAddressArray = result[i].referenceAddressArray;
			}
			addresss.push(address);
		}
		return addresss;
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results_result_address
	 * getCoder接口查询结果第四级结构，当前匹配结果的地址详细信息
	 * 
	 * Parameters:
	 * 	addressComponent
	 *	resultType
	 */
	_analysis_GeoCodeResult_results_result_address:function(addressComponent,resultType) {
		var addressC = {
			country: addressComponent.country
		};
		//行政区划的第二级-省、直辖市、自治区
		if(addressComponent.province) {
			addressC.province = addressComponent.province;
		}
		//行政区划第三级-市
		if(addressComponent.city) {
			addressC.city = addressComponent.city;
		}
		//行政区划第四级-区或县
		if(addressComponent.district) {
			addressC.district = addressComponent.district;
		}
		//行政区划第五级-乡镇
		if(addressComponent.town) {
			addressC.town = addressComponent.town;
		}
		if(addressComponent.street) {
			addressC.street = {
				name:addressComponent.street.name
			};
			var streetGeometry = null;
			if(resultType === "street") {
				//TODO:需要增加对线的json串的解析
				if(addressComponent.street.geometry) {
					var sgeometry = addressComponent.street.geometry;//this.format.read(addressComponent.street.geometry);
				}
				
				if(sgeometry["paths"]) {
					//TODO:这个需要做测试，这里的几何信息一般来说是线，不过也有可能不是线
					streetGeometry = this._getGeometry(sgeometry);
					addressC.street.geometry = streetGeometry;
				}else if(sgeometry["rings"]){
					streetGeometry = this._getGeometry(sgeometry);
					addressC.street.geometry = streetGeometry;
				}else if(sgeometry["x"] && sgeometry["y"]){
					streetGeometry = this._getGeometry(sgeometry);
					addressC.street.geometry = streetGeometry;
				}
			}
		}
		if(addressComponent.streetNumber) {
			addressC.streetNumber = addressComponent.streetNumber;
		}
		if(addressComponent.buildingNumber) {
			addressC.buildingNumber = addressComponent.buildingNumber;
		}
		if(resultType === "adminArea") {
			//当前匹配最小级行政区划的空间信息,本属性需要被转换成Geo.Geometry类型
			var areaGeometry = null;
			if(addressComponent.geometry) {
				var geometry = addressComponent.geometry;//this.format.read(addressComponent.geometry);
				//如果它是面，我们解析它
				if(geometry["rings"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(geometry["paths"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(typeof geometry["x"] === "number" && typeof geometry["y"] === "number") {
					addressC.geometry = this._getGeometry(geometry);
				}
			}
			//当前匹配最小级行政区划下属的其它行政区划名称，多个以逗号隔开
			if(addressComponent.subordinate) {
				addressC.subordinate = addressComponent.subordinate;
			}
			//行政区的邮政编码
			if(addressComponent.zipCode) {
				addressC.zipCode = addressComponent.zipCode;
			}
			//电话长途区划
			if(addressComponent.callingCode) {
				addressC.callingCode = addressComponent.callingCode;
			}
		}
		return addressC;
	},
	
	/**
	 * Method: _analysispoiArray
	 * result节点的儿子节点
	 * 
	 * Parameters:
	 * 	poiArray
	 */
	_analysispoiArray: function(poiArray) {
		var pointFeatures = [];
		for(var i = 0,j = poiArray.length; i < j;i++) {
			var point = {};
			for(var pro in poiArray[i]) {
				point[pro] = poiArray[i][pro];
			}
			pointFeatures.push(point);
		}
		return pointFeatures;
	},
	
	/**
	 * Method: _analysisLocation
	 * result节点的儿子节点
	 * 
	 * Parameters:
	 * 	location
	 */
	_analysisLocation:function(location) {
		
	},
	
	/**
	 * Method: _getGeometry
	 * 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
				//TODO:需要增加多点类型
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: _geometryType
	 * 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	/**
     * APIProperty: failFn
     * {Function} 请求失败的回调函数，可以用自定义函数覆盖。
     */
	failFn: function(error) {
		if(typeof error == "string") {
			alert(error);
		}
		alert("对不起，查询请求失败！请检查地址匹配服务是否正常运行。\n" + 
				"当前服务地址为：" + this.url);
	},

	CLASS_NAME: "Geo.Query.GeoCodingQuery.v1" 
});/**
 * Class: Geo.Query.GeoCodingQuery.v1_0_0 
 * 地址匹配服务查询接口1.0.0版本，本类可以实现如下功能：
 * 
 * > 1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123和经度113.41321)或者执行反向转换。
 * > 2.根据地理坐标获取地址信息。
 * > 3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 * > 说明:本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，
 * > 表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *
 *	Inherits from:
 *  	- <Geo.Query.GeoCodingQuery.v1>
 */
Geo.Query.GeoCodingQuery.v1_0_0 = Geo.Class(Geo.Query.GeoCodingQuery.v1, {
	
	/**
     * Constructor: Geo.Query.GeoCodingQuery.v1_0_0
     * Geo.Query.GeoCodingQuery.v1_0_0类的构造函数。
     *
     * Parameters:
     * url - {String} 服务地址。
     * options - {Object} 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	
	/**
	 * APIMethod: addressesToLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * address - {String || Array(String)} (必选) 查询的地址名称集合。
	 * categoryCode - {Integer} (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<Geo.Bounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * fuzzyMatch - {Boolean} (可选) 是否模糊匹配，true表示精确匹配，false表示模糊匹配。默认值为false。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) ： 从第几条开始查询，缺省值是1。
	 * 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.addressesToLocations({
	 *			extent:Geo.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(typeof options.address === "string") {
			params.address = options.address;
		}else if(Geo.Util.isArray(options.address)) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.address = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = options.categoryCode;
		}
		if(options.extent instanceof Geo.Bounds) {
			params.bbox = options.extent.toBBOX(null,true);
		}
		if(typeof options.fuzzyMatch === "boolean") {
			params.fuzzyMatch = options.fuzzyMatch;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
		
	},
	
	/**
	 * APIMethod: locationToAddresses
	 * 根据位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * lonlat - {Geo.LonLat} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * 
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.locationToAddresses({
	 *			lonlat:new Geo.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(options.lonlat instanceof Geo.LonLat) {
			params.latlng = options.lonlat.lat+","+options.lonlat.lon;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "number") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
	},
	
	CLASS_NAME: "Geo.Query.GeoCodingQuery.v1_0_0" 
});/**
 * Class: Geo.Query.GeoCodingQuery.v1_1_0
 * 地址匹配服务查询接口1.1.0版本，本类可以实现如下功能：
 * 
 * > 1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123 和经度113.41321)或者执行反向转换。
 * > 2.根据地理坐标获取地址信息。
 * > 3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 * > 4.可以根据多个地址信息查询到地理坐标信息。
 * > 5.可以根据多个地理坐标值获取地址信息。
 * > 说明:本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，
 * > 表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *
 *	Inherits from:
 *  	- <Geo.Query.GeoCodingQuery.v1>
 */
Geo.Query.GeoCodingQuery.v1_1_0 = Geo.Class(Geo.Query.GeoCodingQuery.v1, {
	
	/**
	 * APIProperty: method
	 * 数据请求方式，默认值是"get"。
	 */
	method: "get",
	
	/**
     * Constructor: Geo.Query.GeoCodingQuery.v1_1_0
     * Geo.Query.GeoCodingQuery.v1_1_0类的构造函数。
     *
     * Parameters:
     * url - {String} 服务地址。
     * options - {Object} 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	initialize: function(url, options){
		OpenLayers.Util.extend(this,options);
		this.filterFormat = new OpenLayers.Format.Filter();
		Geo.Query.GeoCodingQuery.v1.prototype.initialize.apply(this, arguments);  
	},
	
	/**
	 * APIMethod: addressesToLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * address - {String|| Array(String)} (可选) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * categoryCode - {Integer} (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<Geo.Bounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * semanticAnalysis - {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * filter - {Geo.Filter}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。 
	 * 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.addressesToLocations({
	 *			extent:Geo.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = false;
		if(typeof options.address === "string") {
			params.keyword = options.address;
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = options.categoryCode;
		}
		if((options.address == undefined || options.address == null) && 
				(options.categoryCode == undefined || options.categoryCode == null)) {
			throw "address是必选参数！";
		}
		if(options.extent instanceof Geo.Bounds) {
			params.bbox = options.extent.toBBOX(null,true);
		}
		if(options.filter instanceof Geo.Filter) {
			var domFilter = this.filterFormat.write(options.filter);
			var filterStr = OpenLayers.Format.XML.prototype.write.apply(
				this.filterFormat, [domFilter]
			);
			params.filter = filterStr;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		if(typeof options.semanticAnalysis  === "boolean") {
			params.semanticAnalysis = options.semanticAnalysis;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		
	},
	
	/**
	 * Method: _getCodingRequest
	 * 
	 * Parameters:
	 * 	params {Object} 键值对
	 * 	successFn {Function} 成功回调
	 * 	failFn {Function} 失败回调
	 */
	_getCodingRequest: function(params,successFn,failFn) {
		if(this.method == "get") {
			OpenLayers.loadURL(this.url,params,this,function(result) {
				try{
					var json = this.format.read(result.responseText);
					var GeoCodingResult = this._analysis_GeoCodeResult(json);
				}catch(e) {
					successFn(result.responseText);
					return;
				}
				successFn(GeoCodingResult);
			},this.failFn);
		}else {
			var paramsStr = OpenLayers.Util.getParameterString(params);
			OpenLayers.Request.POST({
	            url: this.url,
	            data: paramsStr,
	            success: function(result) {
					try{
						var json = this.format.read(result.responseText);
						var GeoCodingResult = this._analysis_GeoCodeResult(json);
					}catch(e) {
						successFn(result.responseText);
						return;
					}
					successFn(GeoCodingResult);
				},
	            failure: this.failFn,
	            scope: this
	        });
		}
	},
	
	/**
	 * Method: _setGeoCoderCommonProperty
	 * 
	 * Parameters:
	 * 	params {Object} 键值对
	 * 	options
	 */
	_setGeoCoderCommonProperty: function(params,options) {
		if(typeof options.sortFields  === "string") {
			params.sortFields = options.sortFields;
		}
		if(typeof options.scoreFilter  === "string") {
			params.scoreFilter = options.scoreFilter;
		}
	},
	
	/**
	 * APIMethod: locationToAddresses
	 * 根据位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * lonlat - {Geo.LonLat} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * 
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.locationToAddresses({
	 *			lonlat:new Geo.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = true;
		if(options.lonlat instanceof Geo.LonLat) {
			params.keyword = options.lonlat.lat+","+options.lonlat.lon;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
	},
	
	/**
	 * APIMethod: batchAddressesToLocations
	 * 根据一到多个地址查询坐标位置信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * address - {Array(String)} (必选) 查询的地址名称集合。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * filter - {Geo.Filter}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95
	 * singleKeywordResultCount - {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 * 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchAddressesToLocations({
	 *			address:["小学"],
	 *			singleKeywordResultCount:2,
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	batchAddressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = false;
		if(Geo.Util.isArray(options.address)) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.keywords = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		if(options.filter instanceof Geo.Filter) {
			var domFilter = this.filterFormat.write(options.filter);
			var filterStr = OpenLayers.Format.XML.prototype.write.apply(
				this.filterFormat, [domFilter]
			);
			params.filter = filterStr;
		}
		this._setGeoCoderCommonProperty(params,options);
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
	},
	
	/**
	 * APIMethod: batchLocationToAddresses
	 * 根据多个坐标位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * lonlats - {Array(Geo.LonLat)} (必选) 坐标位置数组。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * singleKeywordResultCount - {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *   
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchLocationToAddresses({
	 *			lonlats:[new Geo.LonLat(123.43888042, 41.759929371),new Geo.LonLat(123.423848649, 41.771748608)],
	 *			singleKeywordResultCount:2,
	 *			tolerance:0.5,
	 *			unit:"degree",
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *
	 *		},function() {});
	 * (end)
	 */
	batchLocationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = true;
		if(options.lonlats instanceof Geo.LonLat) {
			options.lonlats = [options.lonlats];
		//	params.keywords = options.lonlat.lat+","+options.lonlat.lon;
		}else  if(!OpenLayers.Util.isArray(options.lonlats)) {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(Geo.Util.isArray(options.lonlats)) {
			var lonlatsStr = "";
			for(var i = 0; i < options.lonlats.length;i++) {
				lonlatsStr += options.lonlats[i].lat+","+options.lonlats[i].lon+";";
			}
			lonlatsStr = lonlatsStr.substr(0, lonlatsStr.length - 1);
			params.keywords = lonlatsStr;
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		this._setGeoCoderCommonProperty(params,options);
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
	},
	
	CLASS_NAME: "Geo.Query.GeoCodingQuery.v1_1_0" 
});/**
 * Class: Geo.Strategy.AttributeCluster
 * 基于要素属性的聚合策略。
 *
 * Inherits from:
 *  - <Geo.Strategy.Cluster>
 */
Geo.Strategy.AttributeCluster = Geo.Class(Geo.Strategy.Cluster, {
	
    /**
     * APIProperty: attributes
     * 用于比较的一组属性。
     */
    attributes: [],
	
    /**
     * Method: shouldCluster
     * 判断要素是否被包含在一个要素簇内。
     *
     * Parameters:
     * cluster - {<Geo.Feature.Vector>} 一个要素簇。
     * feature - {<Geo.Feature.Vector>} 一个要素。
     *
     * Returns:
     * {Boolean} 返回布尔值，表示要素是否被包含在一个要素簇内。
     */
    shouldCluster: function(cluster, feature){
		var bool = false;
        for (var i = 0; i < this.attributes.length; i++) {
            var attribute = this.attributes[i];
            var cc_attrval = cluster.cluster[0].attributes[attribute];
            var fc_attrval = feature.attributes[attribute];
            bool = (cc_attrval === fc_attrval);
			if(!bool){
				break;
			}
        }
		var superProto = Geo.Strategy.Cluster.prototype;
		return bool && superProto.shouldCluster.apply(this, arguments);
    },
	
    CLASS_NAME: "OpenLayers.Strategy.AttributeCluster"
});﻿﻿/**
 * Class: Geo.Strategy.GeoTextXYZ
 * >文字服务策略类，继承自策略基类Geo.Strategy。
 * >本类定义请求文字服务的方式，包括：
 * >1.当地图缩放的时候请求文字服务。
 * >2.当拖动地图超出一定范围时请求文字服务。
 * 
 *  Inherits from:
 *  - <Geo.Strategy>
 */
Geo.Strategy.GeoTextXYZ = OpenLayers.Class(OpenLayers.Strategy, {
    
    /**
     * Property: bounds
     * {<OpenLayers.Bounds>} 请求矢量数据的范围。
     */
    bounds: null,
    
    /** 
     * Property: resolution 
     * {Float} 地图当前的分辨率。
     */ 
    resolution: null,
	
    /**
     * APIProperty: ratio
     * {Number} 扩展范围与当前视野范围的比率。
     * 扩展范围是指：中心点和当前可视范围中心点相同，长、宽是当前可视范围长、宽1.5倍比率的区域。比率值由用户通过radio属性设置，默认值为1.5。
     */
    ratio: 1,
	
	/** 
     * Property: zoom 
     * {Float} 图层请求数据的级别。
     */
	zoom: 0,

    /** 
     * Property: resFactor 
     * {Float} 地图当前分辨率与地图前一次级别的分辨率的比值。
     */ 
    resFactor: null, 
    
    /**
     * Property: response
     * {<OpenLayers.Protocol.Response>} 协议类查询成功后返回的结果对象。
     */
    response: null,

    /**
     * Constructor: Geo.Strategy.GeoTextXYZ
     * 创建文字服务的策略类的实例。
     */
	
    /**
     * Method: activate
     * 激活策略对象。
     * 
     * Returns:
     * {Boolean} 如果成功激活，则返回true。
     */
    activate: function() {
        var activated = OpenLayers.Strategy.prototype.activate.call(this);
        if(activated) {
            this.layer.events.on({
                "moveend": this.update,
                "refresh": this.update,
                scope: this
            });
			this.layer.map.events.on({
	            "zoomend":function(){
					this.zoom = this.layer.map.getZoom();
					this.layer.removeFeatures();
				},
	            scope: this
	        });
			
			
            this.update();
        }
        return activated;
    },
    
    /**
     * Method: deactivate
     * 取消激活策略对象。
     * 
     * Returns:
     * {Boolean} 如果成功取消激活，则返回true。
     */
    deactivate: function() {
        var deactivated = OpenLayers.Strategy.prototype.deactivate.call(this);
        if(deactivated) {
            this.layer.events.un({
                "moveend": this.update,
                scope: this
            });
			this.layer.map.events.un({
				"zoomend":function(){
					this.layer.removeFeatures();
					this.start();
				},
	            scope: this
	        });
        }
        return deactivated;
    },

    /**
     * Method: update
     * 触发图层"moveend" 或者 "refresh"事件后执行本方法。
     *
     * Parameters:
     * options - {Object} 可选项。
     */
    update: function(options) {
		var mapZoom = this.layer.map.getZoom();
		var zoomChanged = false;
		if(mapZoom !== this.zoom) {
			zoomChanged = true
		}
		
			//延迟4秒关闭
			this.timerId1 = window.setTimeout(
	            OpenLayers.Function.bind(function() {
		        var mapBounds = this.getMapBounds();
		        if (mapBounds !== null && ((options && options.force) ||
		          (this.layer.visibility && this.layer.calculateInRange()&& this.invalidBounds(mapBounds) && !zoomChanged))) {
					//放大缩小的时候隐藏图层，查询到数据后再显示图层。
				    this.calculateBounds(mapBounds);
		            this.resolution = this.layer.map.getResolution(); 
		            this.triggerRead(options);
					//TODO:待完善
		        }else  if ( (options && options.force) ||
		          (this.layer.visibility && this.layer.calculateInRange() && zoomChanged === true)) {
				  		//清空线面键值对
						this.layer.formatFeatures.cleanCommonFeatures();
				  		this.layer.display(false);
						this.calculateBounds(mapBounds);	
						this.resolution = this.layer.map.getResolution(); 
			    		this.triggerRead(options);  
			         
				  }
	    }, this),
            1
        ); 
	},
    
    /**
     * Method: getMapBounds
     * 得到与图层相同投影的地图可视范围。
     *
     * Returns:
     * {<OpenLayers.Bounds>} 地图范围。
     */
    getMapBounds: function() {
        if (this.layer.map === null) {
            return null;
        }
        var bounds = this.layer.map.getExtent();
        if(bounds && !this.layer.projection.equals(
                this.layer.map.getProjectionObject())) {
            bounds = bounds.clone().transform(
                this.layer.map.getProjectionObject(), this.layer.projection
            );
        }
        return bounds;
    },

    /**
     * Method: invalidBounds
     * 地图当前范围是否超出查询定义的范围。
     *
     * Parameters:
     * mapBounds - {<OpenLayers.Bounds>} 地图可视范围。
     *
     * Returns:
     * {Boolean} 
     */
    invalidBounds: function(mapBounds) {
        if(!mapBounds) {
            mapBounds = this.getMapBounds();
        }
        var invalid = !this.bounds || !this.bounds.containsBounds(mapBounds);
        if(!invalid && this.resFactor) {
            var ratio = this.resolution / this.layer.map.getResolution();
            invalid = (ratio >= this.resFactor || ratio <= (1 / this.resFactor));
        }
        return invalid;
    },
 
    /**
     * Method: calculateBounds
     * 感觉地图范围计算当前请求数据的范围。
     * 
     * Parameters:
     * mapBounds - {<OpenLayers.Bounds>} 地图范围。
     */
    calculateBounds: function(mapBounds) {
        if(!mapBounds) {
            mapBounds = this.getMapBounds();
        }
        var center = mapBounds.getCenterLonLat();
        var dataWidth = mapBounds.getWidth() * this.ratio ;
        var dataHeight = mapBounds.getHeight() * this.ratio ;
        this.bounds = new OpenLayers.Bounds(
            center.lon - (dataWidth / 2),
            center.lat - (dataHeight / 2),
            center.lon + (dataWidth / 2),
            center.lat + (dataHeight / 2)
        );
    },
    
    /**
     * Method: triggerRead
     * 缩放地图或刷新图层后执行本操作。
     * 
     * Parameters:
     * options - {Object} 可选项。
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} 协议对象查询成功后返回的结果对象。
     */
    triggerRead: function(options) {
        if (this.response && !(options && options.noAbort === true)) {
          //  this.layer.protocol.abort(this.response);
            this.layer.events.triggerEvent("loadend");
        }
      	var evt = {filter: {}};
		var layer = this.layer;
        layer.events.triggerEvent("loadstart", evt);
		var bounds = layer.map.getExtent();
		var dataWidth = bounds.getWidth() * this.ratio;
        var dataHeight = bounds.getHeight() * this.ratio;
		var center = bounds.getCenterLonLat();
        bounds = new OpenLayers.Bounds(
            center.lon - (dataWidth / 2),
            center.lat - (dataHeight / 2),
            center.lon + (dataWidth / 2),
            center.lat + (dataHeight / 2)
        );
		var leftTop = new Geo.LonLat(bounds.left,bounds.top);
		var pyramid = layer.pyramid;
		var rightBottom = new Geo.LonLat(bounds.right,bounds.bottom);
		var level = pyramid.getLevelForResolution(layer.map.getResolution());
		//最小行列号
		var minXY = pyramid.getTileIndex(leftTop,level);
		//最大行列号
		var maxXY = pyramid.getTileIndex(rightBottom,level);
		this.getTextDateForGridIndex(minXY, maxXY, level);
    },
	
	 /**
     * Method: getTextDateForGridIndex
     * 根据行列号和层级请求数据。
     * 
     * Parameters:
     * minXY - {Integer} 最小行列号。
     * maxXY - {Integer} 最大行列号。
     * level - {Integer} 层级。
     */
	getTextDateForGridIndex: function(minXY, maxXY, level) {
		this.queue = [];
		if(level >= 10) {
			this.layer.textCounter = (maxXY.col - minXY.col + 1) * (maxXY.row - minXY.row + 1);
			//根据行列号请求文字服务
			for(var i = minXY.col; i <= maxXY.col; i++) {
				for(var j = minXY.row; j <= maxXY.row;j++) {
					var lxy = (level + "," + i + "-" + i + "," + j + "-" + j);
			       this.readText(lxy);
				}
			}
		}
	},
	
	/**
     * Method: readText
     * 请求文字服务。
     * 
     * Parameters:
     * lxy - {String} 层级与行列号
     */
	readText: function(lxy) {
		this.response = this.layer.read({
			lxyArray: lxy,
			callback: this.merge,
			scope:this
		});
	},
	
	/**
     * Method: merge
     * 返回结果。
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} 返回结果。
     */
	merge: function(resp) {
		if(!resp.error) {
			this.layer.display(true);
			var features = resp.features;
			this.layer.update(features);
			this.response = null;
	        this.layer.events.triggerEvent("loadend", {response: resp});
		}
	},
 
    CLASS_NAME: "Geo.Strategy.GeoTextXYZ" 
});/**
 * Class: Geo.Service
 * 服务类。本类是服务类的基类，需要由子类去实现。
 */
Geo.Service = Geo.Class({
	
	/**
     * APIProperty: name
     * {String} 服务名称。
     */
	name: null,
	
	/**
     * APIProperty: url
     * {String} 服务地址。
     */	
	url: null,
	
	/**
     * APIProperty: version
     * {String} 服务版本号。
     */		
	version: null,

	
	/**
     * APIProperty: userid
     * {String} 用户名。
     */			
	userid: "test@liferay.com",
	
	/**
     * Constructor: Geo.Service.Bus
     * Geo.Service.Bus类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},


	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息，由子类实现。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */		
	getCapabilities: function(successFn,failFn){
		//由子类实现
	},

	/**
     * APIMethod: isExist
     * 检查服务是否存在，由子类实现。
     */		
	isExist: function(){
		//由子类实现
	},


	/**
     * APIMethod: failFn
     * 服务操作失败响应回调函数。
     * 
     * operate - 失败的操作类型。
     */		
	failFn: function(operate){
		alert("服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" + 
			"请求地址：" + this.url + "\n操作类型：" + operate);
	},

	//将结果解析成XML
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new OpenLayers.Format.XML();
		return xmlParser.read(doc);
	},
	
	//对返回结果进行检查，是否为错误信息
	_checkIsError: function(xmlString){
		var xmlparser = new OpenLayers.Format.XML();
		var xml = xmlparser.read(xmlString);
		var exceptions = xml.selectNodes("ServiceExceptionReport");
        if(exceptions.length > 0){
            return this._parseToJSON(xmlString);
        }
        return null;
	},
	
	//对解析后的JSON对象进行判断是否为服务抛出的异常
	_isException:function(result){
		if(result && result.ServiceExceptionReport){
			return true;
		}
		return false;
		
	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	CLASS_NAME: "Geo.Service"
	
});/**
 * Class: Geo.Service.GlobeTile
 * 吉奥瓦片服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.GlobeTile = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.GlobeTile
     * Geo.Service.GlobeTile类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
	getCapabilities: function(successFn,failFn){
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		OpenLayers.loadURL(url,null,this,function(result){
			successFn(result);
		},failFn);
	},
	
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		var xhr = OpenLayers.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},

	CLASS_NAME: "Geo.Service"
});/**
 * Class: Geo.Service.Bus
 * 公交服务类。
 * 
 * Inherits from:
 *  - <Geo.Service>
 */
Geo.Service.Bus = Geo.Class(Geo.Service,{
	
	/**
     * Constructor: Geo.Service.Bus
     * Geo.Service.Bus类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     * 
     * Example:
     * (code)
     *  var url = "http://map.geostar.com.cn:9001/bus_sdk_new/bus";
     *  var busService = new Geo.Service.Bus("公交服务", url);
     * (end)
     */
	initialize: function(name, url,  options){ 
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},

	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送"GetCapabilities"同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};		
		var xhr = OpenLayers.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},	
	
	/**
     * APIMethod: queryStation
     * 站点查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * stationName - {String} (可选) 站点名称。
     * stationId - {Integer} (可选) 站点ID  必须为正整型。
     * lineId - {Integer} (可选) 线路ID。
     * lineName - {String}  (可选) 线路名称。
     * coordinate - {String} (可选) 站点位置  用逗号分隔XY轴坐标如(X,Y)。
     * bbox - {String} (可选) 矩形范围。
	 *     
     * Example:
     * (code)
     *  //示例1 根据站点名称查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     *  //示例2 根据站点ID查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  //示例3 根据矩形范围查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      bbox : '-1,-1,1,1'
     *  }
     *  (end)
     */	
    queryStation:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStation"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
		
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }
		
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
		
		if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
		
		if(options.coordinate !== null && options.coordinate !== undefined){
        	params.COORDINATE = options.coordinate;
        }   
		
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },

	/**
     * APIMethod: queryLine
     * 线路查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * lineName - {String} (可选) 线路名称。
     * lineId - {Integer} (可选) 线路ID。
     * stationName - {String} (可选) 站点名称。
     * stationId - {Integer} (可选) 站点ID。
     * coordinate - {String} (可选) 站点位置。
     * bbox - {String} (可选) 矩形范围。
     *       
     * Example:
     * (code)
     *  //示例1 根据站点名称查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     * //示例2 根据站点ID查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     * //示例3 根据路线名称查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      lineName : '4'
     *  }
     *  (end)
     */	
    queryLine: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLine"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }    
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }    
                
        if(options.coordinate !== null && options.coordinate !== undefined){
            params.COORDINATE = options.coordinate;
        }   
                     
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },
    
	/**
     * APIMethod: queryChange
     * 公交换乘方案查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * startStationId - {Integer} (可选) 起始站点ID。
     * endStationId - {Integer} (可选) 终止站点ID。
     * startCoordinate - {String} (可选) 起始站点坐标。
     * endCoordinate - {String} (可选) 起始站点坐标。
     * maxDepth - {Integer}(可选) 最大边数范围,正整型参数,没有则默认值为5。
     * maxCost - {Float} (可选) 最大权值范围,正双精度符点型参数,没有则默认为100.0。
     * maxSolutions - {Integer} (可选) 最多解决方案数量,正整型参数,没有则默认为5。
     * orderType - {String}(可选) 值为LeastCost时表示较快捷，值为LeastWalk时表示少步行，值为LeastChange时表示少换乘。
     * 
     * Example:
     * (code)
     *  busService.queryChange({
     *      networkName: "BusChangeModule",
     *        startStationId: "238",
     *        endStationId: "25",
	 *		  maxDepth:5,
	 *		  maxCost:100.0,
	 *		  maxSolutions:5,
	 *		  //orderType表示换乘的类型。LeastCost表示较快捷，用户还可以选择LeastWalk或LeastChange，LeastWalk表示少步行，值为LeastChange时表示少换乘
	 *		  orderType:"LeastCost" 
     *  })
     *  (end)
     */	
    queryChange: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryChange"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.startStationId !== null && options.startStationId !== undefined){
            params.STARTSTATIONID = options.startStationId;
        }
        
        if(options.endStationId !== null && options.endStationId !== undefined){
            params.ENDSTATIONID = options.endStationId;
        }
		
		if(options.orderType !== null && options.orderType !== undefined){
            params.ORDERTYPE = options.orderType;
        }
        
        if(options.startCoordinate !== null && options.startCoordinate !== undefined){
            params.STARTCOORDINATE = options.startCoordinate;
        }    
        
        if(options.endCoordinate !== null && options.endCoordinate !== undefined){
            params.ENDCOORDINATE = options.endCoordinate;
        }  
		
		if(options.maxDepth !== null && options.maxDepth !== undefined){
            params.MAXDEPTH = options.maxDepth;
        } 
		
		if(options.maxCost !== null && options.maxCost !== undefined){
            params.MAXCOST = options.maxCost;
        }  
		
		if(options.maxSolutions !== null && options.maxSolutions !== undefined){
            params.MAXSOLUTIONS = options.maxSolutions;
        }  
		if (options.ChangeCount !== null && options.ChangeCount !== undefined) {
			params.CHANGECOUNT = options.ChangeCount;
        }
		  
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
            	var  featureCollection = [];
				var resXML;//= result.responseXML;
				if (!result.responseXML.documentElement) {
					resXML = format.read(result.responseText);
				}
				else {         
					resXML = result.responseXML;
				}       

				var docElement = resXML.selectNodes("/Features/FeatureCollection");
				
            	var xmlparser = new OpenLayers.Format.XML();
				
            	for(var i = 0; i < docElement.length; i++) {
					//获取FeatureCollection元素节点的属性
					var featureCollectionElement = docElement[i];
					var attArray = ['cost','price','walkingDistance','transferTimes'];
					var attributionObj = this._getAttibutionOfNode(featureCollectionElement, attArray);
					
					var str = xmlparser.write(docElement[i]);
					var features = this._parserFeatures(str);
					//features或featureCollectionElement相当于一个FeatureCollection
					features.attributes= attributionObj;
					var featureMember = featureCollectionElement.selectNodes("featureMember");
					for(var j = 0; j < featureMember.length; j++) {
						var road = featureMember[j].selectNodes("Road");
						//线路添加是否步行属性：isOnFoot
						features[j]["isOnFoot"] = road[0].getAttribute("isOnFoot");
					}
	            	featureCollection.push(features);
            	}

                successFn(featureCollection);
            },
            failure: failFn
        });

    },
	
	//根据节点得到节点的属性
	_getAttibutionOfNode: function(node, keyArray) {
		//获取FeatureCollection属性信息
		var fcAttibution = {};
		if(node.tagName){
			for(var i = 0; i < keyArray.length; i++) {
				fcAttibution[keyArray[i]] = node.getAttribute(keyArray[i])
			}
	    }
		return fcAttibution;
	},
   
    _getGeometryType: function(geometry){
        var maping = {
            "OpenLayers.Geometry.Point": "point",
            "OpenLayers.Geometry.LineString": "line",
            "OpenLayers.Geometry.Polygon": "polygon"
        };
        return "polygon";
    },
    
    _pagingToString: function(curPage,maxPerPage){
        maxPerPage = maxPerPage || this.maxPerPage;
        curPage = curPage || 1;
        return "<numPerPage>" + maxPerPage + "</numPerPage>"+
                "<curPage>" + curPage + "</curPage>";
    },
    
    _orderByToString: function(property,type){
        var str = "<orderBy>"+
    	            "<PropertyName>" + property + "</PropertyName>"+
    	        "</orderBy>";
        return property ? str : "";
    },
    
    _geometryToString: function(geometry){
        return '<geometry>'+
                    '<Polygon>'+
                        '<outerBoundaryIs>'+
                            '<LinearRing>'+
                                '<coordinates decimal="." cs="," ts=" ">20,30 21,41 52,42 53,33 20,30</coordinates>'+
                            '</LinearRing>'+
                        '</outerBoundaryIs>'+
                    '</Polygon>'+
                '</geometry>';
    },
    
    _stringToGeometry: function(string){
        return Geo.Geometry.Polygon.createRegularPolygon(
            new Geo.Geometry.Point( Math.random()*360 - 160, 
                                           Math.random()*90 - 70 ),
            Math.round(Math.random()*20),
            Math.round(Math.random()*10)
        );
    },
	
    _parserFeatures: function(resultString){
        var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
        var features = parser.read(resultString);
        return features;
    },
	
	// 把节点名称所在的节点外套上<featureMember></featureMember>
	_parserResponseText: function(resultString, nodeName){
		if(nodeName){
			var re1 = new RegExp("<" + nodeName + ">", ["g"]);
	        var re2 = new RegExp("</" + nodeName + ">", ["g"]);
			
	        resultString = resultString.replace(re1, "<featureMember><" + nodeName + ">");
	        resultString = resultString.replace(re2, "</" + nodeName + "></featureMember>");
		}
		
		resultString = resultString.replace(/<gml:LineString>/g,"<gml:LineString><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:LineString>/g,"</gml:coordinates></gml:LineString>");
		resultString = resultString.replace(/<gml:Point>/g,"<gml:Point><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:Point>/g,"</gml:coordinates></gml:Point>");
		return resultString;
	},
	
	_parserFeaturesNew: function(resultString, featureName){
		var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
		if(featureName){
			parser.featureName = featureName;
		}
        var features = parser.read(resultString);
        return features;
    },
    
	_parserSuccessResult: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new OpenLayers.Format.XML();
		return xmlParser.read(doc);

	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	/**
	 * APIMethod: queryTransferScheme
	 * 根据始终点的空间坐标或一组起始站点ID和一组终止站点的ID，查询公交换乘的文字信息，必要时也查询出第一条方案的几何信息。（公交2.0）
	 * 
	 * Parameters:
	 * options - {Object} 请求参数。
	 * successFn - {Function}请求成功的回调函数。
	 * failFn - {Function}请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * networkName {String} (必选) 网络模型名称。
	 * transferMode - {Integer} (必选) 换乘模式  ,有三种值：0-较快捷   1-少换乘  2-少步行。
	 * startInput - {String} (必选) 始点信息，可以是坐标信息也可也是ID类型（坐标类型,格式为:x y。分隔符为空格符；ID类型,格式为:id,… ,id。分隔符为逗号）。
	 * endInput - {String} (必选)终点信息支持坐标与ID类型:坐标类型,格式为:x y。分隔符为空格符ID类型,格式为:id,… ,id。分隔符为逗号。
	 * inputMode - {Integer}(可选)始终点输入模式,值为0|1|2: 0-坐标,1-车站外部唯一编号,2-车站内部唯一编号（当前服务没有外部唯一编号）。
	 * ComputeModel	
	 * transferSubset
	 * existGoTime
	 * startTime
	 * specificSubset
	 * maxSearchDistance
	 * computeSort
	 * transferPolicy
	 * resultSort
	 * prioritySubset
	 * existAbsolutePriority
	 * lagSubset
	 * outputPage
	 * pageSize
	 * changeCount
	 */
	queryTransferScheme: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferScheme",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		//四个必选参数
		var required = {
			networkName:true,
            transferMode: true,
            startInput: true,
			endInput: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("缺少必选属性：'" + prop + "'。");
            }
        }
		params.networkName = options.networkName;
		
		//这样判断的原因是为了避免0,1这样的值在进行if判断的时候被当做false把参数给过滤掉；""串不需要被过滤，这个已经向服务组确认
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if(options.transferMode !== null && options.transferMode !== undefined) {
			params.TRANSFERMODE = options.transferMode;
        }
		if(options.startInput !== null && options.startInput !== undefined) {
			params.STARTINPUT = options.startInput;
        }
		if(options.endInput !== null && options.endInput !== undefined) {
			params.ENDINPUT = options.endInput;
        }
		if(options.inputMode !== null && options.inputMode !== undefined) {
			params.INPUTMODEL = options.inputMode;
        }
		if (options.ExistGoTime !== null && options.ExistGoTime !== undefined) {
			params.EXISTGOTIME = options.ExistGoTime;
        }
		if (options.StartTime !== null && options.StartTime !== undefined) {
			params.STARTTIME = options.StartTime;
        }
		if (options.MaxSearchDistance !== null && options.MaxSearchDistance !== undefined) {
			params.MAXSEARCHDISTANCE = options.MaxSearchDistance;
		}
		if (options.PrioritySubset !== null && options.PrioritySubset !== undefined) {
			params.PRIORITYSUBSET = options.PrioritySubset;
        }
		if (options.ExistAbsolutePriority !== null && options.ExistAbsolutePriority !== undefined) {
			params.EXISTABSOLUTEPRIORITY = options.ExistAbsolutePriority;
        }
		if (options.LagSubset !== null && options.LagSubset !== undefined) {
			params.LAGSUBSET = options.LagSubset;
        }
		if (options.OutputPage !== null && options.OutputPage !== undefined) {
			params.OUTPUTPAGE = options.OutputPage;
        }
		if (options.PageSize !== null && options.PageSize !== undefined) {
			params.PAGESIZE = options.PageSize;
        }
		if (options.ChangeCount !== null && options.ChangeCount !== undefined) {
			params.CHANGECOUNT = options.ChangeCount;
        }
		
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: OpenLayers.Function.bind(function(result){
				var resXML = result.responseXML;
                var features = {
                    startPoint: [],
                    transferScheme: [],
                    endPoint: []
                };	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new OpenLayers.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				
				var element = resXML.selectNodes("/QueryTransferSchemeResponse");	
				var elementXMLStr = xmlparser.write(element[0]);
				// XML解析成json对象
				var jsonObj = this._parseToJSON(elementXMLStr);
				var startPoint = jsonObj.QueryTransferSchemeResponse.StartPoint;
				if (!OpenLayers.Util.isArray(startPoint)) {
		            startPoint = [startPoint];
		        }
				var endPoint = jsonObj.QueryTransferSchemeResponse.EndPoint;
				if (!OpenLayers.Util.isArray(endPoint)) {
		            endPoint = [endPoint];
		        }
				var transferScheme = jsonObj.QueryTransferSchemeResponse.TransferScheme;
				
				// 起点要素
                var startPointGeometry = this._getPointGeometryByGMLPointStr(startPoint[0].Geometry.gml_Point);
            	var startPointFeature = new Geo.Feature.Vector(startPointGeometry);
				// 终点要素
                var endPointGeometry = this._getPointGeometryByGMLPointStr(endPoint[0].Geometry.gml_Point);
            	var endPointFeature = new Geo.Feature.Vector(endPointGeometry);
				// 换乘要素
				var transferSchemeFeatures = this._parserTransferScheme(transferScheme);
				
                features = {
                    startPoint: startPointFeature,
                    transferScheme: transferSchemeFeatures,
                    endPoint: endPointFeature
                };
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	// 解析换乘要素
    _parserTransferScheme: function(transferSchemeObjs){
		if (!OpenLayers.Util.isArray(transferSchemeObjs)) {
            transferSchemeObjs = [transferSchemeObjs];
        }
        var transferSchemeFeatures = new Array();
        for (var i = 0; i < transferSchemeObjs.length; i++) {
			var transferSchemeObj = transferSchemeObjs[i];
			// 解析片段信息
			var SectionInfo = this._parserSectionInfo(transferSchemeObj.SectionInfo);
			// 解析片段步行
			var SectionRoutingFeatures = this._parserSectionRouting(transferSchemeObj.SectionRouting);
            
			var transferSchemeFeature = {
                Cost: transferSchemeObjs[i].Cost,
                SectionInfo: SectionInfo,
                SectionRouting: SectionRoutingFeatures,
                TotalDistance: transferSchemeObjs[i].TotalDistance,
                TransferCount: transferSchemeObjs[i].TransferCount
            };
            transferSchemeFeatures.push(transferSchemeFeature);
        }
        return transferSchemeFeatures;
    },
	
	// 解析片段信息
    _parserSectionInfo: function(sectionInfoObjs){
		if (!OpenLayers.Util.isArray(sectionInfoObjs)) {
            sectionInfoObjs = [sectionInfoObjs];
        }
		var sectionInfos = new Array();
		for (var i = 0; i < sectionInfoObjs.length; i++) {
			
			// 上车点要素
			var fromStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation);
			if (sectionInfoObjs[i].FromStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation.PassagewayRouting);
				if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
                fromStationFeature.attributes.PassagewayRouting = fromStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 下车点要素
			var toStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation);
			if (sectionInfoObjs[i].ToStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation.PassagewayRouting);
                if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
				toStationFeature.attributes.PassagewayRouting = toStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 线路要素
			var sectionLine = this._parserSectionLines(sectionInfoObjs[i].SectionLines.SectionLine);
			var sectionRouting = this._parserSectionRouting(sectionInfoObjs[i].SectionRouting);
			
			sectionInfos.push({
				FromStation: fromStationFeature,
				SectionLine: sectionLine,
				ToStation: toStationFeature,
				SectionRouting: sectionRouting
			});
		}
		return sectionInfos;
	},
	
	// 解析片段信息内的片段线路
    _parserSectionLines: function(sectionLineObjs){
        if (!OpenLayers.Util.isArray(sectionLineObjs)) {
            sectionLineObjs = [sectionLineObjs];
        }
		var sectionLineFeatures = new Array();
		for (var i = 0; i < sectionLineObjs.length; i++) {
            var sectionLineFeature = new Geo.Feature.Vector(null, sectionLineObjs[i]);
			sectionLineFeatures.push(sectionLineFeature);
		}
		return sectionLineFeatures;
	},
	
	// 解析片段步行
    _parserSectionRouting: function(sectionRoutingObjs){
		// TODO
        if (!OpenLayers.Util.isArray(sectionRoutingObjs)) {
            sectionRoutingObjs = [sectionRoutingObjs];
        }
		var sectionRoutingFeatures = new Array();
		for (var i = 0; i < sectionRoutingObjs.length; i++) {
			sectionRoutingFeatures.push(sectionRoutingObjs[i]);
		}
		return sectionRoutingFeatures;
	},
	
	// -----根据点串得到点对象
	_getPointGeometryByGMLPointStr: function(pointStr) {
		var pointArr = pointStr.split(",");
		var point = new Geo.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
		return point;
	},
	
	// 解析站点或出入口点的要素
    _getPointFeatureByObj: function(pointInfoObj){
        var pointGeometry = null;
        if (pointInfoObj.Geometry && pointInfoObj.Geometry.gml_Point) {
            pointGeometry = this._getPointGeometryByGMLPointStr(pointInfoObj.Geometry.gml_Point);
        }
        var pointFeature = new Geo.Feature.Vector(pointGeometry, pointInfoObj);
        return pointFeature;
    },
	
	// -----根据id等信息获取geometry串并生成geometry对象
    _getLineGeometryByGMLLineStr: function(geometryStr){
        if (!geometryStr) {
            return null;
        }
        var pointStrArr = geometryStr.split(" ");
        var pointArr = [];
        for (var i = 0, j = pointStrArr.length; i < j; i++) {
            var pointGeometry = this._getPointGeometryByGMLPointStr(pointStrArr[i]);
            pointArr.push(pointGeometry);
        }
        var lineGeometry = new OpenLayers.Geometry.LineString(pointArr);
        return lineGeometry;
    },
	
	/**
	 * APIMethod: queryTransferGeometry
	 * 根据线路ID或者步行ID来获取相应的线要素（公交2.0。注意：这些线要素不包含属性信息）。
	 * 
     * Parameters:
	 * options - {Object} 请求参数。
	 * 
	 * options请求参数属性可为:
	 * networkName - {String} (必选) 网络模型名称。
	 * parameterInfo - {Arrays} 取值格式：[[geometryTypeID,geometryInfoID,FromOrdinal,ToOrdinal]]例如[[0,10,22,24]]。
	 * geometryTypeID - {Integer} (必选) 0-线路内部ID,1-步行路由内部ID。如果这个属性的值为1，那么FromOrdinal和ToOrdinal这两个属性的的值就都为0。
	 * geometryInfoID - {Integer}几何信息 的ID。
	 * FromOrdinal -  {Integer} (必选) 起点序号。
	 * ToOrdinal -  {Integer} (必选) 终点序号。
	 */
	queryTransferGeometry: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferGeometry",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.parameterInfo === null || options.parameterInfo === undefined || options.parameterInfo === ""){
            throw "Error!Not parameterInfo for bus query.";
            return;
        }
		params.networkName = options.networkName;
		params.PARAMETERINFO = "";
        for (var i = 0; i < options.parameterInfo.length; i++) {
            params.PARAMETERINFO += options.parameterInfo[i].toString();
            if (i != options.parameterInfo.length - 1) {
                params.PARAMETERINFO += "_";
            }
        }
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: OpenLayers.Function.bind(function(result){
				var features = this._parseQueryTransferGeometryResult(result);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析QueryTransferGeometry接口返回结果 -----获取线路要素
	_parseQueryTransferGeometryResult: function(result) {
		resXML = result.responseXML;
		var features = [];
		if(!resXML) {
			return features;
		}
		var xmlparser = new OpenLayers.Format.XML();
		var geometrysStrTemp = resXML.selectNodes("/QueryTransferGeometryResponse");	
		//没有查询到数据的情况
		if(geometrysStrTemp && geometrysStrTemp.length <= 0) {
			return features;
		}
		var geometrysXMLStr = xmlparser.write(geometrysStrTemp[0]);
		var geometrysXMLObj = this._parseToJSON(geometrysXMLStr);
		var geometrys = geometrysXMLObj.QueryTransferGeometryResponse.SectionGeometry;	
		
		if(geometrys) {
			if(!OpenLayers.Util.isArray(geometrys)) {
				geometrys = [geometrys];
			}
			//得到一个个站点
			for(var i = 0 ;i < geometrys.length; i++)  {
				//得到几何对象
				var geometryTemp = this._getLineGeometryByGMLLineStr(geometrys[i].Geometry.gml_LineString);
				//得到线要素
                var lineFeature = new Geo.Feature.Vector(geometryTemp, {
                    ID: geometrys[i].ID
                });
				features.push(lineFeature);
			}
		}
		return features;
	},
	
	/**
	 * APIMethod: queryKeyWord
	 * 根据关键字来获取线路信息或者站点信息或者出入口信息。（公交2.0）
	 * 
     * Parameters:
	 * options - {Object} 请求参数。
	 * 
	 * options请求参数属性可为:
	 * networkName - {String} (必选) 网络模型名称。
	 * keyWord - {String} (必选)查询关键字。
	 * searchType - {Integer} (可选) 查询类型，默认值为 2，查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊默认值为2。
	 * keyWordType - {Integer} (可选) 查询关键字类型，默认值为 -1，可供选择的值为-1|0|1|2:-1:先查线路，然后查车站，最后查出入口0-查线路，1-查车站，2-查出入口。
	 *     
	 * Returns:
	 * {Array(Geo.Feature.Vector)} 返回的是出入口、站点、线路要素。
	 */
	queryKeyWord: function(options, successFn, failFn) {
		var params = {
			REQUEST: "QueryKeyWord",
			SERVICE: "BUS",
			VERSION: "1.0.0",
			SEARCHTYPE: 2
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.keyWord === null || options.keyWord === undefined || options.keyWord === ""){
            throw "Error!Not keyWord for bus query.";
            return;
        }
		params.NETWORKNAME = options.networkName;
		params.KEYWORD = options.keyWord;
		
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if (options.searchType !== null && options.searchType !== undefined) {
        	params.SEARCHTYPE = options.searchType;
        }
		if (options.keyWordType !== null && options.keyWordType !== undefined) {
        	params.KEYWORDTYPE = options.keyWordType;
        }
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: OpenLayers.Function.bind(function(result){
				var features = this._parserQueryKeyWordResult(result,options.keyWordType);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析queryKeyWord接口返回结果 -----获取站点或出入口或线路文字描述信息
	_parserQueryKeyWordResult: function(result,keyWordType) {
		var resXML = result.responseXML;
		var features = [];	
		if(!resXML) {
			return features;
		}
		var xmlparser = new OpenLayers.Format.XML();
		var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
		//没有查询到数据的情况
		if(errorTemp && errorTemp.length > 0) {
			return features;
		}
		var objectsStrTemp = resXML.selectNodes("/QueryKeyWordResponse");	
		var objectsXMLStr = xmlparser.write(objectsStrTemp[0]);
		var objectsXMLObj = this._parseToJSON(objectsXMLStr);
		
		// 0-查线路，1-查车站，2-查出入口
        if (keyWordType === 1) {
            var stations = objectsXMLObj.QueryKeyWordResponse.Stations.Station;
			if (stations && !(Geo.Util.isArray(stations))) {
				stations = [stations];
			}
            for (var i = 0; i < stations.length; i++) {
                var pointFeature = this._getPointFeatureByObj(stations[i]);
                features.push(pointFeature);
            }
        } else if (keyWordType === 2) {
            var passageways = objectsXMLObj.QueryKeyWordResponse.Passageways.Passageway;
			if (passageways && !(Geo.Util.isArray(passageways))) {
				passageways = [passageways];
			}
            for (var i = 0; i < passageways.length; i++) {
                var pointFeature = this._getPointFeatureByObj(passageways[i]);
                features.push(pointFeature);
            }
        } else {
            var lines = objectsXMLObj.QueryKeyWordResponse.Lines.Line;
			if (lines && !(Geo.Util.isArray(lines))) {
				lines = [lines];
			}
            for (var i = 0; i < lines.length; i++) {
                var lineFeature = new Geo.Feature.Vector(null,lines[i]);
                features.push(lineFeature);
            }
        }
		return features;
	},
	
	/**
     * APIMethod: queryStationInfo
     * 站点查询操作。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * stationId - {Integer} (必选) 站点ID  必须为正整型。
     *   
     *       
     * Example:
     * (code)
     *  busService.queryStationInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */	
    queryStationInfo:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStationInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.stationId === null || options.stationId === undefined || options.stationId === ""){
            throw "Error!Not stationId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
        
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				resXML = result.responseXML;
				if(!resXML) {
					var features = {
						lines:[],
						passageways:[]
					};
	                successFn(features);
					return;
				}
				var xmlparser = new OpenLayers.Format.XML();
				
				//根据节点名字，解析成对象
				var lines = this._parserQueryStationInfoNode("Lines", xmlparser, resXML);
				var passageways = this._parserQueryStationInfoNode("Passageways", xmlparser, resXML);
                
				//解析后转feature
				var passagewaysFeature = new Array();
                for (var i = 0; i < passageways.length; i++) {
					var pointFeature = this._getPointFeatureByObj(passageways[i]);
					passagewaysFeature.push(pointFeature);
                }
		
				var features = {
					lines: lines,
					passageways: passagewaysFeature
				};
                successFn(features);
            },
            failure: failFn
        });

    },
	
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryStationInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Lines":
                //解析lines
	            var element = resXML.selectNodes("/QueryStationInfoResponse/StationInfo/Lines");
	            var lines = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
	                lines = jsonObj.Lines.Line;
	                if (!(Geo.Util.isArray(lines))) {
	                    lines = [lines];
	                }
	            }
	            return lines;
                break;
            case "Passageways":
                //解析Passageways
	            var element = resXML.selectNodes("/QueryStationInfoResponse");
	            var passageways = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
					var passagewaysJson = jsonObj.QueryStationInfoResponse.StationInfo.Passageways;
					if(passagewaysJson){
						passageways = passagewaysJson.Passageway;
		                if (!(Geo.Util.isArray(passageways))) {
		                    passageways = [passageways];
		                }
					}
	            }
	            return passageways;
                break;
            default:
				return [];
                break;
        }
    },
    
    /**
     * APIMethod: queryLineInfo
     * 线路查询操作。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * lineId - {Integer} (必选) 线路ID。
     * STARTNODENUMBER - {String} (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     * ENDNODENUMBER - {String} (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     * 
     * Example:      
     * (code)
     *  busService.queryLineInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */
    queryLineInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLineInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.lineId === null || options.lineId === undefined || options.lineId === ""){
            throw "Error!Not lineId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.startNodeNumber !== null && options.startNodeNumber !== undefined){
            params.STARTNODENUMBER = options.startNodeNumber;
        }    
                
        if(options.endNodeNumber !== null && options.endNodeNumber !== undefined){
            params.ENDNODENUMBER = options.endNodeNumber;
        }   
                     
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
//				// 传入包含gml的结点名称
//				var resultString = this._parserResponseText(result.responseText, "Line");
//				var features = this._parserFeaturesNew(resultString);
//				
//				// 线路所包含的站点要素
//				var resultStationString = this._parserResponseText(result.responseText, "Station");
//				var stationFeatures = this._parserFeaturesNew(resultStationString);
//                features[0].attributes.Stations = features[0].data.Stations = stationFeatures;
//				
//				successFn(features);
//				return;
				
				var features = [];
				var resXML = null;
				if(result.responseXML) {         
					resXML = result.responseXML;
					var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
					//没有查询到数据的情况
					if(errorTemp && errorTemp.length > 0) {
						successFn(features);
						return;
					}
					var xmlparser = new OpenLayers.Format.XML();
					//根据节点名字，解析成对象
					var line = this._parserQueryLineInfoNode("Line", xmlparser, resXML);
					//解析后转feature
					var lineFeatures = new Array();
	                for (var i = 0; i < line.length; i++) {
						//线路内站点信息转要素
						var stationFeatures = new Array();
	                    for (var j = 0; j < line[i].VIAStations.Station.length; j++) {
							//得到点要素
	                    	var stationFeature = this._getPointFeatureByObj(line[i].VIAStations.Station[j]);
							stationFeatures.push(stationFeature);
	                    }
						line[i].Stations = stationFeatures;
						//得到线几何对象
						var lineGeometry = this._getLineGeometryByGMLLineStr(line[i].Geometry.gml_LineString);
						//得到线要素
	                    var lineFeature = new Geo.Feature.Vector(lineGeometry, line[i]);
						lineFeatures.push(lineFeature);
	                }
			
					features = lineFeatures;
				}
				successFn(features);
            },
            failure: failFn
        });

    },
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryLineInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Line":
                //解析line
	            var element = resXML.selectNodes("/QueryLineInfoResponse");
				var xmlObj = xmlparser.write(element[0]);
                var jsonObj = this._parseToJSON(xmlObj);
				var l = jsonObj.QueryLineInfoResponse.Line;
				
	            var lines = new Array();
                if (l && !(Geo.Util.isArray(l))) {
                    lines = [l];
                }else{
					lines = l;
				}
	            return lines;
                break;
            default:
				return [];
                break;
        }
    },
	
	/**
     * APIMethod: queryPassagewayInfo
     * 根据出入口ID获取与此出入口有关的站点信息，包括出入口所对应的车站信息。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * passagewayId - {Integer} (必选) 出入口ID。
     * 
     * Example:      
     * (code)
     *  busService.queryPassagewayInfo({
     *      networkName: "BusChangeModule",
     *      passagewayId : 2
     *  }
     *  (end)
     */
    queryPassagewayInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryPassagewayInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.passagewayId === null || options.passagewayId === undefined || options.passagewayId === ""){
            throw "Error!Not passagewayId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.passagewayId !== null && options.passagewayId !== undefined){
            params.PASSAGEWAYID = options.passagewayId;
        }
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var resXML = result.responseXML;
				var features = [];	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new OpenLayers.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				var responseText = this._parserResponseText(result.responseText);
				features = this._parserFeaturesNew(responseText, "Stations");
				successFn(features);
            }
        });
	},
	
	CLASS_NAME: "Geo.Service.Bus"
});

//FF,chrome兼容selectNodes,selectSingleNode
(function xmlNodesTool(){
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectNodes = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            //name space resolver defined  
            function nsResolver(prefix){
                var ns = {
                    'csw': 'http://www.opengis.net/cat/csw',
                    'smmd': 'http://data.sbsm.gov.cn/smmd/2007',
                    'wfs': 'http://www.opengis.net/wfs',
                    'gml': 'http://www.opengis.net/gml',
                    'geoglobe': 'http://www.geostar.com.cn/geoglobe'
                };
                return ns[prefix] || null;
            }
            //var oNSResolver = this.createNSResolver(this.documentElement||this.ownerDocument.documentElement)||nsResolver;
            var aItems = this.evaluate(cXPathString, xNode, nsResolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
            var aResult = [];
            for (var i = 0; i < aItems.snapshotLength; i++) {
                aResult[i] = aItems.snapshotItem(i);
            }
            return aResult;
        };
        
        // prototying the Element 
        Element.prototype.selectNodes = function(cXPathString){
            if (this.ownerDocument.selectNodes) {
                return this.ownerDocument.selectNodes(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
        
    }
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectSingleNode = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            var xItems = this.selectNodes(cXPathString, xNode);
            if (xItems.length > 0) {
                return xItems[0];
            }
            else {
                return null;
            }
        };
        
        // prototying the Element 
        Element.prototype.selectSingleNode = function(cXPathString){
            if (this.ownerDocument.selectSingleNode) {
                return this.ownerDocument.selectSingleNode(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
    }
})();/**
 * Class: Geo.Service.Plot
 * 标绘服务类。
 * 
 * Inherits from:
 *  - <Geo.Service>
 */
Geo.Service.Plot = Geo.Class(Geo.Service,{
	
    
	/**
     * APIProperty: maxPerPage
     * {Integer} 每页的最大条数。
     */	
    maxPerPage: 100,
	
	/**
     * Constructor: Geo.Service.Plot
     * Geo.Service.Plot类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},

	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息操作。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn, failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		OpenLayers.loadURL(url,params,this,function(result){
			result = this._parseToXML(result);
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: addClasses
     * 添加标绘分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   className -{String} 必填,分类名称,该名称不能重复。
     *   parentId -{String}   可填,父类ID。
     *   description -{String} 可填,描述信息。
     *   pictureUrl -{String} 可填,图片地址。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     * plotService.addClasses({
	 *		className: "names",
	 *		parentId:"df",
	 *		description:"asdfsdfsdfsd",
	 *		pictureUrl:"fasdfasdfs"
	 *	});
	 * (end)
     */	
	addClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "AddClasses",
			userid: this.userid
		};
		var url = this.url;
		//name标签为必须
		var requestTemplate = 
			"<AddClasses>"+
				"<Feature>"+
					"<name>${className}</name>"+
					"<parentid>${parentId}</parentid>"+
					"<description>${description}</description>"+
					"<pictureurl>${pictureUrl}</pictureurl>"+
				"</Feature>"+
			"</AddClasses>";
		var className = options.className;
		var parentId = options.parentId;
		var description = options.description;
		var pictureUrl = options.pictureUrl;
		var requestString = OpenLayers.String.format(requestTemplate,{
			className: className,
			parentId: parentId,
			description: description,
			pictureUrl: pictureUrl
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},
	
	/**
     * APIMethod: deleteClasses
     * 删除分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   id	- {String} 类别ID,必填。
     * 
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * 	plotService.deleteClasses({
	 *				classId:"1101"
	 *			},function(result){
	 *			  //doSomeThing...
	 *			});
	 * (end)
     */
	deleteClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "DeleteClasses",
			userid: this.userid
		};
		var requestTemplate = 
			"<FeatureCollection>"+
			    "<Feature>"+
			        "<id>${classId}</id>"+
			    "</Feature>"+
			"</FeatureCollection>";
		var classId = options.classId;
		var requestString = OpenLayers.String.format(requestTemplate,{
			classId: classId
		});
		
		var url = this.url + "?" + OpenLayers.Util.getParameterString(params);
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	
	/**
     * APIMethod: updateClasses
     * 修改分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   classId - {String}类别id,必填。唯一标识。
     *   description - {String} 可填,更新的分类描述。
     *   name - {String} 可填,图片的ID。
     *   pictureUrl - {String} 可填,图片地址。
     *   status - {String} 可填,分类状态。
     *   
     *   
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * plotService.updateClasses({
	 *			classId:classid,
     *          description: name,
     *          name: name,
     *          pictureUrl: "超市",
     *          status: "1"
	 *		},function(result){
	 *         //doSomeThing...
	 *      });
	 * (end)
     */	
	updateClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "UpdateClasses",
			userid: this.userid
		};
		var requestTemplate = 
    		"<FeatureCollection>"+
        		"<Feature>"+
        			"<id>${classId}</id>"+                    
        			"${name}"+
        			"${description}"+
        			"${pictureUrl}"+
        		"</Feature>"+
    		"</FeatureCollection>";
		var classId = options.classId;
        var name = options.name;
        var description = options.description;
        var pictureUrl = options.pictureUrl;
        var status = options.status;
        
		var requestString = OpenLayers.String.format(requestTemplate,{
			classId: classId,
            name:function(){
                return (name === null || name === undefined) ? 
                        "" : "<name>" + name + "</name>";
            },
            description:function(){
                return (description === null || description === undefined) ? 
                        "" : "<description>" + description + "</description>";
            },
            pictureUrl:function(){
                return (pictureUrl === null || pictureUrl === undefined) ? 
                        "" : "<pictureurl>" + pictureUrl + "</pictureurl>";
            }
            
		});
		
		var xhr = OpenLayers.Request.POST({
            url: this.url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},
	
	/**
     * APIMethod: queryClasses
     * 查询分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *     options的请求参数包括:
     *         requestType - 对象查询类型,必填(private私有,public公开,pending绑定,all所有)。
     *         filters - [],可以有零到多个 
     *     			例如：filters : [{type:'PropertyIsEqueTo',propertyName : "classcode",propertyValue : currentClassid}
	 *					            ],
     *         orderBy - {Object} 排序类型 例如： orderBy : {property:'EDITTIME',type:'desc'}
     *         		orderBy的请求参数包括 property和type。
     *         
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * plotService.queryClasses({
	 *				className:"class123",
	 *				filter : [{type:'PropertyIsNotEqualTo',propertyName : "parentid",propertyValue : 'A'},
	 *			  	{type:'PropertyIsLike',propertyName : "classname",propertyValue : 'on'}
	 *					],
	 *			},function(result){
	 *				//doSomeThing...
	 *			});
	 *(end)
     */		
	queryClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "QueryClasses",
			userid: this.userid
		};
		var url = this.url;
		
		var requestTemplate = 
			"<FeatureCollection>"+
			    "<Query>"+
			        "${pagingInfo}"+
					"${filter}" +
					"${orderBy}" +
			    "</Query>"+
			"</FeatureCollection>";
        var filterString = this._filterToString(options.filter);    
        var requestString = OpenLayers.String.format(requestTemplate,{
			pagingInfo: OpenLayers.Function.bind(function(){
                return this._pagingToString(options.maxPerPage,options.currentPage);
            },this),
			filter:filterString,
			orderBy: OpenLayers.Function.bind(function(){
				if(options.orderBy === undefined) {
					return "";
				}
                return this._orderByToString(options.orderBy.property,options.orderBy.type);
            },this)
		});

	
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
			
	},
	
	/**
     * APIMethod: publishFeatures
     * 发布要素操作。
     * 
     * Parameters:
     * options - {Object} json格式的请求参数。
     *   bookmarkId - {String} 对象的唯一标识。必填。如果数据库中已存在,那么为更新操作,如果没有,则为新增操作。
     *   type - {String} 对象类型，必填。（点，线，面，point,line,polygon）。
     * 
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     * plotService.publishFeatures({
     *					bookmarkId: "3455-345345-234234-3454",
     *                  type: "point"
     * },function(result){
	 *		//doSomeThing...
     * }); 
     * (end)
     */		
	publishFeatures: function(options, successFn, failFn){
		var requestTemplate = 
			"<FeatureCollection>"+
				"<Feature>"+
					"<BOOKMARKID>${bookmarkId}</BOOKMARKID>"+
					"<TYPE>${type}</TYPE>"+
				"</Feature>"+
			"</FeatureCollection>";
			
		var params = {
			REQUEST: "PublishFeatures",
			userid: this.userid
		};
		var url = this.url;
		
        var requestString = OpenLayers.String.format(requestTemplate,{
			bookmarkId: options.bookmarkId,
            type: options.type
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	/**
     * APIMethod: approvalFeatures
     * 审核要素操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   bookmarkId - {String} 对象的唯一标识。必填。如果数据库中已存在,那么为更新操作,如果没有,则为新增操作。
     *   type - {String} 对象类型，必填。（点，线，面，point,line,polygon）。
     *   
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     *  plotService.approvalFeatures({
     *	   bookmarkId: "3455-345345-234234-3454",
     *     type: "point"
     *	},function(result){
	 *		//doSomeThing...
     *  }); 
     * (end)
     */		
	approvalFeatures: function(options, successFn, failFn){
		var requestTemplate = 
			"<FeatureCollection>"+
				"<Feature>"+
					"<BOOKMARKID>${bookmarkId}</BOOKMARKID>"+
					"<TYPE>${type}</TYPE>"+
				"</Feature>"+
			"</FeatureCollection>";
			
		var params = {
			REQUEST: "ApprovalFeatures",
			userid: this.userid,
			passresult:"pass"
		};
		var url = this.url;
		
        var requestString = OpenLayers.String.format(requestTemplate,{
			bookmarkId: options.bookmarkId,
            type: options.type
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	/**
     * APIMethod: addFeatures
     * 添加要素操作。
     *   
     * Parameters:
     * options - {Object} 请求参数。
     *   featureId - {String} 可填,对象ID。
     *   sortId - {String} 可填,标绘分类ID。
     *   sortType - {String} 可填,标绘分类码。
     *   bookmarkId - {String} 对象的唯一标识。必填。（如果数据库中已存在,那么为更新操作,如果没有,则为新增操作）。
     *   title - {String} 可填,标题。
     *   status - {String} 可填,要素的状态  "1"表示私有，"2"，表示发布，"3"表示审核。
     *   height - {String} 可填,高度。
     *   pitching - {String} 可填,投影。
     *   brief - {String} 可填，图片。
     *   type - {String} 对象类型，必填。(点,线,面,point,line,polygon)。
     *   linecolor - {String} 可填,线颜色。
     *   iconpath - {String}可填,图标路径。
     *   linewidth - {String} 可填,线宽度。
     *   fillcolor - {String} 可填,填充色。
     *   opacity - {String} 可填,是否透明。
     *   geometry - {<Geo.Geometry.LineString>} 必填 要素的几何属性。
     *  bookmarkId - {String} 对象的唯一标识。必填。如果数据库中已存在,那么为更新操作,如果没有,则为新增操作。
     *  sortType - {String} 分类ID  可填,标绘分类ID。
     *  
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     *      plotService.addFeatures({
     *          title:title,
     *          sortType:classid,
	 *			type:'line',
     *          geometry:new Geo.Geometry.LineString([
	 *              new Geo.Geometry.Point(114.4,30.6),
	 *              new Geo.Geometry.Point(113.9,34.7),
	 *              new Geo.Geometry.Point(116.2,40.1),
	 *              new Geo.Geometry.Point(111.5,40.8)
	 *          ])
     *          },function(result){
     *             //doSomeThing...
     *          });
     *  (end)
     */		
    addFeatures: function(options, successFn, failFn){

        if(options.sortType === null && options.sortType === undefined){
            throw "Error!Not sortType of class.";
            return;
        }
        var uuid = Geo.Math.uuid();
        options.bookmarkId = uuid;
        
        this.updateFeatures(options,successFn,failFn);
    },

	/**
     * APIMethod: updateFeatures
     * 更新要素操作。
     *   
     * Parameters:
     * options - {Object} 请求参数。
     *   type - {String} 对象类型，必填。(点，线，面，point，line，polygon)
     *   bookmarkId - {String} 对象的唯一标识。必填。（如果数据库中已存在，那么为更新操作，如果没有，则为新增操作）
     *   featureId - {String} 可填，对象ID。
     *   sortId - {String} 可填，标绘分类ID。
     *   sortType - {String} 可填，标绘分类码。
     *   title - {String} 可填，标题。
     *   status - {String} 可填，要素的状态  "1"表示私有，"2"，表示发布，"3"表示审核。
     *   height - {String} 可填，高度。
     *   pitching - {String} 可填，投影。
     *   brief - {String} 可填，图片。
     *   linecolor - {String} 可填，线颜色。
     *   iconpath - {String}可填，图标路径。
     *   linewidth - {String} 可填，线宽度。
     *   fillcolor - {String} 可填，填充色。
     *   opacity - {String} 可填，是否透明。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     * plotService.updateFeatures({
     * 	      bookmarkId:"234234-234234-234234-234234",
     *        type:"point",
     *        title:"招商银行"
     *  },function(result){
     *     //doSomeThing...
     *	}); 
     * (end)
     */		
	updateFeatures: function(options, successFn, failFn){
        
        var fOptions = options;
        
		var requestTemplate = 
		    '<Feature>'+
		        '${featureId}'+
		        '${sortId}'+
                '${sortType}'+
		        '${bookmarkId}'+
		        '${type}'+
		        '${iconpath}'+
		        '${brief}'+
		        '${linecolor}'+
		        '${linewidth}'+
		        '${fillcolor}'+
		        '${opacity}'+
		        '${title}'+
		        '${status}'+
		        '${height}'+
		        '${pitching}'+
		        '${geometry}'+
		    '</Feature>';
		var requestString = OpenLayers.String.format(requestTemplate,{
            featureId: function(){
                return (fOptions.featureId === null || fOptions.featureId === undefined) ? 
                        "" : "<FEATUREID>" + fOptions.featureId + "</FEATUREID>";
            },
            sortId: function(){
                return (fOptions.sortId === null || fOptions.sortId === undefined) ? 
                        "" : "<SORTID>" + fOptions.sortId + "</SORTID>";
            },
            sortType: function(){
                return (fOptions.sortType === null || fOptions.sortType === undefined) ? 
                        "" : "<SORTTYPE>" + fOptions.sortType + "</SORTTYPE>";
            },
            bookmarkId: function(){
                return (fOptions.bookmarkId === null || fOptions.bookmarkId === undefined) ? 
                        "" : "<BOOKMARKID>" + fOptions.bookmarkId + "</BOOKMARKID>";
            },
            title: function(){
                return (fOptions.title === null || fOptions.title === undefined) ? 
                        "" : "<TITLE>" + fOptions.title + "</TITLE>";
            },
            status: function(){
                return (fOptions.status === null || fOptions.status === undefined) ? 
                        "" : "<STATUS>" + fOptions.status + "</STATUS>";
            },
            height: function(){
                return (fOptions.height === null || fOptions.height === undefined) ? 
                        "" : "<HEIGHT>" + fOptions.height + "</HEIGHT>";
            },
            pitching: function(){
                return (fOptions.pitching === null || fOptions.pitching === undefined) ? 
                        "" : "<PITCHING>" + fOptions.pitching + "</PITCHING>";
            },
            brief: OpenLayers.Function.bind(function(){
                return (fOptions.brief === null || fOptions.brief === undefined) ? 
                        "" : "<BRIEF>" + fOptions.brief + "</BRIEF>";
            },this),
            type: OpenLayers.Function.bind(function(){
                return (fOptions.type === null || fOptions.type === undefined) ? 
                        "" : "<TYPE>" + fOptions.type + "</TYPE>";
            },this),
            linecolor: OpenLayers.Function.bind(function(){
                return (fOptions.linecolor === null || fOptions.linecolor === undefined) ? 
                        "" : "<LINECOLOR>" + fOptions.linecolor + "</LINECOLOR>";
            },this),
            iconpath: OpenLayers.Function.bind(function(){
                return (fOptions.iconpath === null || fOptions.iconpath === undefined) ? 
                        "" : "<ICONPATH>" + fOptions.iconpath + "</ICONPATH>";
            },this),
            linewidth: OpenLayers.Function.bind(function(){
                return (fOptions.linewidth === null || fOptions.linewidth === undefined) ? 
                        "" : "<LINEWIDTH>" + fOptions.linewidth + "</LINEWIDTH>";
            },this),
            fillcolor: OpenLayers.Function.bind(function(){
                return (fOptions.fillcolor === null || fOptions.fillcolor === undefined) ? 
                        "" : "<FILLCOLOR>" + fOptions.fillcolor + "</FILLCOLOR>";
            },this),
         	opacity: OpenLayers.Function.bind(function(){
                return (fOptions.opacity === null || fOptions.opacity === undefined) ? 
                        "" : "<OPACITY>" + fOptions.opacity + "</OPACITY>";
            },this),
            geometry: OpenLayers.Function.bind(function(){
                return (fOptions.geometry === null || fOptions.geometry === undefined) ? 
                        "" : this._geometryToString(fOptions.geometry);
            },this)
        });
        requestString = '<FeatureCollection>' + requestString + '</FeatureCollection>';
		
        var params = {
			REQUEST: "UpdateFeatures",
			userid: this.userid
		};
        
        var xhr = OpenLayers.Request.POST({
            url: this.url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	/**
     * APIMethod: deleteFeatures
     * 删除要素操作。
     *   
     * Parameters:
     * options - {Object} 请求参数。
     * 	bookmarkId - {String} 对象的唯一标识。必填。
     *  type - {String} 对象类型，必填。（点，线，面，point,line,polygon）
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     *   plotService.deleteFeatures({
	 *		 bookmarkId: "23434-3434-23234-1234",
	 *       type: "line"
	 *   },function(result){
	 *      //doSomeThing...
     *   });
     *   (end)
     */		
	deleteFeatures: function(options, successFn, failFn){
		var requestTemplate = 
			"<FeatureCollection>"+
				"<Feature>"+
					"<BOOKMARKID>${bookmarkId}</BOOKMARKID>"+
					"<TYPE>${type}</TYPE>"+
				"</Feature>"+
			"</FeatureCollection>";
			
		var params = {
			REQUEST: "DeleteFeatures",
			userid: this.userid
		};
		var url = this.url;
		
        var requestString = OpenLayers.String.format(requestTemplate,{
			bookmarkId: options.bookmarkId,
            type: options.type
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},
    
	/**
     * APIMethod: queryFeatures
     * 查询要素操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   requestType - 对象查询类型,必填(private私有,public公开,pending绑定,all所有)。
     *   filters - [],可以有零到多个。
     *			例如：filters : [{type: 'PropertyIsEqueTo',propertyName: "plotclass",propertyValue: currentClassid},
	 *				  	{type: 'PropertyIsLike',propertyName: "TITLE",propertyValue: 'ATM'}
	 *				  ],
     *   orderBy - {Object} 排序类型 例如： orderBy : {property: 'EDITTIME',type: 'desc'}
     *    		orderBy的请求参数包括 property和type。
     *   
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 方法使用举例:
     * (code)
     * plotService.queryFeatures({
	 *		requestType:"public",
	 *		filters: [{type: 'PropertyIsEqueTo',propertyName: "plotclass",propertyValue: currentClassid},
	 *			{type: 'PropertyIsLike',propertyName: "TITLE",propertyValue: 'ATM'}
	 *		],
	 *		orderBy: {property: 'EDITTIME',type: 'desc'}
	 *	},function(features){
	 *     //doSomeThing...
	 *  }); 
	 * (end)
     */		
	queryFeatures: function(options, successFn, failFn){
        
		var params = {
			REQUEST: "QueryFeatures",
			userid: this.userid
		};
		var url = this.url;
        	
		var requestTemplate = 
			"<FeatureCollection>"+
			    "<Query>"+
                    "${pagingInfo}"+
			        "<requestType>${requestType}</requestType>"+
			        "${orderBy}"+
					"${filter}"+
			    "</Query>"+
			"</FeatureCollection>";
        var requestString = OpenLayers.String.format(requestTemplate,{
            pagingInfo: OpenLayers.Function.bind(function(){
                return this._pagingToString(options.maxPerPage,options.currentPage);
            },this),
            classcode: options.classcode,
			filter : OpenLayers.Function.bind(function(){
                return this._filterToString(options.filters);
            },this),
            orderBy:OpenLayers.Function.bind(function(){
				if(options.orderBy === undefined) {
					return "";
				}
                return this._orderByToString(options.orderBy.property,options.orderBy.type);
            },
            this), requestType:options.requestType
		});
        				
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });
	},
    
    _getGeometryType: function(geometry){
        var maping = {
            "OpenLayers.Geometry.Point": "point",
            "OpenLayers.Geometry.LineString": "line",
            "OpenLayers.Geometry.Polygon": "polygon"
        };
        return maping[geometry.CLASS_NAME];
    },
	
	_filterToString:function(filters){
		if(!filters) {
			return "";
		}
		var filterString = "";
		if(!(Geo.Util.isArray(filters))) {
			filters = [filters];
		} 
		for(var i = 0; i < filters.length; i++) {
				filterString +=  "<Filter>"+
	            "<"+filters[i].type+">"+
	            "<PropertyName>"+filters[i].propertyName+"</PropertyName>"+
	            "<Literal>"+filters[i].propertyValue+"</Literal>"+
	            "</"+filters[i].type+">";
		        filterString += "</Filter>";
		}
		
		return filterString;
	},
    
    _pagingToString: function(curPage, maxPerPage){
        maxPerPage = maxPerPage || this.maxPerPage;
        curPage = curPage || 1;
        return "<numPerPage>" + maxPerPage + "</numPerPage>"+
                "<curPage>" + curPage + "</curPage>";
    },
    
    _orderByToString: function(property, type){
        var str = "<orderBy>"+
    	            "<PropertyName>" + property + "</PropertyName>"+
					"<OrderType>" + type + "</OrderType>"+
    	        "</orderBy>";
        return property ? str : "";
    },
    
    _geometryToString: function(geometry){
        var parser = new OpenLayers.Format.GML();
        var xmlnode = parser.buildGeometryNode(geometry);
        return '<geometry>' + xmlnode.xml + '</geometry>';
    },
    
	//解析器
	_parserGetcapabilities:  function(result){
			return result;
	},
    
    _parserFeatures: function(resultString){
        var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
        parser.featureName = "featureMember";
        var features = parser.read(resultString);
        return features;
    },
    
	_parserSuccessResult: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	_parseToXML: function(result){
        var xmlParser = new OpenLayers.Format.XML();
		return xmlParser.read(result.responseText);

	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},

	CLASS_NAME: "Geo.Service.Plot"
});/**
 * Class: Geo.Service.ShortestPath
 * 最短路径服务类。GeoGlobe 不支持本服务的创建，该类已废弃。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.ShortestPath = Geo.Class(Geo.Service, {

	
	/**
     * Constructor: Geo.Service.ShortestPath
     * Geo.Service.ShortestPath类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		OpenLayers.loadURL(url,params,this,successFn,failFn);
	},
	
	/**
     * APIMethod: shortestPath
     * 最短路径查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   start - {String} 起点坐标。
     *   end - {String}终点坐标。
     *   network - {String}网络模型名称。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * var service = new Geo.Service.ShortestPath();
     * service.shortestPath({
     *         start: "113,29",
     *         end: "116,39",
     *         network: "RouteModelDis"
     *     },function(features){
     *         //doSomeThing
     *     });
     */	
	shortestPath: function(options, successFn, failFn){
		var url = this.url;
        var startcoord = options.start;
        var endcoord = options.end;
        var network = options.network;
		var params = {
			REQUEST:"ShortestPath",
			STARTCOORD: startcoord,
			ENDCOORD: endcoord,
			NETWORKNAME: network
		};
		OpenLayers.loadURL(url,params,this,function(result){
            var features = this._parseShortestPath(result);
            successFn(features);
        },failFn);
	},
    
    //解析最短路径结果
    _parseShortestPath: function(result){
		var xmlParser = new OpenLayers.Format.XML();
		if(!result.responseXML){
			result.responseXML = xmlParser.read(result.responseText);
		}
        var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
        var features = parser.read(result.responseXML);
        return features;
    },
    
	//解析服务能力描述信息
	_parseCapabilities: function(xml){
		
	},
	
	/*
	 * APIMethod:findRoute
	 * 返回请求起始坐标对应路网模型的导航链路信息
	 */
	findRoute: function(options, successFn, failFn) {
		var params = {
			REQUEST: "FindRoute",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
        var required = {
            data: true,
            orig: true,
            dest: true
        };
        for (var prop in required) {
            if (!(prop in config)) {
                throw new Error("Missing property '" + prop + "'");
            }
        }
		params.DATA = options.data;
		params.ORIG = options.orig;
		params.DEST = options.dest;
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
	  	if(options.radius !== null && options.radius !== undefined){
            params.RADIUS = options.radius;
        }
        
        if(options.queryType !== null && options.queryType !== undefined){
            params.QUERYTYPE = options.queryType;
        }
		
		if(options.midpos !== null && options.midpos !== undefined){
            params.MIDPOS = options.midpos;
        }
		if(options.avoidPos !== null && options.avoidPos !== undefined){
            params.AVOIDPOS = options.avoidPos;
        }
		if(options.filterRoute !== null && options.filterRoute !== undefined){
            params.FILTERROUTE = options.filterRoute;
        }
		if(options.resultCount !== null && options.resultCount !== undefined){
            params.RESULTCOUNT = options.resultCount;
        }
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                var Routes = this._parseFindRouteResult(result);
                successFn(Routes);
            },
            failure: failFn
        });
	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result.responseText);
	},
	
	_parseFindRouteResult: function(result) {
		var routesTemp =  this._parseToJSON(result);
		this._parserFeatures(routesTemp);
		var Routes = {
			Route:routesTemp.Routes.Route
		}
		return Routes;
	},
	
	_parserFeatures: function(data) {
		var route = data.Routes.Route;
		if(route) {
			if(!(Geo.Util.isArray(route))) {
				route = [route];
				data.Routes.Route = route;
			}
			for(var i = 0,j = route.length; i < j;i++) {
				var item = route[i].Item;
				var features = [];
				if(item) {
					if(!(Geo.Util.isArray(item))) {
						item = [item];
					}
					for(var m = 0, n = item.length; m < n; m++) {
						var feature = this._getFeatureForFindRoute(item[m]);
						features.push(feature);
					}
				}
				route[i].Item = features;
			}
		}
	},
	
	_getFeatureForFindRoute: function(attribute) {
		if(!attribute || !attribute.Geometry) {
			throw "FindRoute查询中，查询结果缺少item或Geometry";
			return;
		}
		var geometry = attribute.Geometry;
		if(geometry.gml_Point) {
			geometry = this._geometryForFindRoute["point"](geometry.gml_Point);
		}else if(geometry.gml_LineString) {
			geometry = this._geometryForFindRoute["line"](geometry.gml_LineString);
		}
		
		var feature = new Geo.Feature.Vector(geometry,attribute);
		return feature;
	},
	
	_geometryForFindRoute : {
		point: function(pointStr) {
			var pointArr = pointStr.split(",");
			var point = new Geo.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
			return point;
		},
		line: function(lineStr) {
			if(lineStr) {
				var pointStrArr = lineStr.split(" ");
				var pointArr = [];
				for(var i = 0,j = pointStrArr.length; i < j; i++) {
					var pointGeometry = _geometryForFindRoute["point"](pointStrArr[i]);
					pointArr.push(pointGeometry);
				}
				var lineGeometry = new OpenLayers.Geometry.LineString(pointArr);
				return lineGeometry;
			}else {
				return null;
			}
		}
	},
	
	/**
	 * APIMethod:getRouteInfo
	 * 返回请求编号查询到路段的详细信息。
	 */
	getRouteInfo: function(options, successFn, failFn) {
		var params = {
			REQUEST: "GetRouteInfo",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
		if(!options.data || !options.id){
            throw "Error!Not data and id for bus query.";
            return;
        }
		params.DATA = options.data;
		params.ID = options.id;
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var features = this._parserFeaturesForRouteInfo(result);
            	successFn(features);
            },
            failure: failFn
        });
	},	
	
	_parserFeaturesForRouteInfo: function(resultString){
        var resultJson = this._parseToJSON(resultString);
		var RouteInfo = this._getFeaturesForRouteInfo(resultJson);
		return RouteInfo;
    },
	
	_getFeaturesForRouteInfo: function(data) {
		var route = data.RouteInfo.Route;
		if(route) {
			if(!Geo.Util.isArray(route)) { 
				route = [route];
				data.RouteInfo.Route = route;
			}
			var features = [];
			for(var i = 0,j = route.length; i < j;i++) {
				var routeTemp = route[i];
				var feature = this._getFeatureForFindRoute(routeTemp);
				features.push(feature);
			}
			data.RouteInfo.Route = features;
		}
		var RouteInfo = {
			Route:data.RouteInfo.Route
		}
		return RouteInfo;
	},
    
	CLASS_NAME: "Geo.Service.ShortestPath"
});/**
 * Class: Geo.Service.Route
 * 最短路径服务类。该类已废弃。请使用Geo.Service.GeoRoute。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.Route = Geo.Class(Geo.Service, {

	
	/**
     * Constructor: Geo.Service.Route
     * Geo.Service.Route类的构造函数
     *
     * Parameters:
     * name - {String} 服务名称
     * url - {String} 服务地址
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		OpenLayers.loadURL(url,params,this,successFn,failFn);
	},
	
	/*
	 * APIMethod:findRoute
	 * 返回请求起始坐标对应路网模型的导航链路信息
	 * Parameters:
	 * options - {Object} 请求参数
	 * 		data - {String} （必选）路网名称
	 * 		orig - {String} （必选）起点坐标   例如："120,30"
	 * 		dest -  {String} （必选）终点坐标
	 * 		radius — {Number}(可选) 抓取起点与终点距离有效道路的半径范围，单位为米，默认值为10米
	 * 		queryType - {Number} (可选)导航查询类型。0表示最快时间；1表示最短路径，默认为按最短路径查询
	 * 		midpos - {String}(可选) 途径点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * 		avoidPos - {String}(可选) 规避点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 *      filterRoute - {Number}(可选) 导航查询的途径路段类型过滤，可选值：0 – 不进行过滤；1 – 过滤高速公路；2 – 过滤小路；默认值为0
	 *      resultCount - {Number}返回导航查询的最大解决方案数量，参数值必须为正整数,默认值为1
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new  Geo.Service.ShortestPath("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.findRoute({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routes){
	 *				debugger;
	 *			});
	 *   (end)
	 */
	findRoute: function(options, successFn, failFn) {
		var params = {
			REQUEST: "FindRoute",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
        var required = {
            data: true,
            orig: true,
            dest: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("Missing property '" + prop + "'");
            }
        }
		params.DATA = options.data;
		params.ORIG = options.orig;
		params.DEST = options.dest;
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
	  	if(options.radius !== null && options.radius !== undefined){
            params.RADIUS = options.radius;
        }
        
        if(options.queryType !== null && options.queryType !== undefined){
            params.QUERYTYPE = options.queryType;
        }
		
		if(options.midpos !== null && options.midpos !== undefined){
            params.MIDPOS = options.midpos;
        }
		if(options.avoidPos !== null && options.avoidPos !== undefined){
            params.AVOIDPOS = options.avoidPos;
        }
		if(options.filterRoute !== null && options.filterRoute !== undefined){
            params.FILTERROUTE = options.filterRoute;
        }
		if(options.resultCount !== null && options.resultCount !== undefined){
            params.RESULTCOUNT = options.resultCount;
        }
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                var Routes = this._parseFindRouteResult(result);
                successFn(Routes);
            },
            failure: failFn
        });
	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		var xml = result.responseXML.xml;
		return parser.read(xml);
	},
	
	_parseFindRouteResult: function(result) {
		var routesTemp =  this._parseToJSON(result);
		var rTemp = this._parserFeatures(routesTemp);
		var Routes = {
			Route:rTemp
		}
		return Routes;
	},
	
	_parserFeatures: function(data) {
		if(!data.Routes) {
			return {};
		}
		var route = data.Routes.Route;
		if(route) {
			if(!(Geo.Util.isArray(route))) {
				route = [route];
				data.Routes.Route = route;
			}
			for(var i = 0,j = route.length; i < j;i++) {
				var item = route[i].Item;
				var features = [];
				if(item) {
					if(!(Geo.Util.isArray(item))) {
						item = [item];
					}
					for(var m = 0, n = item.length; m < n; m++) {
						var feature = this._getFeatureForFindRoute(item[m]);
						features.push(feature);
					}
				}
				route[i].Item = features;
			}
		}
		return route;
	},
	
	_getFeatureForFindRoute: function(attribute) {
		if(!attribute || !attribute.Geometry) {
			throw "FindRoute查询中，查询结果缺少item或Geometry";
			return;
		}
		var geometry = attribute.Geometry;
		if(geometry.gml_Point) {
			geometry = this._geometryForFindRoute["point"](geometry.gml_Point);
		}else if(geometry.gml_LineString) {
			geometry = this._geometryForFindRoute["line"](geometry.gml_LineString);
		}
		
		var feature = new Geo.Feature.Vector(geometry,attribute);
		return feature;
	},
	
	_geometryForFindRoute : {
		point: function(pointStr) {
			var pointArr = pointStr.split(",");
			var point = new Geo.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
			return point;
		},
		line: function(lineStr) {
			if(lineStr) {
				var pointStrArr = lineStr.split(" ");
				var pointArr = [];
				for(var i = 0,j = pointStrArr.length; i < j; i++) {
					var pointGeometry = Geo.Service.Route.prototype._geometryForFindRoute["point"](pointStrArr[i]);
					pointArr.push(pointGeometry);
				}
				var lineGeometry = new OpenLayers.Geometry.LineString(pointArr);
				return lineGeometry;
			}else {
				return null;
			}
		}
	},
	
	/*
	 * APIMethod:getRouteInfo
	 * 返回请求编号查询到路段的详细信息
	 * 	Parameters:
	 * 		options - {Object} 请求参数
	 * 			data - {String} （必选）路网名称
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new  Geo.Service.ShortestPath("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.getRouteInfo({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routes){
	 *				debugger;
	 *			});
	 *   (end)
	 */
	getRouteInfo: function(options, successFn, failFn) {
		var params = {
			REQUEST: "GetRouteInfo",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
		if(!options.data || !options.id){
            throw "Error!Not data and id for bus query.";
            return;
        }
		params.DATA = options.data;
		params.ID = options.id;
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var features = this._parserFeaturesForRouteInfo(result);
            	successFn(features);
            },
            failure: failFn
        });
	},	
	
	_parserFeaturesForRouteInfo: function(result){
        var resultJson = this._parseToJSON(result);
		var RouteInfo = this._getFeaturesForRouteInfo(resultJson);
		return RouteInfo;
    },
	
	_getFeaturesForRouteInfo: function(data) {
		var routeInfoTemp = data.RouteInfo;
		if(!routeInfoTemp || !routeInfoTemp.Route) {
			var RouteInfo = {
				Route:{}
			}
			return RouteInfo;
		}
		var route = routeInfoTemp.Route;
		if(route) {
			if(!(Geo.Util.isArray(route))) {
				route = [route];
				routeInfoTemp.Route = route;
			}
			var features = [];
			for(var i = 0,j = route.length; i < j;i++) {
				var routeTemp = route[i];
				var feature = this._getFeatureForFindRoute(routeTemp);
				features.push(feature);
			}
			routeInfoTemp.Route = features;
		}
		var RouteInfo = {
			Route:routeInfoTemp.Route
		}
		return RouteInfo;
	},
    
	CLASS_NAME: "Geo.Service.Route"
	
});/**
 * Class: Geo.Service.TAS
 * 地形分析服务类。
 *
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.TAS = Geo.Class(Geo.Service, {

    /**
     * Constructor: Geo.Service.TAS
     * Geo.Service.TAS 类的构造函数。
     *
     * Parameters:
     * 	name - {String} 服务名称。
     * 	url - {String} 服务地址。
     * 	options - {Object} 实例的选项设置，此参数可选。
     *
     */
    initialize: function(name, url, options){
        this.name = name;
        this.url = url;
        OpenLayers.Util.extend(this, options);
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * 	successFn - {Function} 请求成功的回调函数。
     * 	failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            VERSION: "1.0.0",
            SERVICE: "TAS"
        };
        OpenLayers.loadURL(url, params, null, successFn, failFn);
    },
    
    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            VERSION: "1.0.0",
            SERVICE: "TAS"
        };
        var xhr = OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    
    /**
     * APIMethod: pointAltitude
     * 地形高程查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.pointAltitude({
     *      layerLevel: 3,
     *      pointCount: 1,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049",
     *      subjoin : 10
     *  })
     *  (end)
     */
    pointAltitude: function(options, successFn, failFn){
        this._sendRequest("PointAltitude", options, successFn, failFn);
    },
    
    /**
     * APIMethod: pointSlope
     * 坡度查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.pointSlope({
     *      layerLevel: 3,
     *      pointCount: 1,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049",
     *      subjoin : 10
     *  })
     *  (end)
     */
    pointSlope: function(options, successFn, failFn){
        this._sendRequest("PointSlope", options, successFn, failFn);
    },
    
    /**
     * APIMethod: pointAspect
     * 坡向查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.pointAspect({
     *      layerLevel: 3,
     *      pointCount: 1,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049",
     *      subjoin : 10
     *  }
     *  (end)
     */
    pointAspect: function(options, successFn, failFn){
        this._sendRequest("PointAspect", options, successFn, failFn);
    },
    
    /**
     * APIMethod: surfaceArea
     * 表面面积查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.surfaceArea({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    surfaceArea: function(options, successFn, failFn){
        this._sendRequest("SurfaceArea", options, successFn, failFn);
    },
    
    /**
     * APIMethod: volume
     * 体积查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.volume({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    volume: function(options, successFn, failFn){
        this._sendRequest("Volume", options, successFn, failFn);
    },
    
    /**
     * APIMethod: surfaceDistance
     * 表面矩离查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.surfaceDistance({
     *      layerLevel: 3,
     *      pointCount: 2,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061123,25.293686487049",
     *      subjoin : 10
     *  }
     *  (end)
     */
    surfaceDistance: function(options, successFn, failFn){
        this._sendRequest("SurfaceDistance", options, successFn, failFn);
    },
    
    /**
     * APIMethod: profileAnalysis
     * 剖面分析操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.profileAnalysis({
     *      layerLevel: 3,
     *      pointCount: 2,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061123,25.293686487049",
     *      subjoin : 10
     *  }
     *  (end)
     */
    profileAnalysis: function(options, successFn, failFn){
        this._sendRequest("ProfileAnalysis", options, successFn, failFn);
    },
    
    /**
     * APIMethod: contourAnalysis
     * 等高线分析操作
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.contourAnalysis({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    contourAnalysis: function(options, successFn, failFn){
        this._sendRequest("ContourAnalysis", options, successFn, failFn);
    },
    
    /**
     * APIMethod: topPoint
     * 顶点查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.topPoint({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    topPoint: function(options, successFn, failFn){
        this._sendRequest("TopPoint", options, successFn, failFn);
    },
    
    /**
     * APIMethod: singlePointVisiable
     * 单点可视查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.singlePointVisiable({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    singlePointVisiable: function(options, successFn, failFn){
        this._sendRequest("SinglePointVisiable", options, successFn, failFn);
    },
    
    /**
     * APIMethod: floodAnalysis
     * 洪水淹沿分析操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.floodAnalysis({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    floodAnalysis: function(options, successFn, failFn){
        this._sendRequest("FloodAnalysis", options, successFn, failFn);
    },
    
    /**
     * APIMethod: topLowPoint
     * 最高点与最低点的查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.topLowPoint({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    topLowPoint: function(options, successFn, failFn){
        this._sendRequest("TopLowPoint", options, successFn, failFn);
    },
    
    /**
     * APIMethod: getMetaData
     * 元数据查询操作。
     *
     * Parameters:
     * caller - {Object}
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getMetaData: function(caller, successFn, failFn){
        this._sendRequest("GetMetaData", options, successFn, failFn);
    },
    
    //发送请求
    _sendRequest: function(action, options, successFn, failFn){
        var url = this.url;
        var layerLevel = options.layerLevel;
        var layerName = options.layerName;
        var pointCount = options.pointCount;
        var coordinates = this._convertRadian(options.coordinates);
        var subjoin = options.subjoin || 0;
        var params = {
            REQUEST: action,
            LAYERLEVEL: layerLevel,
            LAYERNAME: layerName,
            POINTCOUNT: pointCount,
            COORDINATES: coordinates,
            SUBJOIN: subjoin
        };
        OpenLayers.loadURL(url, params, this, function(result){
            var resultObj = this._parseResult(result);
            successFn(resultObj);
        }, failFn);
    },
    
    //经纬度转弧度
    _convertRadian: function(coordinates){
        var arr = coordinates.split(",");
        for (var i = 0; i < arr.length; i++) {
            arr[i] = arr[i] * 3.1415926 / 180;
        }
        return arr.join(",");
    },
    
    _countCoord: function(pointString){
        var arr = pointString.split(",");
        return arr.length / 2;
    },
    
    _parseResult: function(result){
        var errorResult = this._checkIsError(result.responseText);
        if (!errorResult) {
            var parser = new Geo.Util.Format.XML2JSON();
            var resultObj = parser.read(result.responseText);
            return resultObj;
        }
        return errorResult;
    },
    
    CLASS_NAME: "Geo.Service.TAS"
});
/**
 * Class: Geo.Service.WPS
 * OGC-WPS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WPS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WPS
     * Geo.Service.WPS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		OpenLayers.loadURL(url,null,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		var xhr = OpenLayers.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: describeProcess
     * 获取指定Process描述信息。
     * 
     * Parameters:
     * process - {String} Process名称。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * serviceObj.describeProcess("buffer", function(result){
     *     alert(result.reponseText);
     * });
     * (end)
     */	
	describeProcess: function(process,successFn,failFn){
		var requestTemplate = 
			'<DescribeProcess xmlns="http://www.opengis.net/wps/1.0.0" ' +
							  'xmlns:ows="http://www.opengis.net/ows/1.1" ' +
							  'xmlns:xlink="http://www.w3.org/1999/xlink" ' +
							  'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' +
							  'xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsDescribeProcess_request.xsd" ' +
							  'service="WPS" ' +
							  'version="1.0.0" ' +
							  'language="en-CA">' +
			    '<ows:Identifier>' +
			        '${process}' +
			    '</ows:Identifier>' +
			'</DescribeProcess>';
		var postStr = OpenLayers.String.format(
			requestTemplate,
			{process:process}
		);
		
		var request = "DescribeProcess";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		
		var xhr = new OpenLayers.Request.POST({
			url: url,
			data: postStr,
			scope: this,
			success:successFn,
			failure:failFn
		});
	},
	
	/**
     * APIMethod: execute
     * 执行分析操作。
     * 
     * Parameters:
     * content - {String} 分析操作请求内容。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     *       var requestStr = '<wps:Execute service="WPS" version="1.0.0" 
     *       xmlns:gml="http://www.opengis.net/gml" 
     *       xmlns:wps="http://www.opengis.net/wps/1.0.0" 
     *       xmlns:ows="http://www.opengis.net/ows/1.1" 
     *       xmlns:wfs="http://www.opengis.net/wfs" 
     *       xmlns:xlink="http://www.w3.org/1999/xlink" 
     *       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
     *       xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd">' +
     *           '<ows:Identifier>Intersection</ows:Identifier>' +
     *           '<wps:DataInputs>' +
     *           '<wps:Input>' +
     *           '<ows:Identifier>InputPolygon</ows:Identifier>' +
     *           '<wps:Data>' +
     *           '<wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">' +
     *           '<wfs:FeatureCollection xmlns:wfs="http://www.opengis.net/wfs">' +
     *           '<gml:featureMember xmlns:gml="http://www.opengis.net/gml">' +
     *           '<feature:features xmlns:feature="http://mapserver.gis.umn.edu/mapserver" fid="Geo.Feature.Vector_112">' +
     *           '<feature:geometry>' +
     *           '<gml:LineString>' +
     *           '<gml:coordinates decimal="." cs="," ts=" ">100.40625,12.09765625 110.10546875,45.83203125</gml:coordinates>' +
     *           '</gml:LineString>' +
     *           '</feature:geometry>' +
     *           '</feature:features>' +
     *           '</gml:featureMember>' +
     *           '</wfs:FeatureCollection>' +
     *           '<wfs:FeatureCollection xmlns:wfs="http://www.opengis.net/wfs">' +
     *           '<gml:featureMember xmlns:gml="http://www.opengis.net/gml">' +
     *           '<feature:features xmlns:feature="http://mapserver.gis.umn.edu/mapserver" fid="Geo.Feature.Vector_118">' +
     *           '<feature:geometry>' +
     *           '<gml:LineString>' +
     *           '<gml:coordinates decimal="." cs="," ts=" ">100.40625,30.09765625 110.10546875,30.83203125</gml:coordinates>' +
     *           '</gml:LineString>' +
     *           '</feature:geometry>' +
     *           '</feature:features>' +
     *           '</gml:featureMember>' +
     *           '</wfs:FeatureCollection>' +
     *           '</wps:ComplexData>' +
     *           '</wps:Data>' +
     *           '</wps:Input>' +
     *           '</wps:DataInputs>' +
     *           '<wps:ResponseForm>' +
     *           '<wps:RawDataOutput>' +
     *           '<ows:Identifier>BufferedPolygon</ows:Identifier>' +
     *           '</wps:RawDataOutput>' +
     *           '</wps:ResponseForm>' +
     *           '</wps:Execute>';
     *           
     *           serviceObj.execute(requestStr, function(result){});
     * (end)
     */	
	execute: function(content,successFn,failFn){
		var request = "Execute";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		
		var xhr = new OpenLayers.Request.POST({
			url: url,
			data: content,
			scope: this,
			success:successFn,
			failure:failFn
		});
	},

	CLASS_NAME: "Geo.Service.WPS"
});/**
 * Class: Geo.Service.WFS
 * OGC-WFS服务类。
 * 说明：本类也适用于聚合网络要素服务（Aggregation Web Feature Service简称AWFS）
 * 和地名地址要素服务（Web Feature Service Gazetteer简称WFS-G）。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WFS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WFS
     * Geo.Service.WFS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WFS",
			VERSION: "1.0.0"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},

	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WFS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: describeFeatureType
     * 获取要素类型描述操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     *   params有三个参数(service,version,request)默认可以不填，其中version默认值是1.0.0，如果要设置其他版本请设置version参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * serviceObj.describeFeatureType({
     *     TypeName: "RES1_T_PN"
     * }, showResult);
     * (end)
     */	
	describeFeatureType: function(params,successFn,failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WFS",
			version: "1.0.0",
			request: "DescribeFeatureType"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: getFeature
     * 获取要素操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	TypeName - {String} 必选 类型名称。
     * 	version - {String} 版本，默认值是1.0.0,如果用户请求的服务版本不是1.0.0，请设置该参数。
     *  MaxFeatures - {Integer} 可选 查询的返回的结果总数。
     *  filter - {Geo.Filter} 可选 过滤器。
     *  以上是常用的属性，其他属性请参考OGC-WFS标准。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * 	 serviceObj.getFeature({
     *      TypeName: "RES1_T_PN",
     *      MaxFeatures: 10
     *   }, function(){});
     * (end)
     */	
	getFeature: function(params,successFn,failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WFS",
			version: "1.0.0",
			request: "GetFeature"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},

	CLASS_NAME: "Geo.Service.WFS"
	
});/**
 * Class: Geo.Service.WFST
 * OGC-WFST服务类。Web要素服务-T（Web Feature Service-Transaction简称WFST）遵循OGC的WFS1.0.0规范，
 * 本服务提供对要素的增加、修改、删除等事务操作。
 *
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WFST = Geo.Class(Geo.Service, {
	
    /**
     * APIProperty: xy
     * {Boolean} 值为true时，为(x,y)顺序。值为false时，为(y,x)顺序。
     */ 
    xy: true,

    /**
     * Constructor: Geo.Service.WFST
     * Geo.Service.WFST类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     */
    initialize: function(name, url, options){
        Geo.Service.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        OpenLayers.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS"
        };
        var xhr = OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    
    /**
     * APIMethod: describeFeatureType
     * 获取要素类型描述操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     *   params有三个参数(service,version,request)默认可以不填，其中version默认值是1.0.0，如果要设置其他版本请设置version参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例：
     * (code)
     * serviceObj.describeFeatureType({
     *     TypeName: "RES1_T_PN"
     * }, showResult);
     * (end)
     */
    describeFeatureType: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "DescribeFeatureType"
        };
        OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        
        OpenLayers.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: getFeature
     * 获取要素操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	TypeName - {String} 必选 类型名称。
     * 	version - {String} 版本，默认值是1.0.0,如果用户请求的服务版本不是1.0.0，请设置该参数。
     *  MaxFeatures - {Integer} 可选 查询的返回的结果总数。
     *  filter - {Geo.Filter} 可选 过滤器。
     *  以上是常用的属性，其他属性请参考OGC-WFS标准。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     * 	 serviceObj.getFeature({
     *      TypeName: "RES1_T_PN",
     *      MaxFeatures: 10
     *   }, function(){});
     * (end)
     */
    getFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "GetFeature"
        };
        OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        
        OpenLayers.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: lockFeature
     * 锁定要素操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	typeName - {String} 必选 指定操作的图层类型名称。
     * 	version - {String} 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     *  expiry - {Number} 可选 锁定的分钟数，如果没有则默认为1分钟。
     *  lockAction - {String} 可选 指定如何获得锁，如果没有则默认为"ALL"。
     *  filter - {Geo.Filter} 可选 操作要素的条件过滤器。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    lockFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "LockFeature",
            expiry: 1,
            lockAction: "ALL"
        };
        OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
        
		//解析filter对象，转换为XML字符串。
		var filterXMLString = this._parserFilterToString(params.filter);
        
        var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<LockFeature version="${version}" service="${service}" lockAction="${lockAction}" expiry="${expiry}" ' +
	        'xmlns:wfs=" http://www.opengis.net/wfs" ' +
	        'xmlns:gml=" http://www.opengis.net/gml" ' +
	        'xmlns:myns=" http://www.someserver.com/myns" ' +
	        'xmlns:ogc=" http://www.opengis.net/ogc" ' +
	        'xmlns:xsi=" http://www.w3.org/2001/XMLSchema-instance" ' +
	        'xsi:schemaLocation="http://www.opengis.net/wfs ../wfs/1.1.0/WFS.xsd">' +
	        '<Lock typeName="${typeName}">' +
		        '${filterXMLString}' +
	        '</Lock>' +
        '</LockFeature>';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            version: params.version,
            service: params.service,
            lockAction: params.lockAction,
            expiry: params.expiry,
            typeName: params.typeName,
            filterXMLString: filterXMLString
        });
        
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
        
        //        OpenLayers.loadURL(url, params, this, function(result){
        //            successFn(result);
        //        }, failFn);
    },
    
    /**
     * APIMethod: transaction
     * 要素的事务操作，可以对服务中的要素内容进行增加、删除和修改操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	version {String} 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     * 	releaseAction {String} 可选 指定如何释放锁，提供有"ALL"和"SOME"两种方式，默认值是"ALL"。
     *             在做更新或删除要素的时候，releaseAction="ALL"或"SOME"决定LockId对应的所有要素是否全部释放。
     *             如果是"ALL",表示LockId对应的所有要素全部解锁释放。
     *             如果是"SOME",表示LockId只对正在操作的要素解锁释放，其他要素还是保持锁定状态。
     *  lockId {String} 可选 锁定编号。
     * inserts - {Object} 添加要素的请求参数。
     *  features {Array(<Geo.Feature.Vector>)} 必选 一系列要素的集合。
     *  typeName {String} 必选 指定操作的图层类型名称。
     * updates - {Object} 修改要素的请求参数。
     *  feature {<Geo.Feature.Vector>} 必选 要素对象。
     *  typeName {String} 必选 指定操作的图层类型名称。
     *  filter {Geo.Filter} 可选 操作要素的条件过滤器。
     * deletes - {Object} 删除要素的请求参数。
     *  typeName {String} 必选 指定操作的图层类型名称。
     *  filter {Geo.Filter} 可选 操作要素的条件过滤器。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    transaction: function(params, inserts, updates, deletes, successFn, failFn){
		var url = this.url;
		//默认参数
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "Transaction",
            releaseAction: "ALL"
        };
		//合并默认参数，获得实际请求参数
		OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
		
		//定义post请求模板
		var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<wfs:Transaction releaseAction="${releaseAction}" handle="Transaction 01" version="${version}" service="${service}" '+
		'xmlns="http://www.someserver.com/myns" ' +
		'xmlns:gml="http://www.opengis.net/gml" ' +
		'xmlns:ogc="http://www.opengis.net/ogc" ' +
		'xmlns:wfs="http://www.opengis.net/wfs" ' +
		'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
	        '${lockIdString}' +
	        '${transactionString}' +
        '</wfs:Transaction>';
		
		//lockId的请求标签
        var lockId = params.lockId;
		var lockIdString = "";
		if(lockId){
			lockIdString += '<LockId>' + lockId + '</LockId>';
		}
		
		var transactionString = "";
		//添加
        if (inserts) {
            transactionString += this._getInsertString(inserts);
        }
		//修改
		if(updates){
			transactionString += this._getUpdateString(updates);
		}
		//删除
		if(deletes){
			transactionString += this._getDeleteString(deletes);
		}
		
		//根据模板，获得post请求串
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            releaseAction: params.releaseAction,
            version: params.version,
            service: params.service,
            lockIdString: lockIdString,
            transactionString: transactionString
        });
		
		//请求失败的回调函数
		if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
		
		//发送post请求
		var xhr = new OpenLayers.Request.POST({
            url: url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
	},
	
	/**
     * Method: _getInsertString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * insert - {object} 添加要素的参数对象。
     *
     * Returns:
     * {String} 返回插入的XML字符串。
	 */
    _getInsertString: function(inserts){
		var features = inserts.features;
		var typeName = inserts.typeName;
		var insertStr = "";
        for (var i = 0; i < features.length; i++) {
            var feature = features[i];
            insertStr += '<wfs:Insert handle="Insert ' + i + '">' +
			this._getInsertFeatureString(feature, typeName) +
			'</wfs:Insert>';
        };
		return insertStr;
	},
	
	/**
     * Method: _getInsertFeatureString
     * 获取保存要素所需的外部属性串。 
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 要素。
     * typeName - {String} 指定操作的图层类型名称。
     *
     * Returns:
     * {String} 返回保存要素所需的外部属性串。
	 */
    _getInsertFeatureString: function(feature, typeName){
			        
        var str = "";
        
        var featureTemplate = '<${typeName}>${content}</${typeName}>';
        var geoTemplate = "<GEOMETRY>${geometry}</GEOMETRY>";
        
        var attrTemplate = "<${tag}><![CDATA[${value}]]></${tag}>"
        
        for (var item in feature.data) {
            if (item == "OID") {
                continue;
            }
            str += OpenLayers.String.format(attrTemplate, {
                value: (feature.data[item] ? feature.data[item] : ""),
                tag: item
            });
        }
        str += OpenLayers.String.format(geoTemplate, {
            geometry: this._getGeometryStringByFeature(feature)
        });
        
        str = OpenLayers.String.format(featureTemplate, {
            typeName: typeName,
            content: str
        });
        return str;
    },
	
	/**
     * Method: _getUpdateString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * updates - {object} 修改要素的参数对象。
     *
     * Returns:
     * {String} 返回XML字符串。
	 */
    _getUpdateString: function(updates){
        var filter = updates.filter;
        var typeName = updates.typeName;
        var feature = updates.feature;
        
        //要素的要修改的属性和值的XML字符串
        var propertyString = this._getUpdatePropertyString(feature);
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        var updateStr = '<wfs:Update typeName="' + typeName + '" handle="Update 1">' +
	        propertyString +
	        filterXMLString +
        '</wfs:Update>';
        
        return updateStr;
    },
	
	/**
     * Method: _getUpdatePropertyString
     * 获取修改的要素属性的XML字符串。 
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 要素。
     *
     * Returns:
     * {String} 返回修改的要素属性的XML字符串。
	 */
    _getUpdatePropertyString: function(feature){
        var str = "";
        for (var item in feature.data) {
            if (item == "OID") {
                continue;
            }
            str += '<wfs:Property>' +
	            '<wfs:Name><![CDATA[' +
	            item +
	            ']]></wfs:Name>' +
	            '<wfs:Value><![CDATA[' +
	            (feature.data[item] ? feature.data[item] : "") +
	            ']]></wfs:Value>' +
            '</wfs:Property>';
        }
        str += '<wfs:Property>' +
	        '<wfs:Name>Geometry</wfs:Name>' +
	        '<wfs:Value>' +
	        this._getGeometryStringByFeature(feature) +
	        '</wfs:Value>' +
        '</wfs:Property>';
        return str;
    },
	
	/**
     * Method: _getGeometryStringByFeature
     * 获取修改的要素geometry的XML字符串。 
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 要素。
     *
     * Returns:
     * {String} 返回修改的要素geometry的XML字符串。
	 */
	_getGeometryStringByFeature: function(feature){
		var gmlFormat = new OpenLayers.Format.GML({xy: this.xy});
        gmlFormat.buildCoordinatesNode = OpenLayers.Function.bind(function(geometry){
			var coordinatesNode = this.createElementNS(this.gmlns, "gml:coordinates");
            coordinatesNode.setAttribute("decimal", ".");
            coordinatesNode.setAttribute("cs", ",");
            coordinatesNode.setAttribute("ts", " ");
            
            var parts = [];
            
            if (geometry instanceof OpenLayers.Bounds) {
                if (this.xy) {
                    parts.push(geometry.left + "," + geometry.bottom);
                    parts.push(geometry.right + "," + geometry.top);
                }
                else {
                    parts.push(geometry.bottom + "," + geometry.left);
                    parts.push(geometry.top + "," + geometry.right);
                }
            }
            else {
                var points = (geometry.components) ? geometry.components : [geometry];
                for (var i = 0; i < points.length; i++) {
                    if (this.xy) {
                        parts.push(points[i].x + "," + points[i].y);
                    }
                    else {
                        parts.push(points[i].y + "," + points[i].x);
                    }
                }
            }
            
            var txtNode = this.createTextNode(parts.join(" "));
            coordinatesNode.appendChild(txtNode);
            
            return coordinatesNode;
			
        }, gmlFormat);
        
		//DOMElement. A GML polygon node.
		var gmlDOMElement = gmlFormat.buildGeometryNode(feature.geometry);
		//gmlDOMElement.setAttribute("srsName", "urn:ogc:def:crs:EPSG:6.9:4326");
		var xmlParser = new OpenLayers.Format.XML();
		var geometrtXmlStr = xmlParser.write(gmlDOMElement);
		return geometrtXmlStr;
    },
	
	/**
     * Method: _getDeleteString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * deletes - {object} 删除要素的参数对象。
     *
     * Returns:
     * {String} 返回插入的XML字符串。
	 */
    _getDeleteString: function(deletes){
        var filter = deletes.filter;
        var typeName = deletes.typeName;
        
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        
        var deleteStr = "";
        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete 1">';
        deleteStr += filterXMLString;
        deleteStr += '</wfs:Delete>';
        return deleteStr;
    },
	
	/**
     * Method: _parserFilterToString
     * 解析filter对象，转换为XML字符串。
     * 
     * Parameters:
     *  filter - {<Geo.Filter>} 可选 操作要素的条件过滤器。
     *
     * Returns:
     * {String} 过滤器字符串。
	 */
    _parserFilterToString: function(filter){
		//解析filter对象，转换为XML字符串。
		var filterXMLString = "";
        if (filter) {
            var filterFormatter = new Geo.Format.Filter.v1();
            var result = filterFormatter.write(filter);//{DOMElement} An ogc:Filter element.
			var xmlParser = new OpenLayers.Format.XML();
			filterXMLString = xmlParser.write(result);
			return filterXMLString;
        }
		return filterXMLString;
	},
	
    CLASS_NAME: "Geo.Service.WFST"
});
/**
 * Class: Geo.Service.WMS
 * OGC-WMS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WMS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WMS
     * Geo.Service.WMS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMS"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: getMap
     * 获取地图内容操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMS标准。
     * 	version - {String} 版本，默认值是1.1.1。
     *  layers - {String} 图层名称。
     *  styles - {String}  样式，默认是空串。
     *  srs -  - {String} 默认值是"EPSG:4326"。
     *  width - {Integer} 必选 宽。
     *  height - {Integer} 必选 长。
     *  format - {String} 默认值是"image/jpeg"。
     *  bbox  - {String} 必选 范围。
     * Returns:
 	 * {String} 地图内容图片地址。
 	 * 
 	 * 示例:
 	 * (code)
 	 * var url = wmsService.getMap({
     *     layers: "basic",
     *     bbox: "-180,-90,180,270",
     *     width: 256,
     *     height: 256
     * });
     * (end)         
     */	
	getMap: function(params){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WMS",
			version: "1.1.1",
			request: "GetMap",
			styles: "",
			srs:"EPSG:4326",
			exceptions: "application/vnd.ogc.se_inimage",
			format: "image/jpeg"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		var paramsString = OpenLayers.Util.getParameterString(params);
		return OpenLayers.Util.urlAppend(url, paramsString);
	},

	CLASS_NAME: "Geo.Service.WMS"
});/**
 * Class: Geo.Service.WMTS
 * OGC-WMTS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WMTS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WMTS
     * Geo.Service.WMTS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMTS"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMTS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: getTile
     * 获取瓦片内容操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMTS标准。
 	 * service - {String} 默认值是"WMTS"。
 	 * version - {String} 默认值是"1.0.0"。
 	 * layer - {String} 必选 图层标示。
 	 * style - {String} 必选 图层样式标示。
 	 * format - {String} 默认值是"image/png"。
 	 * TileMatrixSet - {String} 必选 矩阵集。
 	 * TileMatrix - {String} 必选 矩阵。
 	 * TileRow - {Integer} 必选 瓦片行号。
 	 * TileCol - {Integer} 必选 瓦片列号。
     * 
     * Returns:
 	 * {String} 瓦片内容图片地址。
 	 * 
 	 * 示例：
 	 * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
 	 * (end)
     */	
	getTile:function(params){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WMTS",
			version: "1.0.0",
			request: "GetTile",
			format: "image/png"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		var paramsString = OpenLayers.Util.getParameterString(params);
		return OpenLayers.Util.urlAppend(url, paramsString);
	},
	
	/**
     * APIMethod: getCapabilitiesForRest
     * WMTS-RESTful的获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilitiesForRest: function(successFn, failFn){
		var version = "1.0.0";
		var docName = "WMTSCapabilities.xml";
		var path = version + "/" + docName;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
		url = url + path;
		
        if (!failFn) {
            failFn = function(){
                this.failFn("GetCapabilities");
            };
        }
		
        OpenLayers.loadURL(url, null, this, function(result){
            successFn(result);
        }, failFn);
	},
	
	/**
     * APIMethod: getTileForRest
     * WMTS-RESTful的获取瓦片内容操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMTS标准。
     * 
     * Returns:
 	 * {String} 瓦片内容图片地址。
 	 * 	layer - {String} 必选 图层标示。
 	 * 	style - {String} 必选 图层样式标示。
 	 * 	format - {String} 必选 瓦片图片格式。默认值是"image/png"。
 	 * 	TileMatrixSet - {String} 必选 矩阵集。
 	 * 	TileMatrix - {String} 必选 矩阵。
 	 * 	TileRow - {Integer} 必选 瓦片行号。
 	 * 	TileCol - {Integer} 必选 瓦片列号。
 	 * 
 	 * 示例：
 	 * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
 	 * (end)
     */	
    getTileForRest: function(params){
		var layer = params.layer;
		var style = params.style;
		var tileMatrixSet = params.tileMatrixSet;
		var tileMatrix = params.tileMatrix;
		var tileRow = params.tileRow;
		var tileCol = params.tileCol;
		
		var formatSuffix = null;
		var format = params.format ? params.format : "image/png";
        var formatSuffixMap = {
            "image/png": "png",
            "image/png8": "png",
            "image/png24": "png",
            "image/png32": "png",
            "png": "png",
            "image/jpeg": "jpg",
            "image/jpg": "jpg",
            "jpeg": "jpg",
            "jpg": "jpg"
        };
		if (!formatSuffix) {
            formatSuffix = formatSuffixMap[format] || format.split("/").pop();            
        }
		
		var path = layer + "/" + style + "/" + tileMatrixSet + 
		"/" + tileMatrix + "/" + tileRow + "/" + tileCol + "." + formatSuffix;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
		url = url + path;
        return url;
    },

	CLASS_NAME: "Geo.Service.WMTS"
});/**
 * Class: Geo.Service.GeoWMTS
 * 武大吉奥WMTS服务类，该服务类基于OGC-WMTS服务类，并在OGC-WMTS服务类的基础上做了扩展，
 * 实现了获取多时相WMTS服务的时间版本信息的接口
 * 
 * Inherits from:
 * - <Geo.Service.WMTS>
 */
Geo.Service.GeoWMTS = Geo.Class(Geo.Service.WMTS, {
	
	/**
     * Constructor: Geo.Service.GeoWMTS
     * Geo.Service.GeoWMTS类的构造函数
     *
     * Parameters:
     * name - {String} 服务名称
     * url - {String} 服务地址
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		Geo.Service.WMTS.prototype.initialize.apply(this, arguments);
	},
	
	/**
	 * APIMethod: getVersions
	 * 得到服务的版本信息
	 * 
     * Parameters:
     *  params:
     * 	  layer - {String} 图层名称
     *    tileMatrix - {String} 图层层级
     *    tileMatrixSet - {String} 矩阵集名称
     *    tileBox - {String} 行列号范围，格式为“最小列,最小行,最大列,最大行” 如“3,6,7,12”表示获取3-7列、6-12行中所有的瓦片版本ID与名称。
     *    
     * 	options：
     *    content -  {String} 服务返回数据的详细程度 ，当值为"brief"时，返回信息中仅包含版本名称和版本ID；当值为"detail"时，返回信息中会
     *    包含更加详细的版本相关信息，如数据的生产时间，生产单位以及服务的提供单位等信息。当值为"full"时，返回所有信息。默认值是"full"
     *    version - {String} 服务的版本，默认值是"1.0.0"  
     *     
     *  successFn - {Function} 请求成功的回调函数
     *  failFn - {Function} 请求失败的回调函数。
     *  (code)
     *  var serviceObj = new Geo.Service.GeoWMTS("GeoWMTS服务", "http://10.4.6.49:7001/wmts_time_wuhan/wmts");
     *  serviceObj.getVersions({
     *      layer: "wuhan",
     *      tileMatrix: 5,
     *      tileBox: "24,4,27,6",
     *      tileMatrixSet: "Matrix_0" 
     *  }, {
     *      content: "full"
     *  }, function(request){
     *   	alert(request.responseText);  
     *  });
     *  (end)
	 */
	getVersions: function(params, options, successFn, failFn) {
		var url = this.url;
		//下面请求参数中需要增加CONTENT属性
		var DEFAULT_OPTIONS = { 
			content: "full",
			service: "WMTS",
			version: "1.0.0",
			request: "GetVersions"
		};
		OpenLayers.Util.applyDefaults(options, DEFAULT_OPTIONS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(options.request);
			};
		}
		
		OpenLayers.loadURL(url, {
			request: options.request,
			layer: params.layer,
			tileMatrixSet: params.tileMatrixSet,
			tileMatrix: params.tileMatrix,
			tileBox: params.tileBox,
			content: options.content,
			service: options.service,
			version: options.version
			
		}, this, 
		function(request){
			successFn(request);
		},failFn);
	},
	
	/**
	 * APIMethod: GetVersionInfo
	 * 得到服务的版本信息
	 *  说明：getVersions方法也是得到用户版本信息，它是根据行列号范围等参数得到时间版本信息，而GetVersionInfo是根据版本名称等参数得到时间版本信息
	 * 
     * Parameters:
     *  params:
     * 	  layer - {String} 图层名称
     *    versionNames - {String} 多时相版本名称
     *    tileMatrixSet - {String} 矩阵集名称
     *    
     *  options：
     *    content -  {String} 服务返回数据的详细程度 ，当值为"brief"时，返回信息中仅包含版本名称和版本ID；当值为"detail"时，返回信息中会
     *    包含更加详细的版本相关信息，如数据的生产时间，生产单位以及服务的提供单位等信息。当值为"full"时，返回所有信息。默认值是"full"
     *    version - {String} 服务的版本，默认值是"1.0.0"  
     *    
     *  successFn - {Function} 请求成功的回调函数
     *  failFn - {Function} 请求失败的回调函数。
	 */
	getVersionInfo: function(params, options, successFn, failFn) {
		var url = this.url;
		//下面请求参数中需要增加CONTENT属性
		var DEFAULT_OPTIONS = { 
			content: "brief",
			service: "WMTS",
			version: "1.0.0",
			request: "GetVersionInfo"
			
		};
		OpenLayers.Util.applyDefaults(options, DEFAULT_OPTIONS);
		
		OpenLayers.loadURL(url, {
			layer: params.layer,
			versionNames: params.versionNames,
			tileMatrixSet: params.tileMatrixSet,
			content: options.content,
			service: options.service,
			version: options.version,
			request: options.request
		}, this, 
		function(request){
			successFn(request);
		},failFn);
	},

	/**
	 * 
	 */
	CLASS_NAME: "Geo.Service.GeoWMTS"
	
});/**
 * Class: Geo.Service.WCS
 * OGC-WCS服务类。仅支持OGC标准的WCS1.0.0规范。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WCS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WCS
     * Geo.Service.WCS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn, failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WCS"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WCS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: describeCoverage
     * 获取Coverage的描述信息。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WCS标准。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * wcsService.describeCoverage(
     *     {identifiers: "Cov1,Cov2,Cov3"},
     *     function(result){
     *         alert(result.responseText);
     *     }
     * );
     * (end)
     * 
     */	
	describeCoverage: function(params, successFn, failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			SERVICE: "WCS",
			VERSION: "1.0.0",
			REQUEST: "DescribeCoverage"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: getCoverage
     * 获取Coverage内容。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WCS标准。
     *   identifier - {String} 必选 请求标示。
     *   BoundingBox - {String} 必选 请求范围。
     *   format - {String} 必选  数据格式。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * wcsService.getCoverage(
     *     { identifier:"Cov123",
     *       BoundingBox: "-71,47,-66,51,urn:ogc:def:crs:OGC:2:84"
     *       format: "image/netcdf"
     *     },
     *     function(result){
     *         //do something...
     *     }
     * );
     * (end)
     */	
	getCoverage: function(params,successFn,failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			SERVICE: "WCS",
			VERSION: "1.1.2",
			REQUEST: "GetCoverage"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	CLASS_NAME: "Geo.Service.WCS"
});/**
 * Class: Geo.Service.CSW
 * OGC-CSW服务类。
 *
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.CSW = Geo.Class(Geo.Service, {

    /**
     * Constructor: Geo.Service.CSW
     * Geo.Service.CSW类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
    initialize: function(name, url, options){
        Geo.Service.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var content = '<csw:GetCapabilities service="CSW" xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ows="http://www.opengis.net/ows">' +
        '<ows:AcceptVersions>' +
        '<ows:Version>2.0.2' +
        '</ows:Version>' +
        '</ows:AcceptVersions>' +
        '<ows:AcceptFormats>' +
        '<ows:OutputFormat>text/xml</ows:OutputFormat>' +
        '</ows:AcceptFormats>' +
        '</csw:GetCapabilities>';
        
        content = OpenLayers.String.format(this._soapTemplate, {
            soapBody: content
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: content,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "CSW"
        };
        var xhr = OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    
    /**
     * APIMethod: getRecords
     * 获取服务元数据记录。
     *
     * Parameters:
     * content - {String} CSW服务POST请求串，具体格式参考OGC关于CSW服务文档。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getRecords: function(content, successFn, failFn){
    
        content = OpenLayers.String.format(this._getRecordsTemplate, {});
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: content,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    //查询请求串模板
    _getRecordsTemplate: '<?xml version="1.0" encoding="UTF-8"?>' +
    '<csw:GetRecords service="CSW" version="2.0.2" xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ogc="http://www.opengis.net/ogc" xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007" outputFormat="text/xml" resultType="results" outputSchema="smmd:Metadata" startPosition="1" maxRecords="10">' +
    '<csw:Query typeNames="smmd:Metadata">' +
    ' <csw:ElementSetName>full</csw:ElementSetName>' +
    ' <csw:Constraint version="2.0.0">' +
    '<ogc:Filter>' +
    ' <ogc:PropertyIsLike wildCard="*" singleChar="_" escape="\\\">' +
    '<ogc:PropertyName>/smmd:Metadata/smmd:mdFileID</ogc:PropertyName>' +
    '<ogc:Literal>*</ogc:Literal>' +
    '</ogc:PropertyIsLike>' +
    '</ogc:Filter>' +
    '</csw:Constraint>' +
    '</csw:Query>' +
    '</csw:GetRecords>',
    
    //soap格式请求串模板
    _soapTemplate: '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xsi:schemaLocation="http://www.opengis.net/ows" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
    '<soapenv:Body>' +
    '${soapBody}' +
    '</soapenv:Body>' +
    '</soapenv:Envelope>',
    
    /**
     * APIMethod: GetRecordById
     * 根据元数据ID查询服务元数据。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"getRecordById",不区分大小写。
     *   id -{String} 必填,请求检索的元数据ID。例如：ee90cbea-dc5e-4c8d-8225-03b06f5788b1。
     *   service -{String}  必填,服务名称，值必须为CSW。
     *   version -{String}  必填,服务版本号，值必须为2.0.2。
     *	 outputFormat -{String} 必须为一个Mime type ，值必须为application/xml或text/xml。
     *	 outputSchema -{String} 默认值："http://opengis.net/cat/csw/2.0.2" 请求结果的命名空间。
     *   elementSetName -{String} 默认值：summary返回的数据描述，值可为brief，summary，full。当值为brief时返回简明描述;当值为summary时返回概括描述;当值为full时返回全部的元数据信息。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.getRecordById({
     * 		request : "getRecordById",
     *		id : "ee90cbea-dc5e-4c8d-8225-03b06f5788b1",
     *		service: "CSW",
     *		version: "2.0.2",
     *		outputFormat: "Application/xml",
     *		outputSchema: "http://opengis.net/cat/csw/2.0.2",
     *		typeNames: "smmd:Metadata",
     *		elementSetName: "full"
     * });
     * (end)
     */
    getRecordById: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "getRecordById",
            id: options.id ? options.id : "",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            outputFormat: options.outputFormat ? options.outputFormat : "Application/xml",
            outputSchema: options.outputSchema ? options.outputSchema : "http://opengis.net/cat/csw/2.0.2",
            elementSetName: options.elementSetName ? options.elementSetName : "summary"
        };
        var requestStringTemplate = '<csw:GetRecordById service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">' +
        '<csw:Id>${id}</csw:Id>' +
        '<csw:ElementSetName typeNames="smmd:Metadata">${elementSetName}</csw:ElementSetName>' +
        '</csw:GetRecordById >';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            id: optionsTmp.id,
            service: optionsTmp.service,
            version: optionsTmp.version,
            elementSetName: optionsTmp.elementSetName
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: describeRecord
     * 查询服务元数据描述记录。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"describeRecord",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *   nameSpace -{String} 字符串列表，以逗号分隔。用于指定命名空间和前缀。格式是的xmlns（[前缀]命名空间URL）。如果没有指定前缀，那么这是默认的命名空间。
     *	 typeName -{String} 字符串列表，以逗号分隔。要描述一个或多个限定的类型名称。
     *   outputFormat -{String} 显示输出文件的格式必须为一个Mime type ，值必须为application/xml或text/xml。
     *	 schemaLanguage -{String} 零个或一个（可选）默认值是XMLSCHEMA。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.describeRecord({
     * 		request : "getRecordById",
     *		service: "CSW",
     *		version: "2.0.2",
     *		typeName: "smmd:Metadata"
     * });
     * (end)
     */
    describeRecord: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "describeRecord",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            nameSpace: options.nameSpace ? options.nameSpace : "",
            typeName: options.typeName ? options.typeName : "smmd:Metadata",
            outputSchema: options.outputSchema ? options.outputSchema : "application/xml",
            schemaLanguage: options.schemaLanguage ? options.schemaLanguage : "XMLSCHEMA"
        };
        
        var requestStringTemplate = '<csw:DescribeRecord service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">' +
        '<csw:TypeName>${typeName}</csw:TypeName>' +
        '</csw:DescribeRecord >';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            service: optionsTmp.service,
            version: optionsTmp.version,
            typeName: optionsTmp.typeName
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: getDomain
     * 获得域名。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"getDomain",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *   parameterName -{String} 字符串列表，以逗号分隔。无序列表的接口参数的名称。parameterName和propertyName只能有其中一个。
     *	 propertyName -{String} 字符串列表，以逗号分隔。无序的请求的属性名称列表。
     *							（定义信息模型）在搜索属性的情况下，使用不带任何前缀等只有普通的名称（区分大小写），
     *	 						因为这些是唯一定义。例如：分母而不是SpatialResolution.Denominator。
     *							parameterName和propertyName只能有其中一个。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.getDomain({
     * 		request : "getRecordById",
     *		service: "CSW",
     *		version: "2.0.2",
     *		propertyName: "brief"
     * });
     * (end)
     */
    getDomain: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "describeRecord",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            propertyName: options.propertyName ? options.propertyName : "",//brief
            parameterName: options.parameterName ? options.parameterName : ""//GetRecords.ElementSetName
        };
        
        var requestStringTemplate = '<csw:GetDomain service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">';
        if (options.propertyName) {
            requestStringTemplate += '<csw:PropertyName>${propertyName}</csw:PropertyName>';
        }
        if (options.parameterName) {
            requestStringTemplate += '<csw:ParameterName>${parameterName}</csw:ParameterName>';
        }
        requestStringTemplate += '</csw:GetDomain >';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            service: optionsTmp.service,
            version: optionsTmp.version,
            propertyName: optionsTmp.propertyName,
            parameterName: optionsTmp.parameterName
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: transaction
     * 事务操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"transaction",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.transaction({
     * 		request : "getRecordById",
     *		service: "CSW",
     *		version: "2.0.2",
     *		transactionType: "Insert"
     * });
     * (end)
     */
    transaction: function(options, successFn, failFn){
        // insert的参数md_metaData,handle
        
        // update的参数md_metaData,typeName,constraintLanguage,constraint_Language_version,constraint,handle
        
        // delete的参数typeName,constraintLanguage,constraint_Language_version,constraint,handle
        var optionsTmp = {
            request: options.request ? options.request : "transaction",// 必须
            service: options.service ? options.service : "CSW",// 必须
            version: options.version ? options.version : "2.0.2",// 必须
            transaction: options.transaction ? options.transaction : "",
            
            transactionType: options.transactionType ? options.transactionType : "", // 必须 One of “Insert”, “Update”, “Delete”
            requestId: options.requestId ? options.requestId : 0,// 0 or 1
            verboseResponse: options.verboseResponse ? options.verboseResponse : false,
            
            md_metaData: options.md_metaData ? options.md_metaData : "",// 必须
            typeName: options.typeName ? options.typeName : "", // 0 or smmd:Metadata
            constraintLanguage: options.constraintLanguage ? options.constraintLanguage : "", // "CQL_TEXT" or "FILTER"
            constraint_Language_version: options.constraint_Language_version ? options.constraint_Language_version : "",// 必须. 例：1.1.0
            constraint: options.constraint ? options.constraint : "",// 必须. 谓词表达式中指定的语言表示的约束语言参数。
            handle: options.handle ? options.handle : 0// 0 or 1 用于错误处理的目的关联的助记符名称
        };
        
        var requestStringTemplate = '';
        var requestString = "";
        switch (optionsTmp.transactionType) {
            case "Insert":
                requestStringTemplate += '<csw:Transaction xmlns:csw="http://www.opengis.net/cat/csw" version="${version}" service="${service}">' +
                '<csw:Insert xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007" ' +
                'xmlns:wrs="http://www.opengis.net/cat/wrs/1.0" xmlns:gco="http://www.isotc211.org/2005/gco" ' +
                'xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:xlink="http://www.w3.org/1999/xlink" ' +
                'xmlns:srv="http://www.isotc211.org/2005/srv" xmlns:gml="http://www.opengis.net/gml" ' +
                'xmlns:gmx="http://www.isotc211.org/2005/gmx" xmlns:rim="urn:oasis:names:tc:ebxml-regrep:xsd:rim:3.0" ' +
                'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
                '${md_metaData}' +
                '</csw:Insert>' +
                '</csw:Transaction>';
                requestString = OpenLayers.String.format(requestStringTemplate, {
                    service: optionsTmp.service,
                    version: optionsTmp.version,
                    md_metaData: optionsTmp.md_metaData
                });
                break;
            case "Update":
                requestStringTemplate += '<csw:Transaction service="${service}" version="${version}" xmlns:csw="http://www.opengis.net/cat/csw">' +
                '<csw:Update xmlns:srv="http://www.isotc211.org/2005/srv" xmlns:gml="http://www.opengis.net/gml" ' +
                'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:gmd="http://www.isotc211.org/2005/gmd" ' +
                'xmlns:rim="urn:oasis:names:tc:ebxml-regrep:xsd:rim:3.0" xmlns:wrs="http://www.opengis.net/cat/wrs/1.0" ' +
                'xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gmx="http://www.isotc211.org/2005/gmx" ' +
                'xmlns:ogc="http://www.opengis.net/ogc" xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007">' +
                '${md_metaData}' +
                '${constraint}' +
                '</csw:Update>' +
                '</csw:Transaction>';
                requestString = OpenLayers.String.format(requestStringTemplate, {
                    service: optionsTmp.service,
                    version: optionsTmp.version,
                    md_metaData: optionsTmp.md_metaData,
                    constraint: optionsTmp.constraint
                });
                break;
            case "Delete":
                requestStringTemplate += '<csw:Transaction service="${service}" version="${version}" xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007" ' +
                'xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ogc="http://www.opengis.net/ogc">' +
                '<csw:Delete typeName="${typeName}">' +
                '${constraint}' +
                '</csw:Delete>' +
                '</csw:Transaction>';
                requestString = OpenLayers.String.format(requestStringTemplate, {
                    service: optionsTmp.service,
                    version: optionsTmp.version,
                    typeName: optionsTmp.typeName,
                    constraint: optionsTmp.constraint
                });
                break;
                
        }
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
        
    },
    
    /**
     * APIMethod: harvest
     * 查询服务元数据描述记录。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"harvest",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *   nameSpace -{String} 字符串列表，以逗号分隔。用于指定命名空间和前缀。格式是的xmlns（[前缀]命名空间URL）。如果没有指定前缀，那么这是默认的命名空间。
     *	 source -{String} 必填,URI,参考源资源收割。
     *   resourceType -{String} 必填,字符串,参考资源的类型。例如：http://www.isotc211.org/schemas/2005/gmd/。
     *	 resourceFormat -{String} 字符的字符串,表示正在收获的资源格式的MIME类型。
     *	 responseHandler -{String} 可选。
     *	 harvestInterval -{String} 可选。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.describeRecord({
     * 		request : "harvest",
     *		service: "CSW",
     *		version: "2.0.2",
     *		source: "http://10.4.6.23:7001/CSW/csw",
     *		resourceType: "http://data.sbsm.gov.cn/smmd/2007"
     * });
     * (end)
     */
    harvest: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "harvest",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            nameSpace: options.nameSpace ? options.nameSpace : "",//
            source: options.source ? options.source : "",//http://10.4.6.23:7001/CSW/csw
            resourceType: options.resourceType ? options.resourceType : "",//http://data.sbsm.gov.cn/smmd/2007
            resourceFormat: options.resourceFormat ? options.resourceFormat : "",//
            responseHandler: options.responseHandler ? options.responseHandler : "",//D:/
            harvestInterval: options.harvestInterval ? options.harvestInterval : ""//2012-12-22 12:12:12
        };
        
        var requestStringTemplate = '<csw:Harvest service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">';
        requestStringTemplate += '<csw:Source>${source}</csw:Source>';
        requestStringTemplate += '<csw:ResourceType>${resourceType}</csw:ResourceType>';
        if (options.harvestInterval) {
            requestStringTemplate += '<csw:HarvestInterval>${harvestInterval}</csw:HarvestInterval>';
        }
        if (options.responseHandler) {
            requestStringTemplate += '<csw:ResponseHandler>${responseHandler}</csw:ResponseHandler>';
        }
        requestStringTemplate += '</csw:Harvest>';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            service: optionsTmp.service,
            version: optionsTmp.version,
            source: optionsTmp.source,
            resourceType: optionsTmp.resourceType,
            harvestInterval: optionsTmp.harvestInterval,
            responseHandler: optionsTmp.responseHandler
        });
        
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
	
    CLASS_NAME: "Geo.Service.CSW"
});
/**
 * Class: Geo.Service.CWMS
 * CWMS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.CWMS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.CWMS
     * Geo.Service.CWMS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		Geo.Service.prototype.initialize.apply(this, arguments);
		this.format = new OpenLayers.Format.JSON();
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		if(!failFn){
			failFn = function(){
				this.failFn("GetCapabilities");
			};
		}
		OpenLayers.loadURL(this.url,null,this,function(result){
			var res = this.format.read(result.responseText);
			successFn(res);
		},failFn);
	},
	
	/**
	 * APIMethod: GetLayerInfo
	 * 本操作是获取缓存地图服务的图层（单个图层的详细信息），结果以JSON形式返回。
	 * 
	 * Parameters:
	 *   layerId - {String}图层id 必填。
	 *   successFn - {Function} 请求成功的回调函数。
     *   failFn - {Function} 请求失败的回调函数。
     *   
     *   例子:
     *   (code)
     *     serviceObj.getLayerInfo(layers[0].id,
     *        function(result) {
	 *			var obj = new OpenLayers.Format.JSON();
	 *			var res = obj.write(result);
	 *			document.getElementById("serviceCapabilities").innerText = res;
	 *		  });
     *   (end)
	 */
	getLayerInfo : function(layerId,successFn,failFn) {
		var location = this.url.indexOf("/",this.url.length - 1);
		if(location != -1) {
			var url = this.url + layerId;
		}else {
			var url = this.url + "/" + layerId;
		}
		
		if(!failFn){
			failFn = function(){
				this.failFn("GetLayerInfo");
			};
		}
		OpenLayers.loadURL(url,null,this,function(result){
			var res = this.format.read(result.responseText);
			successFn(res);
		},failFn);
				
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: null,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: getMap
     * 获取地图内容操作。
     * 
     * Parameters:
     * 	params - {Object} 
     *    layerId - {String}图层Id 必填。
     *    mapstyleId - {String}当前请求图层样式的唯一编号 必填。
     *    srid -{String} 图层的参考坐标系 必填。
     *    sourceDate - {Date}据的最后更新日期 必填。
     *    level - {Integer}请求图层的层号 必填。
     *    formatSuffix - {String}输出图片格式 必填。
     *    col - {Integer} 瓦片列号 必填。
     *    row - {Integer} 瓦片行号 必填。
     *  
     * Returns:
 	 * {String} 地图内容图片地址。
 	 * 
 	 * 示例:
 	 * (code)
 	 * var url = serviceObj.getMap({
     *     col	: 1506,
	 *	   formatSuffix:"png",
	 *	   layerId	:"GeoGlobeMap_1",
	 *	   level:11,
	 *	   mapStyleId:"GISP:1",
	 *	   row:259	,
	 *	   sourceDate:myDate,
	 *	   srid : "EPSG:4326"
     *  });
     *   (end)
     */	
	getMap: function(params){
		var path =  encodeURIComponent(params.layerId) + "/" + encodeURIComponent(params.mapStyleId) + "/" + 
		encodeURIComponent(params.srid) + "/" +params.sourceDate.getYear() + params.sourceDate.getMonth() + params.sourceDate.getDate() + "/" +
		"L"+ params.level + "/" + params.col+ encodeURIComponent(",") + params.row + "." + params.formatSuffix;
		var location = this.url.indexOf("/",this.url.length - 1);
		if(location != -1) {
			var url = this.url + path;
		}else {
			var url = this.url + "/" + path;
		}
		return url;
	},

	CLASS_NAME: "Geo.Service.CWMS"
});/**
 * Class: Geo.Service.MapService
 * MAPSERVICE-REST服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.MapService = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.MapService
     * Geo.Service.MapService类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			f:"json"
			//callback:"flightHandler"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		this.jsonp.createRequest(url,params, OpenLayers.Function.bind(function(result){
			successFn(result);
		},this));
	},
	/**
	 * 获取查询结果的json表示法
	 * @param {Object} result
	 */
	_getJson: function(result) {
		var resultObj = this.format.read(result.responseText);
		return resultObj;
	},
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			f:"json"
			//callback:"flightHandler"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},

	CLASS_NAME: "Geo.Service.MapService"
});/**
 * Class: Geo.Service.GeoCoding
 * 地址匹配服务
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.GeoCoding = Geo.Class(Geo.Service, {
	
	/**
	 * APIProperty: version
	 * 服务版本，默认值是"1.0.0"。
	 */
	version:"1.0.0",
	
	/**
     * Constructor: Geo.Service.GeoCoding
     * Geo.Service.GeoCoding类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		Geo.Service.prototype.initialize.apply(this, arguments);
		this.format = new OpenLayers.Format.JSON();
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		if(!failFn){
			failFn = function(){
				this.failFn("GetCapabilities");
			};
		}
		var params = {
			request:"GetCapabilities",
			output:"json",
			version:this.version,
			service:"GeoCoding"
		};
		OpenLayers.loadURL(this.url,params,this,function(result) {
			var json = this.format.read(result.responseText);
			successFn({
				result:result,
				json:json
			});
		},failFn);
	},

	CLASS_NAME: "Geo.Service.GeoCoding"
});﻿/**
 * Class: Geo.Service.GeoRoute
 * 路网导航服务类,Geo.Service.Route与Geo.Service.GeoRoute都是路网服务类，建议使用Geo.Service.GeoRoute类。
 * >说明：本类的findRoute方法以及getRouteInfo方法的成功回调中如果包含exceptionInfo节点，则表示服务查询发生异常。
 * >findRoute方法以及getRouteInfo方法成功回调中返回的异常信息包含两个节点（exceptionInfo节点和exceptionCode节点）。
 * >异常信息的数据结构举例：
 * >{
 * >	exceptionInfo:"终点附近无导航链路",
 * >	exceptionCode:"1002"
 * >} 
 * >其中exceptionInfo表示异常信息的描述;exceptionCode表示异常编码;异常编码取值说明：
 * >1000：服务逻辑或功能异常。
 * >1001：服务未配置路网数据集。（当服务未配置路网数据集并且请求FindRoute与GetRouteInfo接口将返回此异常）。
 * >1002：导航查询的两点之间无通路。（请求FindRoute接口如果无解决方案则返回此异常）。
 * >1003：无匹配的路段信息。（请求GetRouteInfo接口如果无关联请求路段ID的内容则返回此异常）。
 * >1004：请求参数内容不正确。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.GeoRoute = Geo.Class(Geo.Service, {
	
	/**
	 * Property: _format
	 * 结果解析器。
	 */
	_format: null,
	
	/**
     * Constructor: Geo.Service.GeoRoute
     * Geo.Service.Route类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 备用参数，目前暂不使用。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		this._format = new Geo.Util.Format.GeoRoute();
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn) {
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		OpenLayers.loadURL(url,params,this,successFn,failFn);
	},
	
	/**
	 * APIMethod:findRoute
	 * 返回请求起始坐标对应路网模型的导航链路信息。
	 * 
	 * Parameters:
	 * options - {Object} 请求参数。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * data - {String} （必选）路网名称。
	 * orig - {String} （必选）起点坐标。   例如："120,30"。
	 * dest -  {String} （必选）终点坐标。
	 * radius — {Number}(可选) 抓取起点与终点距离有效道路的半径范围，单位为米，默认值为10米。
	 * queryType - {Number} (可选)导航查询类型。0表示最快时间；1表示最短路径，默认为按最短路径查询。
	 * midpos - {String}(可选) 途径点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * avoidPos - {String}(可选) 规避点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * filterRoute - {Number}(可选) 导航查询的途径路段类型过滤，可选值：0 – 不进行过滤；1 – 过滤高速公路；2 – 过滤小路；默认值为0。
	 * resultCount - {Number}(可选) 导航查询返回的最大解决方案数目，参数值必须为正整数，参数默认值为1。
     * 
	 * Example:
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new Geo.Service.Route("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.findRoute({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routes){
	 *
	 *			});
	 *   (end)
	 */
	findRoute: function(options, successFn, failFn) {
		var params = {
			REQUEST: "FindRoute",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
        var required = {
            data: true,
            orig: true,
            dest: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("Missing property '" + prop + "'");
            }
        }
		params.DATA = options.data;
		params.ORIG = options.orig;
		params.DEST = options.dest;
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
	  	if(options.radius !== null && options.radius !== undefined){
            params.RADIUS = options.radius;
        }
        
        if(options.queryType !== null && options.queryType !== undefined){
            params.QUERYTYPE = options.queryType;
        }
		
		if(options.midpos !== null && options.midpos !== undefined){
            params.MIDPOS = options.midpos;
        }
		if(options.avoidPos !== null && options.avoidPos !== undefined){
            params.AVOIDPOS = options.avoidPos;
        }
		if(options.filterRoute !== null && options.filterRoute !== undefined){
            params.FILTERROUTE = options.filterRoute;
        }
		if(options.resultCount !== null && options.resultCount !== undefined){
            params.RESULTCOUNT = options.resultCount;
        }
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var routes = this._format.read(result.responseText);
				//处理异常情况，当发生异常时，直接返回异常串
				if(typeof routes.exceptionInfo === "string") {
					 successFn(routes);
					 return;
				}
				var routeInfo = new Geo.Service.GeoRoutesResult(routes);
                successFn(routeInfo);
            },
            failure: failFn
        });
	},
	
	/**
	 * APIMethod:getRouteInfo
	 * 返回请求编号查询到路段的详细信息。
	 * 
	 * Parameters:
	 * options - {Object} 请求参数。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * data - {String} （必选）路网名称
	 * id - {String} （必选）查询路段的ID名称，可以有0个或多个，多个ID之间以逗号分隔。
	 * 
	 * Example:
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new Geo.Service.Route("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.getRouteInfo({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routeInfo){});
	 *   (end)
	 */
	getRouteInfo: function(options, successFn, failFn) {
		var params = {
			REQUEST: "GetRouteInfo",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
		if(!options.data || !options.id){
            throw "Error!Not data and id for bus query.";
            return;
        }
		params.DATA = options.data;
		params.ID = options.id;
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var routeInfo = this._format.read(result.responseText);
				//处理异常情况，当发生异常时，直接返回异常串
				if(typeof routeInfo.exceptionInfo === "string") {
					 successFn(routeInfo);
					 return;
				}
				routeInfo = new Geo.Service.GeoRouteInfoResult(routeInfo);
            	successFn(routeInfo);
            },
            failure: failFn
        });
	},	

	CLASS_NAME: "Geo.Service.GeoRoute"
	
});

/**
 * Class: Geo.Util.Format.GeoRoute
 * 路网导航查询结果解析类，本类供内部调用，用户一般无需使用。
 */
Geo.Util.Format.GeoRoute = new Geo.Class(Geo.Format.XML,{

	/**
	 * Constructor: Geo.Util.Format.GeoRoute
	 * 构造函数。
	 * 
	 * Parameters:
	 * data - {Object} 服务端生成的原始JSON数据。
	 */
    initialize: function(options) {
        OpenLayers.Format.XML.prototype.initialize.apply(this, [options]);
    },

	/**
	 * APIMethod: read
	 * 读入服务端响应的XML内容并解析为JSON对象返回。
	 * 
	 * Parameters:
	 * data - {String} 服务端响应的XML。
	 * 
     * Returns:
     * {Object | String} JSON对象
     * 说明：当返回结果为字符串时表示查询发生异常。
     */	
    read: function(data) {
        var result = {};
		var routes = [];
		var dataTemp = data;
        if(typeof data == "string") {
			//调用父类的read方法。将xml串转换为dom对象。
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            routes = [];
			//获得根节点名称
			var elName = Geo.Format.XML.prototype.getChildEl.apply(this, [data]).nodeName;
			//处理异常情况：
			if("ServiceExceptionReport" === elName) {
				//var serviceException = data.getElementsByTagName("ogc:ServiceException")[0];
				var serviceException = Geo.Format.XML.prototype.getElementsByTagNameNS(data, "*", "ServiceException")[0];
				var text = Geo.Format.XML.prototype.getChildValue.apply(this, [serviceException]);
				var code = serviceException.getAttribute("code");
				return {
					exceptionInfo: text,
					exceptionCode: code
				};
			}
			
			//获取跟节点的子元素
			var nodes = data.getElementsByTagName(elName)[0].childNodes;
			//Todo 如果elName不带前缀的，取整个elName。如果elName带前缀的，则取前缀之后的名称。
			//var nodes = Geo.Format.XML.prototype.getElementsByTagNameNS(data, "*", elName)[0];
			//遍历子节点
            for(var i=0; i<nodes.length; i++){
                var node = nodes[i];
				//获取节点名称
                var nodeName = node.nodeName;
				//判断方法是否存在
                if(this._resultPaser[elName][nodeName]) {
					//使用apply方法改变调用方法的上下文环境
					this._resultPaser[elName][nodeName].apply(this, [node, routes]);
                }
            }
        }
		elName = elName.toLowerCase();
		if("routeinfo" === elName) {
			result["items"] = routes;
		}else {
			result[elName] = routes;
		}
		
        return result;
    },
	
	/**
	 * Property: _resultPaser
	 * 查询结果解析器。
	 */
    _resultPaser: {
		"RouteInfo":{
			"Item": function(node, obj) {
				var nodes = node.childNodes;
				var id = node.getAttribute("id");
	            var item = {};
				if(id) {
					item = {
						id: id
					}
				}
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["RouteInfo"][nodeName]){
						this._resultPaser["RouteInfo"][nodeName].apply(this, [node,item]);
	                }
	            }
				obj.push(item);
			},
	        "Name": function(node, obj){
				//调用父类的getChildValue方法，并且使用本对象的上下文环境。
				var name = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            if(name) {
	                obj.name = name;
	            }
	        },
	        "Toll": function(node, obj){
				var toll = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.toll = toll;
	        },
			"Level": function(node, obj) {
				var level = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
				obj.level = level;
			},
			"Length": function(node, obj) {
				var length = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.length = length;
			},
			"Geometry": function(node, obj) {
				//获取gml:LineString节点对象。
				//var geometryDom = node.getElementsByTagName("gml:LineString")[0];//chrome下解析不到
				var geometryDom = Geo.Format.XML.prototype.getElementsByTagNameNS(node, "*", "LineString")[0];
				if(geometryDom) {
					var text = Geo.Format.XML.prototype.getChildValue.apply(this, [geometryDom]);
					if(typeof text === "string" && text.length > 0) {
						var pointArrStr = text.split(" ");
						var points = [];
						for(var i = 0, len = pointArrStr.length; i < len; i++) {
							var pois = pointArrStr[i].split(",");
							points.push(new Geo.Geometry.Point(new Number(pois[0]),new Number(pois[1])));
						}
						var lineString = new Geo.Geometry.LineString(points);
						obj.geometry = lineString;
					}
				}
			},
			"Directions": function(node, obj) {
				obj.directions = [];
				var nodes = node.childNodes;
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["RouteInfo"][nodeName]){
	                    this._resultPaser["RouteInfo"][nodeName](node,obj.directions);
	                }
	            }
			},
			"Direction": function(node, obj) {
				var dir = {};
				var direction = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            dir.direction = direction;
				//获取节点的属性值
				dir.nextID = node.getAttribute("nextID");
				dir.nextItem = node.getAttribute("nextItem");
				obj.push(dir);
			}
			//TODO：是否还有可选属性没有加进来，待查
	    },
		"Routes": {
			"Route": function(node, obj) {
				var nodes = node.childNodes;
	            var route = {};
	            for(var i=0; i<nodes.length; i++){
	                var node = nodes[i];
					var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,route]);
	                }
	            }
				obj.push(route);
			},
			"Item": function(node, obj) {
				if(!Geo.Util.isArray(obj.items)) {
					obj.items = [];
				}
				var nodes = node.childNodes;
				var id = node.getAttribute("id");
				var item = {};
				if(id) {
					item = {
						id: id
					}
				}
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,item]);
	                }
	            }
				obj.items.push(item);
			},
			"Distance": function(node, obj){
				var distance = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.distance = distance;
			},
			"Name": function(node, obj){
				var name = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            if(name) {
	                obj.name = name;
	            }
	        },
			"Length": function(node, obj) {
				var length = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.length = length;
			},
			"Direction": function(node, obj) {
				var dir = {};
				var direction = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            dir.direction = direction;
				dir.nextID = node.getAttribute("nextID");
				dir.nextItem = node.getAttribute("nextItem");
				obj.direction = dir;
			},
			"Geometry": function(node, obj) {
				//var geometryDom = node.getElementsByTagName("gml:LineString")[0];//chrome下解析不到
				var geometryDom = Geo.Format.XML.prototype.getElementsByTagNameNS(node, "*", "LineString")[0];
				if(geometryDom) {
					var text = Geo.Format.XML.prototype.getChildValue.apply(this, [geometryDom]);
					if(typeof text === "string" && text.length > 0) {
						var pointArrStr = text.split(" ");
						var points = [];
						for(var i = 0, len = pointArrStr.length; i < len; i++) {
							var pois = pointArrStr[i].split(",");
							points.push(new Geo.Geometry.Point(new Number(pois[0]),new Number(pois[1])));
						}
						var lineString = new Geo.Geometry.LineString(points);
						obj.geometry = lineString;
					}
				}
			},
			"Duration": function(node, obj) {
				var duration = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.duration = duration;
			},
			"BoundingBox": function(node, obj) {
				var nodes = node.childNodes;
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,obj]);
	                }
	            }
			},
            "LowerCorner": function(node, obj) {
				var str = Geo.Format.XML.prototype.getChildValue.apply(this, [node]).replace(
                    (/^\s*|\s*$/g), "");
                str = str.replace((/\s*,\s*/g), ",");
                var pointList = str.split(",");
                obj.left = pointList[0];
                obj.bottom = pointList[1];
            },
            "UpperCorner": function(node, obj) {
				var str = Geo.Format.XML.prototype.getChildValue.apply(this, [node]).replace(
                    (/^\s*|\s*$/g), "");
                str = str.replace((/\s*,\s*/g), ",");
                var pointList = str.split(",");
                obj.right = pointList[0];
                obj.top = pointList[1];
                obj.bounds = new OpenLayers.Bounds(obj.left, obj.bottom,
                    obj.right, obj.top);
				//left,bottom,right,top只是临时使用，所以用完后需要清掉。
                delete obj.left;
                delete obj.bottom;
                delete obj.right;
                delete obj.top;
            },
			"Count": function(node, obj) {
				var count = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.count = count;
			}
		}
	}
});﻿/**
 * Class: Geo.Service.GeoRouteInfoResult
 * 路段信息结果类。用于记录路段所在道路的详细信息。
 */
Geo.Service.GeoRouteInfoResult = Geo.Class({
	
	/**
	 * APIProperty: data
	 * {Object}解析服务返回的XML后，得到的完整JSON对象。
	 */
	data: null,
	
	/**
	 * APIProperty: items
	 * {Array(Geo.Service.GeoRouteInfoItem)}
	 * 路段数组。
	 */
	items: null,
	
	/**
     * Constructor: Geo.Service.GeoRouteInfoResult
     * Geo.Service.GeoRouteInfoResult类的构造函数。
     *
     * Parameters:
     * data - {Object} JSON对象。
     */
	initialize: function(data) {
		this.items = [];
		if(data && data.items) {
			this.data = data;
			var items = data.items;
		}
		if(Geo.Util.isArray(items)){
			for(var i = 0, len = items.length;i < len; i++) {
				var routeInfoItem = new Geo.Service.GeoRouteInfoItem();
				for(var route in items[i]) {
					routeInfoItem[route] = items[i][route];
				}
				this.items.push(routeInfoItem);
			}
        }
	},

	CLASS_NAME: "Geo.Service.GeoRouteInfoResult"
	
});

/**
 * Class: Geo.Service.GeoRouteInfoItem
 * 路段对象。从出发点到目的地的路程由一个或多个路段组成。
 */
Geo.Service.GeoRouteInfoItem = Geo.Class({
	
	/**
	 * APIProperty: id
	 * {String}路段编号。
	 */
	id:  null,
	
	/**
	 * APIProperty: name
	 * {String}路段名称。
	 */
	name: null,
	
	/**
	 * APIProperty: toll
	 * {Number}路段收费信息，元素值定义：
	 *	0 – 免费路段；
	 *	1 – 部分收费路段；
	 *	2 – 收费路段。
	 *	（路段收费信息匹配路网数据库的特定属性，如果没有该属性则默认值为“0”免费路段）
	 */
	toll: null,
	
	/**
	 * APIProperty: length
	 * {Number}路段行驶的里程，单位为米。
	 */
	length: null,
	
	/**
	 * APIProperty: geometry
	 * {Geo.Geometry}线路几何信息。
	 */
	geometry: null,
	
	/**
	 * APIProperty: level
	 * {String}道路级别，由路网数据库定义。
	 *	（路段级别一般标识路段的类型；例如路段级别分为1-3级，级别1为普通小路，级别2为城镇公路，级别3为高速公路；如果路网数据库未指定路段级别则默认值为0）
	 */
	level: null,
	
	/**
	 * APIProperty: directions
	 * {Array{Object}} 
	 * 路段朝向。
	 * 
	 * 数组中的对象结构举例:
	 * [
	 * 	{
	 *  	nextID: "4211",
	 *  	nextItem: "红钢二街",
	 *  	direction: 1
	 *  }
	 * ]
	 * 
	 * 示例中节点说明：
	 * direction:方位,0代表正西方向，7代表西北方向，4代表正北方向，2代表东北方向，1代表正东方向，3代表东南方向，5代表正南方向，8代表西南方向。
	 * nextID:下一路段编号
	 * nextItem:下一路段名称
	 */
	directions: null,
	
	/**
     * Constructor: Geo.Service.GeoRouteInfoItem
     * Geo.Service.GeoRouteInfoItem类的构造函数。
     */
	initialize: function() {
		
	},

	CLASS_NAME: "Geo.Service.GeoRouteInfoItem"
	
});﻿/**
 * Class: Geo.Service.GeoRoutesResult
 * 导航链路信息结果对象。结果对象中包含起点到目的地的所有行走方案。
 */
Geo.Service.GeoRoutesResult = Geo.Class({
	
	/**
	 * APIProperty: data
	 * {Object}解析服务返回的XML后，得到的完整JSON对象。
	 */
	data: null,
	
	/**
	 * APIProperty: routes
	 * {Array(Geo.Service.GeoRouteResult)}  起点到终点的所有行走方案。
	 */
	routes: null,
	
	/**
     * Constructor: Geo.Service.GeoRoutesResult
     * Geo.Service.GeoRoutesResult类的构造函数。
     *
     * Parameters:
     * data - {Object} JSON对象
     *
     */
	initialize: function(data) {
		this.routes = [];
		var routes = null;
		if(data && data.routes) {
			this.data = data;
			routes = data.routes;
		}
		if(Geo.Util.isArray(routes)) {
			for(var i = 0, len = routes.length;i < len; i++) {
				var routeObj = new Geo.Service.GeoRouteResult();
				for(var route in routes[i]) {
					routeObj[route] = routes[i][route];
				}
				this.routes.push(routeObj);
			}
        }
	},

	CLASS_NAME: "Geo.Service.GeoRoutesResult"
	
});

/**
 * Class: Geo.Service.GeoRouteResult
 * 起到到终点的一条行走方案。
 */
Geo.Service.GeoRouteResult = Geo.Class({
	
	/**
	 * APIProperty: bounds
	 * {Geo.Bounds}两点间的一条通路的范围
	 */
	bounds: null,
	
	/**
	 * APIProperty: count
	 * {Integer}导航线路包含的路段总数。
	 */
	count: null,
	
	/**
	 * APIProperty: distance
	 * {Number}导航线路总里程，单位为米。
	 */
	distance: null,
	
	/**
	 * APIProperty: duration
	 * {Integer}导航行驶总时间，单位为分钟。
	 *	（导航行驶总时间根据由总里程换算而来，具体换算公式由服务定制）
	 */
	duration: null,
	
	/**
	 * APIProperty: geometry
	 * {Geo.Geometry}线路的几何信息。
	 */
	geometry: null,
	
	/**
	 * APIProperty: items
	 * {Array{object}} 
	 * 	路段元素，可以有零或多个；每个元素包含一个属性id，标识路段的唯一编号；
	 * 	如果路段不在道路上（如起点到某条道路），将不包含路段编号与路段名称。
	 * 
	 * 数组中的对象结构举例:
	 * {
	 * 	id:"33",
	 * 	length: "161",
	 * 	name: "玉兰路",
	 * 	geometry:值为Geo.Geometry对象,
	 * 	direction: {
	 * 		text:"4",
	 * 		nextID:"8414",
	 * 		nextItem:"佳园路"
	 * 	}
	 * }
	 * 示例中节点说明：
	 * id: 路段id
	 * name:路段名称
	 * length：路段总长，单位为米
	 * geometry:路段行走路线
	 * text:方位,0代表正西方向，7代表西北方向，4代表正北方向，2代表东北方向，1代表正东方向，3代表东南方向，5代表正南方向，8代表西南方向。
	 * nextID:下一路段编号
	 * nextItem:下一路段名称
	 * 
	 */
	items: null,
	
	/**
     * Constructor: Geo.Service.GeoRouteResult
     * Geo.Service.GeoRouteResult类的构造函数。
     */
	initialize: function() {
		
	},

	CLASS_NAME: "Geo.Service.GeoRouteResult"
	
});
﻿/**
 * Class: Geo.Service.GeoText
 * 文字服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.GeoText = Geo.Class(Geo.Service, {
	
	/**
	 * APIProperty: data
	 * {Object}文字服务能力描述信息的JSON对象（请求Geo.Service.GeoText类的对象的getCapabilities方法可以得到JSON对象）。
	 */
	data: null,
	
	/**
	 * APIProperty: version
	 * {String}服务版本。
	 */
	version:"1.0.0",
	
	/**
     * Constructor: Geo.Service.GeoText
     * Geo.Service.GeoText类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称
     * url - {String} 服务地址
     * options - {Object} 实例的选项设置，此参数可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	initialize: function(name, url, options) {
		Geo.Service.prototype.initialize.apply(this, arguments);
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn) {
		if(!failFn){
			failFn = function(){
				this.failFn("Root接口");
			};
		}
		var params = {
			f: "json",
			service:"TEXT",
			version:"1.0.0"
		};
		params.version = this.version;
		var xhr = OpenLayers.Request.GET({
            url: this.url,
			params: params,
            scope: this,
			async: false,
            success: function(result){
				var resultJson = OpenLayers.Format.JSON.prototype.read.apply(this, [result.responseText]);
                this.data = resultJson;
				successFn(resultJson);
            }
        });
	},
	
		
	/**
	 * Method:getTextStyleByTextRendition
	 * 将TextRedition标签中的部分元素转换为要素的style样式。
	 * 
	 * Parameters:
	 * textRendition {Object} 文字标注样式。
	 * 
	 * Returns:
     * {Object} 文字标注样式。
	 */
	getTextStyleByTextRendition: function(textRendition) {
		var style = {};
		var styleTemp = {};
	//	var featureStyle = Geo.Util.extend({},Geo.Feature.Vector.style['default']);
		var fontName = textRendition.FontName;
		//字体颜色
		var fontColor = textRendition.Color.Value;
		//字体透明度
		var fontOpacity = textRendition.Color.Transparent;
		//是否为粗体
		var isBold = textRendition.IsBold;
		var fontWeight = isBold ? "bold" : "normal";
		
		//TODO：文字标注背景颜色不支持
		//var bgfontColor = textRendition.BGColor.Value;
		//文字标注背景透明度不支持
		//var bgTransparent = textRendition.BGColor.Transparent;
		//字体样式
		if(textRendition.FontStyle === "Normal") {
			styleTemp.fontStyle = "normal";
		}else if(textRendition.FontStyle === "RightItalic") {
			styleTemp.fontStyle = "italic";
		}
		//TODO:字体样式倾斜角度不支持：FontStyleAngle
		//文字标注偏移
		var labelXOffset = textRendition.OffsetX;
		var labelYOffset = textRendition.OffsetY;
		//文字是否有下划线IsUnderLine，此属性目前无法不支持
		//文字是否有删除线：IsStrikeoutLine，此属性目前无法不支持
		//文字是否为粗体，此属性目前无法不支持
		//文字背景是否为透明IsBGTransparent，此属性目前无法支持；
		//这几个属性目前不支持：IsHollow，IsShadow，ShadowColor，ShadowOffsetX，ShadowOffsetY，Width，Height，HorizontalSpacing，VerticalSpacing
		//Rotation,VerticalAlign,HorizonAlign,IsBGTransparent，isvisible
		//字体宽度,高度，TODO：目前是默认宽度高度一样
		var fontSize = parseInt(textRendition.Width * 4) +"px";
		//文字标注的样式
		style = {
			fontFamily: fontName,
			fontColor: fontColor,//fontColor,//fontColor,"red"
			fontOpacity: fontOpacity,
			fontWeight: fontWeight,
			labelXOffset: labelXOffset,
			labelYOffset: labelYOffset,
			fontSize: fontSize
		}
		OpenLayers.Util.extend(style, styleTemp);
		return style;
	},
	
	/**
	 * Method: getTextStyleByLabelRenditionID
	 * 根据文字标注画法ID得到文字标注样式。
	 * 
	 * Parameters:
	 * id - {Array(String)}渲染器id
	 * 
	 * Returns:
     * {Object} 文字标注样式。
	 */
	getTextStyleByLabelRenditionID: function(id) {
		var rendition = this.data.rendition;
		for(var i = 0, len = rendition.length; i < len; i++) {
			if(rendition[i].renditionID === id) {
				var textStyle = this.getTextStyleByTextRendition(rendition[i].TextRendition);
				var maxCharactersPerLine = this.getMaxCharactersPerLine(rendition[i]);
				if(typeof maxCharactersPerLine === "number") {
					textStyle.maxCharactersPerLine = maxCharactersPerLine;
				}
				return textStyle;
			}
		}
	},
	
	/**
	 * Method: getMaxCharactersPerLine
	 * 获取图层的文字标注每行最大显示多少条。
	 * 
	 * Parameters:
	 * rendition - {Object}渲染相关参数
	 * 
	 * Returns:
     * {Integer} 每行最大显示多少字。
	 */
	getMaxCharactersPerLine: function(rendition) {
		var eachLine = null;
		if(rendition.WrapStyle && rendition.WrapStyle.MaxCharactersPerLine) {
			 eachLine = rendition.WrapStyle.MaxCharactersPerLine.enable;
		}
		return eachLine;
	},
	
	/**
	 * APIMethod:getTextStylesByLayerIds
	 * 根据图层id获取图层样式。
	 * 
 	 * Parameters:
 	 * data - 文字服务能力描述信息的JSON对象（请求本对象的getCapabilities方法可以得到JSON对象）。
	 * ids - {Array(Number)}图层ID。
	 * 
	 * Returns:
     * {Object} 图层名称与图层样式键值对。
	 */
	getTextStylesByLayerIds: function(data,ids) {
		var dataTableNames = {};
		var layers = data.layers;
		if(typeof ids === "number") {
			ids = [ids];
		}
		if(!Geo.Util.isArray(ids)) {
			return dataTableNames;
		}
		//得到图层名与图层样式id的键值对
		for(var i = 0; i < ids.length;i++) {
			for(var j = 0, len = layers.length; j < len;j++) {
				if(ids[i] === layers[j].id) {
					dataTableNames[layers[j]["dataTableName"]] = layers[j]["labelRenditionID"];
					continue;
				}
			}
		}
		var dataTableNameReditionId = {};
		//得到图层名与样式的键值对
		for(var dataTableName in dataTableNames) {
			var style = this.getTextStyleByLabelRenditionID(dataTableNames[dataTableName]);
			dataTableNameReditionId[dataTableName] = style;
		}
		return dataTableNameReditionId;
	},
	
	CLASS_NAME: "Geo.Service.GeoText"
	
});
/**
 *  Class: Geo.Service.Thematic
 *  专题图服务类
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.Thematic = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.Thematic
     * Geo.Service.Thematic类的构造函数
     *
     * Parameters:
     * name - {String} 服务名称
     * url - {String} 服务地址
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options) {
		this.name = name;
		this.url = url;
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			f:"json"
		};
		if(!failFn){
			failFn = function(){
				this.failFn();
			};
		}
		this.jsonp.createRequest(url,params, OpenLayers.Function.bind(function(result){
			successFn(result);
		},this));
	},
	
	/**
	 * APIMethod:getLegend
	 * Parameters:
	 * url - {String} 服务地址。
	 * layerID - {String} 图层ID。
	 * chartID - {String} 专题符号标识。
	 * format - {String} 返回的样式。
	 * colorSchemaID - {String} 色卡标识
	 * 
	 * Returns:
     * {String} 得到图例地址。
	 */
	getLegend: function(options) {
		//http://192.168.42.76:7021/ThematicMapService/tms/legend/0/020101.png?ColorSchemaID=3
		var location = options.url.indexOf("/",options.url.length - 1);
		if(location != -1) {
			options.url = options.url.substr(0,options.url.length - 1);
		}
		var path =  "${url}/legend/${layerID}/${chartID}.${format}";//?colorSchemaID = ${colorSchemaID}
		path = Geo.String.format(path, {
			'url': options.url, 
			'layerID': options.layerID, 
			'chartID': options.chartID,
			'format': options.format || "png"
		});
		if(typeof options.colorSchemaID === "string") {
			path += ("?colorSchemaID=" + options.colorSchemaID);
		}
		return path;
	},
	
	
	//异常
	//xxxxxx

	CLASS_NAME: "Geo.Service.Thematic"
});
/**
 * APIMethod: setProxyHost
 * 设置代理地址,根据自己的代理器地址来配置
 * 
 * Parameters:
 * proxyHost - {String} 代理地址
 * 
 */
Geo.Request.setProxyHost = function(proxyHost){
	OpenLayers.ProxyHost = proxyHost;
}

/**
 * APIMethod: getProxyHost
 * 代理地址
 *
 * Returns:
 * {String} 代理地址
 */
Geo.Request.getProxyHost = function(){
	return OpenLayers.ProxyHost;
}